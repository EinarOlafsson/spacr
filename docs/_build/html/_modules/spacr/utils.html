

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spacr.utils &mdash; spacr 1.0.8 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=45a07ac9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=aec50437"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #005f73" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo_spacr.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Core Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/core/index.html">Core Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/core/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/core/index.html#spacr.core.preprocess_generate_masks"><code class="docutils literal notranslate"><span class="pre">preprocess_generate_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/core/index.html#spacr.core.generate_cellpose_masks"><code class="docutils literal notranslate"><span class="pre">generate_cellpose_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/core/index.html#spacr.core.generate_screen_graphs"><code class="docutils literal notranslate"><span class="pre">generate_screen_graphs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/io/index.html">IO Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/io/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.process_non_tif_non_2D_images"><code class="docutils literal notranslate"><span class="pre">process_non_tif_non_2D_images()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombineLoaders"><code class="docutils literal notranslate"><span class="pre">CombineLoaders</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombineLoaders.train_loaders"><code class="docutils literal notranslate"><span class="pre">CombineLoaders.train_loaders</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombineLoaders.loader_iters"><code class="docutils literal notranslate"><span class="pre">CombineLoaders.loader_iters</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombineLoaders.__iter__"><code class="docutils literal notranslate"><span class="pre">CombineLoaders.__iter__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombineLoaders.__next__"><code class="docutils literal notranslate"><span class="pre">CombineLoaders.__next__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset"><code class="docutils literal notranslate"><span class="pre">CombinedDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.datasets"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.datasets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.lengths"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.lengths</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.total_length"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.total_length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.shuffle"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.shuffle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.__getitem__"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.__getitem__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.CombinedDataset.__len__"><code class="docutils literal notranslate"><span class="pre">CombinedDataset.__len__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset"><code class="docutils literal notranslate"><span class="pre">NoClassDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.data_dir"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.data_dir</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.transform"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.transform</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.shuffle"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.shuffle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.load_to_memory"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.load_to_memory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.filenames"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.filenames</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.load_image"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.load_image()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.__len__"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.__len__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.shuffle_dataset"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.shuffle_dataset()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.NoClassDataset.__getitem__"><code class="docutils literal notranslate"><span class="pre">NoClassDataset.__getitem__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset"><code class="docutils literal notranslate"><span class="pre">spacrDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.data_dir"><code class="docutils literal notranslate"><span class="pre">spacrDataset.data_dir</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.classes"><code class="docutils literal notranslate"><span class="pre">spacrDataset.classes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.transform"><code class="docutils literal notranslate"><span class="pre">spacrDataset.transform</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.shuffle"><code class="docutils literal notranslate"><span class="pre">spacrDataset.shuffle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.pin_memory"><code class="docutils literal notranslate"><span class="pre">spacrDataset.pin_memory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.filenames"><code class="docutils literal notranslate"><span class="pre">spacrDataset.filenames</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.labels"><code class="docutils literal notranslate"><span class="pre">spacrDataset.labels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.load_image"><code class="docutils literal notranslate"><span class="pre">spacrDataset.load_image()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.__len__"><code class="docutils literal notranslate"><span class="pre">spacrDataset.__len__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.shuffle_dataset"><code class="docutils literal notranslate"><span class="pre">spacrDataset.shuffle_dataset()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.get_plate"><code class="docutils literal notranslate"><span class="pre">spacrDataset.get_plate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataset.__getitem__"><code class="docutils literal notranslate"><span class="pre">spacrDataset.__getitem__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.preload_batches"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.preload_batches</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.batch_queue"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.batch_queue</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.process"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.process</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.current_batch_index"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.current_batch_index</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.pin_memory"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.pin_memory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.__iter__"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.__iter__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.__next__"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.__next__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.cleanup"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.cleanup()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.spacrDataLoader.__del__"><code class="docutils literal notranslate"><span class="pre">spacrDataLoader.__del__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset"><code class="docutils literal notranslate"><span class="pre">TarImageDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset.members"><code class="docutils literal notranslate"><span class="pre">TarImageDataset.members</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset.tar_path"><code class="docutils literal notranslate"><span class="pre">TarImageDataset.tar_path</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset.transform"><code class="docutils literal notranslate"><span class="pre">TarImageDataset.transform</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset.__len__"><code class="docutils literal notranslate"><span class="pre">TarImageDataset.__len__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.TarImageDataset.__getitem__"><code class="docutils literal notranslate"><span class="pre">TarImageDataset.__getitem__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.load_images_from_paths"><code class="docutils literal notranslate"><span class="pre">load_images_from_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.concatenate_and_normalize"><code class="docutils literal notranslate"><span class="pre">concatenate_and_normalize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.delete_empty_subdirectories"><code class="docutils literal notranslate"><span class="pre">delete_empty_subdirectories()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.preprocess_img_data"><code class="docutils literal notranslate"><span class="pre">preprocess_img_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.read_plot_model_stats"><code class="docutils literal notranslate"><span class="pre">read_plot_model_stats()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.convert_numpy_to_tiff"><code class="docutils literal notranslate"><span class="pre">convert_numpy_to_tiff()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.generate_cellpose_train_test"><code class="docutils literal notranslate"><span class="pre">generate_cellpose_train_test()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.parse_gz_files"><code class="docutils literal notranslate"><span class="pre">parse_gz_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.generate_dataset"><code class="docutils literal notranslate"><span class="pre">generate_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.generate_loaders"><code class="docutils literal notranslate"><span class="pre">generate_loaders()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.generate_training_dataset"><code class="docutils literal notranslate"><span class="pre">generate_training_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.training_dataset_from_annotation"><code class="docutils literal notranslate"><span class="pre">training_dataset_from_annotation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.training_dataset_from_annotation_metadata"><code class="docutils literal notranslate"><span class="pre">training_dataset_from_annotation_metadata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.generate_dataset_from_lists"><code class="docutils literal notranslate"><span class="pre">generate_dataset_from_lists()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.convert_separate_files_to_yokogawa"><code class="docutils literal notranslate"><span class="pre">convert_separate_files_to_yokogawa()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.convert_to_yokogawa"><code class="docutils literal notranslate"><span class="pre">convert_to_yokogawa()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.apply_augmentation"><code class="docutils literal notranslate"><span class="pre">apply_augmentation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.process_instruction"><code class="docutils literal notranslate"><span class="pre">process_instruction()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/io/index.html#spacr.io.prepare_cellpose_dataset"><code class="docutils literal notranslate"><span class="pre">prepare_cellpose_dataset()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/utils/index.html">General Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/utils/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.spacr_path"><code class="docutils literal notranslate"><span class="pre">spacr_path</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.filepaths_to_database"><code class="docutils literal notranslate"><span class="pre">filepaths_to_database()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.activation_maps_to_database"><code class="docutils literal notranslate"><span class="pre">activation_maps_to_database()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.activation_correlations_to_database"><code class="docutils literal notranslate"><span class="pre">activation_correlations_to_database()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.calculate_activation_correlations"><code class="docutils literal notranslate"><span class="pre">calculate_activation_correlations()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.load_settings"><code class="docutils literal notranslate"><span class="pre">load_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.save_settings"><code class="docutils literal notranslate"><span class="pre">save_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.print_progress"><code class="docutils literal notranslate"><span class="pre">print_progress()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.reset_mp"><code class="docutils literal notranslate"><span class="pre">reset_mp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.is_multiprocessing_process"><code class="docutils literal notranslate"><span class="pre">is_multiprocessing_process()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.close_file_descriptors"><code class="docutils literal notranslate"><span class="pre">close_file_descriptors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.close_multiprocessing_processes"><code class="docutils literal notranslate"><span class="pre">close_multiprocessing_processes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.check_mask_folder"><code class="docutils literal notranslate"><span class="pre">check_mask_folder()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.smooth_hull_lines"><code class="docutils literal notranslate"><span class="pre">smooth_hull_lines()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.mask_object_count"><code class="docutils literal notranslate"><span class="pre">mask_object_count()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.is_list_of_lists"><code class="docutils literal notranslate"><span class="pre">is_list_of_lists()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.normalize_to_dtype"><code class="docutils literal notranslate"><span class="pre">normalize_to_dtype()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.annotate_conditions"><code class="docutils literal notranslate"><span class="pre">annotate_conditions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.Cache"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.Cache.cache"><code class="docutils literal notranslate"><span class="pre">Cache.cache</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.Cache.max_size"><code class="docutils literal notranslate"><span class="pre">Cache.max_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.Cache.get"><code class="docutils literal notranslate"><span class="pre">Cache.get()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.Cache.put"><code class="docutils literal notranslate"><span class="pre">Cache.put()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention_v1</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1.d_k"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention_v1.d_k</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1.forward"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention_v1.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_q"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1.W_q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_k"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1.W_k</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_v"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1.W_v</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.attention"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1.attention</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.forward"><code class="docutils literal notranslate"><span class="pre">SelfAttention_v1.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention.d_k"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention.d_k</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention.forward"><code class="docutils literal notranslate"><span class="pre">ScaledDotProductAttention.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention"><code class="docutils literal notranslate"><span class="pre">SelfAttention</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_q"><code class="docutils literal notranslate"><span class="pre">SelfAttention.W_q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_k"><code class="docutils literal notranslate"><span class="pre">SelfAttention.W_k</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_v"><code class="docutils literal notranslate"><span class="pre">SelfAttention.W_v</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.attention"><code class="docutils literal notranslate"><span class="pre">SelfAttention.attention</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.forward"><code class="docutils literal notranslate"><span class="pre">SelfAttention.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion"><code class="docutils literal notranslate"><span class="pre">EarlyFusion</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion.conv1"><code class="docutils literal notranslate"><span class="pre">EarlyFusion.conv1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion.forward"><code class="docutils literal notranslate"><span class="pre">EarlyFusion.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention"><code class="docutils literal notranslate"><span class="pre">SpatialAttention</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.conv1"><code class="docutils literal notranslate"><span class="pre">SpatialAttention.conv1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.sigmoid"><code class="docutils literal notranslate"><span class="pre">SpatialAttention.sigmoid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.forward"><code class="docutils literal notranslate"><span class="pre">SpatialAttention.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention"><code class="docutils literal notranslate"><span class="pre">MultiScaleBlockWithAttention</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.dilated_conv1"><code class="docutils literal notranslate"><span class="pre">MultiScaleBlockWithAttention.dilated_conv1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.spatial_attention"><code class="docutils literal notranslate"><span class="pre">MultiScaleBlockWithAttention.spatial_attention</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.custom_forward"><code class="docutils literal notranslate"><span class="pre">MultiScaleBlockWithAttention.custom_forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.forward"><code class="docutils literal notranslate"><span class="pre">MultiScaleBlockWithAttention.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.early_fusion"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.early_fusion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.multi_scale_block_1"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.multi_scale_block_1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.fc1"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.fc1</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.use_checkpoint"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.use_checkpoint</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.custom_forward"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.custom_forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.forward"><code class="docutils literal notranslate"><span class="pre">CustomCellClassifier.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel"><code class="docutils literal notranslate"><span class="pre">TorchModel</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.model_name"><code class="docutils literal notranslate"><span class="pre">TorchModel.model_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.use_checkpoint"><code class="docutils literal notranslate"><span class="pre">TorchModel.use_checkpoint</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.base_model"><code class="docutils literal notranslate"><span class="pre">TorchModel.base_model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.num_ftrs"><code class="docutils literal notranslate"><span class="pre">TorchModel.num_ftrs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.apply_dropout_rate"><code class="docutils literal notranslate"><span class="pre">TorchModel.apply_dropout_rate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.init_base_model"><code class="docutils literal notranslate"><span class="pre">TorchModel.init_base_model()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.get_weight_choice"><code class="docutils literal notranslate"><span class="pre">TorchModel.get_weight_choice()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.get_num_ftrs"><code class="docutils literal notranslate"><span class="pre">TorchModel.get_num_ftrs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.init_spacr_classifier"><code class="docutils literal notranslate"><span class="pre">TorchModel.init_spacr_classifier()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.forward"><code class="docutils literal notranslate"><span class="pre">TorchModel.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits"><code class="docutils literal notranslate"><span class="pre">FocalLossWithLogits</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.alpha"><code class="docutils literal notranslate"><span class="pre">FocalLossWithLogits.alpha</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.gamma"><code class="docutils literal notranslate"><span class="pre">FocalLossWithLogits.gamma</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.forward"><code class="docutils literal notranslate"><span class="pre">FocalLossWithLogits.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ResNet"><code class="docutils literal notranslate"><span class="pre">ResNet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ResNet.initialize_base"><code class="docutils literal notranslate"><span class="pre">ResNet.initialize_base()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.ResNet.forward"><code class="docutils literal notranslate"><span class="pre">ResNet.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.split_my_dataset"><code class="docutils literal notranslate"><span class="pre">split_my_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.classification_metrics"><code class="docutils literal notranslate"><span class="pre">classification_metrics()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.compute_irm_penalty"><code class="docutils literal notranslate"><span class="pre">compute_irm_penalty()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.choose_model"><code class="docutils literal notranslate"><span class="pre">choose_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.calculate_loss"><code class="docutils literal notranslate"><span class="pre">calculate_loss()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.pick_best_model"><code class="docutils literal notranslate"><span class="pre">pick_best_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_paths_from_db"><code class="docutils literal notranslate"><span class="pre">get_paths_from_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.save_file_lists"><code class="docutils literal notranslate"><span class="pre">save_file_lists()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.augment_single_image"><code class="docutils literal notranslate"><span class="pre">augment_single_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.augment_images"><code class="docutils literal notranslate"><span class="pre">augment_images()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.augment_classes"><code class="docutils literal notranslate"><span class="pre">augment_classes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.annotate_predictions"><code class="docutils literal notranslate"><span class="pre">annotate_predictions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.initiate_counter"><code class="docutils literal notranslate"><span class="pre">initiate_counter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.add_images_to_tar"><code class="docutils literal notranslate"><span class="pre">add_images_to_tar()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.generate_fraction_map"><code class="docutils literal notranslate"><span class="pre">generate_fraction_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.fishers_odds"><code class="docutils literal notranslate"><span class="pre">fishers_odds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.model_metrics"><code class="docutils literal notranslate"><span class="pre">model_metrics()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.check_multicollinearity"><code class="docutils literal notranslate"><span class="pre">check_multicollinearity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.lasso_reg"><code class="docutils literal notranslate"><span class="pre">lasso_reg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.MLR"><code class="docutils literal notranslate"><span class="pre">MLR()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_files_from_dir"><code class="docutils literal notranslate"><span class="pre">get_files_from_dir()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.create_circular_mask"><code class="docutils literal notranslate"><span class="pre">create_circular_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.apply_mask"><code class="docutils literal notranslate"><span class="pre">apply_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.invert_image"><code class="docutils literal notranslate"><span class="pre">invert_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.resize_images_and_labels"><code class="docutils literal notranslate"><span class="pre">resize_images_and_labels()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.resize_labels_back"><code class="docutils literal notranslate"><span class="pre">resize_labels_back()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.calculate_iou"><code class="docutils literal notranslate"><span class="pre">calculate_iou()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.match_masks"><code class="docutils literal notranslate"><span class="pre">match_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.compute_average_precision"><code class="docutils literal notranslate"><span class="pre">compute_average_precision()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.pad_to_same_shape"><code class="docutils literal notranslate"><span class="pre">pad_to_same_shape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.compute_ap_over_iou_thresholds"><code class="docutils literal notranslate"><span class="pre">compute_ap_over_iou_thresholds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.compute_segmentation_ap"><code class="docutils literal notranslate"><span class="pre">compute_segmentation_ap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.jaccard_index"><code class="docutils literal notranslate"><span class="pre">jaccard_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.dice_coefficient"><code class="docutils literal notranslate"><span class="pre">dice_coefficient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.extract_boundaries"><code class="docutils literal notranslate"><span class="pre">extract_boundaries()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.boundary_f1_score"><code class="docutils literal notranslate"><span class="pre">boundary_f1_score()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.merge_touching_objects"><code class="docutils literal notranslate"><span class="pre">merge_touching_objects()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_intensity_objects"><code class="docutils literal notranslate"><span class="pre">remove_intensity_objects()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels"><code class="docutils literal notranslate"><span class="pre">SelectChannels</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels.channels"><code class="docutils literal notranslate"><span class="pre">SelectChannels.channels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#id0"><code class="docutils literal notranslate"><span class="pre">SelectChannels.channels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels.__call__"><code class="docutils literal notranslate"><span class="pre">SelectChannels.__call__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_image_v1"><code class="docutils literal notranslate"><span class="pre">preprocess_image_v1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.model"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.compute_saliency_maps"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator.compute_saliency_maps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.compute_saliency_and_predictions"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator.compute_saliency_and_predictions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.plot_activation_grid"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator.plot_activation_grid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.percentile_normalize"><code class="docutils literal notranslate"><span class="pre">SaliencyMapGenerator.percentile_normalize()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.model"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.target_layer"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.target_layer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.cam_type"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.cam_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.gradients"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.gradients</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.activations"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.activations</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.target_layer_module"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.target_layer_module</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.hook_layers"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.hook_layers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.get_layer"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.get_layer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.compute_gradcam_maps"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.compute_gradcam_maps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.compute_gradcam_and_predictions"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.compute_gradcam_and_predictions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.plot_activation_grid"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.plot_activation_grid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.percentile_normalize"><code class="docutils literal notranslate"><span class="pre">GradCAMGenerator.percentile_normalize()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_image"><code class="docutils literal notranslate"><span class="pre">preprocess_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.class_visualization"><code class="docutils literal notranslate"><span class="pre">class_visualization()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_submodules"><code class="docutils literal notranslate"><span class="pre">get_submodules()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM"><code class="docutils literal notranslate"><span class="pre">GradCAM</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.model"><code class="docutils literal notranslate"><span class="pre">GradCAM.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.target_layers"><code class="docutils literal notranslate"><span class="pre">GradCAM.target_layers</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.cuda"><code class="docutils literal notranslate"><span class="pre">GradCAM.cuda</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.forward"><code class="docutils literal notranslate"><span class="pre">GradCAM.forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.__call__"><code class="docutils literal notranslate"><span class="pre">GradCAM.__call__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.show_cam_on_image"><code class="docutils literal notranslate"><span class="pre">show_cam_on_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.recommend_target_layers"><code class="docutils literal notranslate"><span class="pre">recommend_target_layers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients"><code class="docutils literal notranslate"><span class="pre">IntegratedGradients</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients.model"><code class="docutils literal notranslate"><span class="pre">IntegratedGradients.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#id1"><code class="docutils literal notranslate"><span class="pre">IntegratedGradients.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients.generate_integrated_gradients"><code class="docutils literal notranslate"><span class="pre">IntegratedGradients.generate_integrated_gradients()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_db_paths"><code class="docutils literal notranslate"><span class="pre">get_db_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_sequencing_paths"><code class="docutils literal notranslate"><span class="pre">get_sequencing_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.load_image_paths"><code class="docutils literal notranslate"><span class="pre">load_image_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.merge_dataframes"><code class="docutils literal notranslate"><span class="pre">merge_dataframes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_highly_correlated_columns_v1"><code class="docutils literal notranslate"><span class="pre">remove_highly_correlated_columns_v1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.filter_columns"><code class="docutils literal notranslate"><span class="pre">filter_columns()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.reduction_and_clustering"><code class="docutils literal notranslate"><span class="pre">reduction_and_clustering()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_noise"><code class="docutils literal notranslate"><span class="pre">remove_noise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_embedding"><code class="docutils literal notranslate"><span class="pre">plot_embedding()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.generate_colors"><code class="docutils literal notranslate"><span class="pre">generate_colors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.assign_colors"><code class="docutils literal notranslate"><span class="pre">assign_colors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.setup_plot"><code class="docutils literal notranslate"><span class="pre">setup_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_clusters"><code class="docutils literal notranslate"><span class="pre">plot_clusters()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_umap_images"><code class="docutils literal notranslate"><span class="pre">plot_umap_images()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_images_by_cluster"><code class="docutils literal notranslate"><span class="pre">plot_images_by_cluster()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_image"><code class="docutils literal notranslate"><span class="pre">plot_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_canvas"><code class="docutils literal notranslate"><span class="pre">remove_canvas()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_clusters_grid"><code class="docutils literal notranslate"><span class="pre">plot_clusters_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.plot_grid"><code class="docutils literal notranslate"><span class="pre">plot_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.generate_path_list_from_db"><code class="docutils literal notranslate"><span class="pre">generate_path_list_from_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.correct_paths"><code class="docutils literal notranslate"><span class="pre">correct_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.delete_folder"><code class="docutils literal notranslate"><span class="pre">delete_folder()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.measure_test_mode"><code class="docutils literal notranslate"><span class="pre">measure_test_mode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_data"><code class="docutils literal notranslate"><span class="pre">preprocess_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_low_variance_columns"><code class="docutils literal notranslate"><span class="pre">remove_low_variance_columns()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_highly_correlated_columns"><code class="docutils literal notranslate"><span class="pre">remove_highly_correlated_columns()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.filter_dataframe_features"><code class="docutils literal notranslate"><span class="pre">filter_dataframe_features()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.check_overlap"><code class="docutils literal notranslate"><span class="pre">check_overlap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.find_non_overlapping_position"><code class="docutils literal notranslate"><span class="pre">find_non_overlapping_position()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.search_reduction_and_clustering"><code class="docutils literal notranslate"><span class="pre">search_reduction_and_clustering()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.load_image"><code class="docutils literal notranslate"><span class="pre">load_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.extract_features"><code class="docutils literal notranslate"><span class="pre">extract_features()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.check_normality"><code class="docutils literal notranslate"><span class="pre">check_normality()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.random_forest_feature_importance"><code class="docutils literal notranslate"><span class="pre">random_forest_feature_importance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.perform_statistical_tests"><code class="docutils literal notranslate"><span class="pre">perform_statistical_tests()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.combine_results"><code class="docutils literal notranslate"><span class="pre">combine_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.cluster_feature_analysis"><code class="docutils literal notranslate"><span class="pre">cluster_feature_analysis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.process_mask_file_adjust_cell"><code class="docutils literal notranslate"><span class="pre">process_mask_file_adjust_cell()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.adjust_cell_masks"><code class="docutils literal notranslate"><span class="pre">adjust_cell_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.adjust_cell_masks_v1"><code class="docutils literal notranslate"><span class="pre">adjust_cell_masks_v1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.process_masks"><code class="docutils literal notranslate"><span class="pre">process_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.merge_regression_res_with_metadata"><code class="docutils literal notranslate"><span class="pre">merge_regression_res_with_metadata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.process_vision_results"><code class="docutils literal notranslate"><span class="pre">process_vision_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_ml_results_paths"><code class="docutils literal notranslate"><span class="pre">get_ml_results_paths()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.augment_image"><code class="docutils literal notranslate"><span class="pre">augment_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.augment_dataset"><code class="docutils literal notranslate"><span class="pre">augment_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.convert_and_relabel_masks"><code class="docutils literal notranslate"><span class="pre">convert_and_relabel_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.correct_masks"><code class="docutils literal notranslate"><span class="pre">correct_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.count_reads_in_fastq"><code class="docutils literal notranslate"><span class="pre">count_reads_in_fastq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.get_cuda_version"><code class="docutils literal notranslate"><span class="pre">get_cuda_version()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.all_elements_match"><code class="docutils literal notranslate"><span class="pre">all_elements_match()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.prepare_batch_for_segmentation"><code class="docutils literal notranslate"><span class="pre">prepare_batch_for_segmentation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.check_index"><code class="docutils literal notranslate"><span class="pre">check_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.map_condition"><code class="docutils literal notranslate"><span class="pre">map_condition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.download_models"><code class="docutils literal notranslate"><span class="pre">download_models()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.generate_cytoplasm_mask"><code class="docutils literal notranslate"><span class="pre">generate_cytoplasm_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.add_column_to_database"><code class="docutils literal notranslate"><span class="pre">add_column_to_database()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.fill_holes_in_mask"><code class="docutils literal notranslate"><span class="pre">fill_holes_in_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.correct_metadata_column_names"><code class="docutils literal notranslate"><span class="pre">correct_metadata_column_names()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.control_filelist"><code class="docutils literal notranslate"><span class="pre">control_filelist()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.rename_columns_in_db"><code class="docutils literal notranslate"><span class="pre">rename_columns_in_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.group_feature_class"><code class="docutils literal notranslate"><span class="pre">group_feature_class()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.delete_intermedeate_files"><code class="docutils literal notranslate"><span class="pre">delete_intermedeate_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.filter_and_save_csv"><code class="docutils literal notranslate"><span class="pre">filter_and_save_csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.extract_tar_bz2_files"><code class="docutils literal notranslate"><span class="pre">extract_tar_bz2_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.calculate_shortest_distance"><code class="docutils literal notranslate"><span class="pre">calculate_shortest_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.format_path_for_system"><code class="docutils literal notranslate"><span class="pre">format_path_for_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.normalize_src_path"><code class="docutils literal notranslate"><span class="pre">normalize_src_path()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.generate_image_path_map"><code class="docutils literal notranslate"><span class="pre">generate_image_path_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.copy_images_to_consolidated"><code class="docutils literal notranslate"><span class="pre">copy_images_to_consolidated()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.correct_metadata"><code class="docutils literal notranslate"><span class="pre">correct_metadata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/utils/index.html#spacr.utils.remove_outliers_by_group"><code class="docutils literal notranslate"><span class="pre">remove_outliers_by_group()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/settings/index.html">Settings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/settings/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_plot_merge_settings"><code class="docutils literal notranslate"><span class="pre">set_default_plot_merge_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_settings_preprocess_generate_masks"><code class="docutils literal notranslate"><span class="pre">set_default_settings_preprocess_generate_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_plot_data_from_db"><code class="docutils literal notranslate"><span class="pre">set_default_plot_data_from_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_settings_preprocess_img_data"><code class="docutils literal notranslate"><span class="pre">set_default_settings_preprocess_img_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_umap_image_settings"><code class="docutils literal notranslate"><span class="pre">set_default_umap_image_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_measure_crop_settings"><code class="docutils literal notranslate"><span class="pre">get_measure_crop_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_analyze_screen"><code class="docutils literal notranslate"><span class="pre">set_default_analyze_screen()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_train_test_model"><code class="docutils literal notranslate"><span class="pre">set_default_train_test_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_generate_training_dataset_defaults"><code class="docutils literal notranslate"><span class="pre">set_generate_training_dataset_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.deep_spacr_defaults"><code class="docutils literal notranslate"><span class="pre">deep_spacr_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_train_test_model_settings"><code class="docutils literal notranslate"><span class="pre">get_train_test_model_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_analyze_recruitment_default_settings"><code class="docutils literal notranslate"><span class="pre">get_analyze_recruitment_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_default_test_cellpose_model_settings"><code class="docutils literal notranslate"><span class="pre">get_default_test_cellpose_model_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_default_apply_cellpose_model_settings"><code class="docutils literal notranslate"><span class="pre">get_default_apply_cellpose_model_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.default_settings_analyze_percent_positive"><code class="docutils literal notranslate"><span class="pre">default_settings_analyze_percent_positive()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_analyze_reads_default_settings"><code class="docutils literal notranslate"><span class="pre">get_analyze_reads_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_map_barcodes_default_settings"><code class="docutils literal notranslate"><span class="pre">get_map_barcodes_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_train_cellpose_default_settings"><code class="docutils literal notranslate"><span class="pre">get_train_cellpose_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_generate_dataset_defaults"><code class="docutils literal notranslate"><span class="pre">set_generate_dataset_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_perform_regression_default_settings"><code class="docutils literal notranslate"><span class="pre">get_perform_regression_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_check_cellpose_models_default_settings"><code class="docutils literal notranslate"><span class="pre">get_check_cellpose_models_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_identify_masks_finetune_default_settings"><code class="docutils literal notranslate"><span class="pre">get_identify_masks_finetune_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.q"><code class="docutils literal notranslate"><span class="pre">q</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.expected_types"><code class="docutils literal notranslate"><span class="pre">expected_types</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.categories"><code class="docutils literal notranslate"><span class="pre">categories</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.category_keys"><code class="docutils literal notranslate"><span class="pre">category_keys</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.check_settings"><code class="docutils literal notranslate"><span class="pre">check_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.generate_fields"><code class="docutils literal notranslate"><span class="pre">generate_fields()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.descriptions"><code class="docutils literal notranslate"><span class="pre">descriptions</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_annotate_default_settings"><code class="docutils literal notranslate"><span class="pre">set_annotate_default_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_default_generate_barecode_mapping"><code class="docutils literal notranslate"><span class="pre">set_default_generate_barecode_mapping()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_default_generate_activation_map_settings"><code class="docutils literal notranslate"><span class="pre">get_default_generate_activation_map_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_analyze_plaque_settings"><code class="docutils literal notranslate"><span class="pre">get_analyze_plaque_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_graph_importance_defaults"><code class="docutils literal notranslate"><span class="pre">set_graph_importance_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_interperate_vision_model_defaults"><code class="docutils literal notranslate"><span class="pre">set_interperate_vision_model_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_analyze_endodyogeny_defaults"><code class="docutils literal notranslate"><span class="pre">set_analyze_endodyogeny_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.set_analyze_class_proportion_defaults"><code class="docutils literal notranslate"><span class="pre">set_analyze_class_proportion_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/settings/index.html#spacr.settings.get_plot_data_from_csv_default_settings"><code class="docutils literal notranslate"><span class="pre">get_plot_data_from_csv_default_settings()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/sp_stats/index.html">Statistics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.choose_p_adjust_method"><code class="docutils literal notranslate"><span class="pre">choose_p_adjust_method()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.perform_normality_tests"><code class="docutils literal notranslate"><span class="pre">perform_normality_tests()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.perform_levene_test"><code class="docutils literal notranslate"><span class="pre">perform_levene_test()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.perform_statistical_tests"><code class="docutils literal notranslate"><span class="pre">perform_statistical_tests()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.perform_posthoc_tests"><code class="docutils literal notranslate"><span class="pre">perform_posthoc_tests()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sp_stats/index.html#spacr.sp_stats.chi_pairwise"><code class="docutils literal notranslate"><span class="pre">chi_pairwise()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Image Analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/measure/index.html">Measurement</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/measure/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.get_components"><code class="docutils literal notranslate"><span class="pre">get_components()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.save_and_add_image_to_grid"><code class="docutils literal notranslate"><span class="pre">save_and_add_image_to_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.img_list_to_grid"><code class="docutils literal notranslate"><span class="pre">img_list_to_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.measure_crop"><code class="docutils literal notranslate"><span class="pre">measure_crop()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.process_meassure_crop_results"><code class="docutils literal notranslate"><span class="pre">process_meassure_crop_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.generate_cellpose_train_set"><code class="docutils literal notranslate"><span class="pre">generate_cellpose_train_set()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/measure/index.html#spacr.measure.get_object_counts"><code class="docutils literal notranslate"><span class="pre">get_object_counts()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/plot/index.html">Plotting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/plot/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_image_mask_overlay"><code class="docutils literal notranslate"><span class="pre">plot_image_mask_overlay()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_cellpose4_output"><code class="docutils literal notranslate"><span class="pre">plot_cellpose4_output()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_masks"><code class="docutils literal notranslate"><span class="pre">plot_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.generate_mask_random_cmap"><code class="docutils literal notranslate"><span class="pre">generate_mask_random_cmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.random_cmap"><code class="docutils literal notranslate"><span class="pre">random_cmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_images_and_arrays"><code class="docutils literal notranslate"><span class="pre">plot_images_and_arrays()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_arrays"><code class="docutils literal notranslate"><span class="pre">plot_arrays()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_arrays_v1"><code class="docutils literal notranslate"><span class="pre">plot_arrays_v1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_merged"><code class="docutils literal notranslate"><span class="pre">plot_merged()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.generate_plate_heatmap"><code class="docutils literal notranslate"><span class="pre">generate_plate_heatmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_plates"><code class="docutils literal notranslate"><span class="pre">plot_plates()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.print_mask_and_flows"><code class="docutils literal notranslate"><span class="pre">print_mask_and_flows()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_resize"><code class="docutils literal notranslate"><span class="pre">plot_resize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.normalize_and_visualize"><code class="docutils literal notranslate"><span class="pre">normalize_and_visualize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.visualize_masks"><code class="docutils literal notranslate"><span class="pre">visualize_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.visualize_cellpose_masks"><code class="docutils literal notranslate"><span class="pre">visualize_cellpose_masks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_comparison_results"><code class="docutils literal notranslate"><span class="pre">plot_comparison_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_object_outlines"><code class="docutils literal notranslate"><span class="pre">plot_object_outlines()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.volcano_plot"><code class="docutils literal notranslate"><span class="pre">volcano_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_histogram"><code class="docutils literal notranslate"><span class="pre">plot_histogram()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_lorenz_curves"><code class="docutils literal notranslate"><span class="pre">plot_lorenz_curves()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_permutation"><code class="docutils literal notranslate"><span class="pre">plot_permutation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_feature_importance"><code class="docutils literal notranslate"><span class="pre">plot_feature_importance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.read_and_plot__vision_results"><code class="docutils literal notranslate"><span class="pre">read_and_plot__vision_results()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.jitterplot_by_annotation"><code class="docutils literal notranslate"><span class="pre">jitterplot_by_annotation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.create_grouped_plot"><code class="docutils literal notranslate"><span class="pre">create_grouped_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph"><code class="docutils literal notranslate"><span class="pre">spacrGraph</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.df"><code class="docutils literal notranslate"><span class="pre">spacrGraph.df</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.grouping_column"><code class="docutils literal notranslate"><span class="pre">spacrGraph.grouping_column</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.order"><code class="docutils literal notranslate"><span class="pre">spacrGraph.order</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.data_column"><code class="docutils literal notranslate"><span class="pre">spacrGraph.data_column</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.graph_type"><code class="docutils literal notranslate"><span class="pre">spacrGraph.graph_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.summary_func"><code class="docutils literal notranslate"><span class="pre">spacrGraph.summary_func</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.colors"><code class="docutils literal notranslate"><span class="pre">spacrGraph.colors</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.output_dir"><code class="docutils literal notranslate"><span class="pre">spacrGraph.output_dir</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.save"><code class="docutils literal notranslate"><span class="pre">spacrGraph.save</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.error_bar_type"><code class="docutils literal notranslate"><span class="pre">spacrGraph.error_bar_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.remove_outliers"><code class="docutils literal notranslate"><span class="pre">spacrGraph.remove_outliers</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.theme"><code class="docutils literal notranslate"><span class="pre">spacrGraph.theme</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.representation"><code class="docutils literal notranslate"><span class="pre">spacrGraph.representation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.paired"><code class="docutils literal notranslate"><span class="pre">spacrGraph.paired</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.all_to_all"><code class="docutils literal notranslate"><span class="pre">spacrGraph.all_to_all</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.compare_group"><code class="docutils literal notranslate"><span class="pre">spacrGraph.compare_group</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.y_lim"><code class="docutils literal notranslate"><span class="pre">spacrGraph.y_lim</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.graph_name"><code class="docutils literal notranslate"><span class="pre">spacrGraph.graph_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.log_x"><code class="docutils literal notranslate"><span class="pre">spacrGraph.log_x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.log_y"><code class="docutils literal notranslate"><span class="pre">spacrGraph.log_y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.results_df"><code class="docutils literal notranslate"><span class="pre">spacrGraph.results_df</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.sns_palette"><code class="docutils literal notranslate"><span class="pre">spacrGraph.sns_palette</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.fig"><code class="docutils literal notranslate"><span class="pre">spacrGraph.fig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.results_name"><code class="docutils literal notranslate"><span class="pre">spacrGraph.results_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.raw_df"><code class="docutils literal notranslate"><span class="pre">spacrGraph.raw_df</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.preprocess_data"><code class="docutils literal notranslate"><span class="pre">spacrGraph.preprocess_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.remove_outliers_from_plot"><code class="docutils literal notranslate"><span class="pre">spacrGraph.remove_outliers_from_plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.perform_normality_tests"><code class="docutils literal notranslate"><span class="pre">spacrGraph.perform_normality_tests()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.perform_levene_test"><code class="docutils literal notranslate"><span class="pre">spacrGraph.perform_levene_test()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.perform_statistical_tests"><code class="docutils literal notranslate"><span class="pre">spacrGraph.perform_statistical_tests()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.perform_posthoc_tests"><code class="docutils literal notranslate"><span class="pre">spacrGraph.perform_posthoc_tests()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.create_plot"><code class="docutils literal notranslate"><span class="pre">spacrGraph.create_plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.get_results"><code class="docutils literal notranslate"><span class="pre">spacrGraph.get_results()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.spacrGraph.get_figure"><code class="docutils literal notranslate"><span class="pre">spacrGraph.get_figure()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_data_from_db"><code class="docutils literal notranslate"><span class="pre">plot_data_from_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_data_from_csv"><code class="docutils literal notranslate"><span class="pre">plot_data_from_csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_region"><code class="docutils literal notranslate"><span class="pre">plot_region()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_image_grid"><code class="docutils literal notranslate"><span class="pre">plot_image_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.overlay_masks_on_images"><code class="docutils literal notranslate"><span class="pre">overlay_masks_on_images()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.graph_importance"><code class="docutils literal notranslate"><span class="pre">graph_importance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.plot_proportion_stacked_bars"><code class="docutils literal notranslate"><span class="pre">plot_proportion_stacked_bars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/plot/index.html#spacr.plot.create_venn_diagram"><code class="docutils literal notranslate"><span class="pre">create_venn_diagram()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html">Cellpose Integration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.parse_cellpose4_output"><code class="docutils literal notranslate"><span class="pre">parse_cellpose4_output()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.identify_masks_finetune"><code class="docutils literal notranslate"><span class="pre">identify_masks_finetune()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.generate_masks_from_imgs"><code class="docutils literal notranslate"><span class="pre">generate_masks_from_imgs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.check_cellpose_models"><code class="docutils literal notranslate"><span class="pre">check_cellpose_models()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.save_results_and_figure"><code class="docutils literal notranslate"><span class="pre">save_results_and_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.compare_mask"><code class="docutils literal notranslate"><span class="pre">compare_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/spacr_cellpose/index.html#spacr.spacr_cellpose.compare_cellpose_masks"><code class="docutils literal notranslate"><span class="pre">compare_cellpose_masks()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Classification</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/ml/index.html">Classical ML</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/ml/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.QuasiBinomial"><code class="docutils literal notranslate"><span class="pre">QuasiBinomial</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.QuasiBinomial.dispersion"><code class="docutils literal notranslate"><span class="pre">QuasiBinomial.dispersion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.QuasiBinomial.variance"><code class="docutils literal notranslate"><span class="pre">QuasiBinomial.variance()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.calculate_p_values"><code class="docutils literal notranslate"><span class="pre">calculate_p_values()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.perform_mixed_model"><code class="docutils literal notranslate"><span class="pre">perform_mixed_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.create_volcano_filename"><code class="docutils literal notranslate"><span class="pre">create_volcano_filename()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.scale_variables"><code class="docutils literal notranslate"><span class="pre">scale_variables()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.select_glm_family"><code class="docutils literal notranslate"><span class="pre">select_glm_family()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.prepare_formula"><code class="docutils literal notranslate"><span class="pre">prepare_formula()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.fit_mixed_model"><code class="docutils literal notranslate"><span class="pre">fit_mixed_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.check_and_clean_data"><code class="docutils literal notranslate"><span class="pre">check_and_clean_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.minimum_cell_simulation"><code class="docutils literal notranslate"><span class="pre">minimum_cell_simulation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.process_model_coefficients"><code class="docutils literal notranslate"><span class="pre">process_model_coefficients()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.check_distribution"><code class="docutils literal notranslate"><span class="pre">check_distribution()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.pick_glm_family_and_link"><code class="docutils literal notranslate"><span class="pre">pick_glm_family_and_link()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.regression_model"><code class="docutils literal notranslate"><span class="pre">regression_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.regression"><code class="docutils literal notranslate"><span class="pre">regression()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.save_summary_to_file"><code class="docutils literal notranslate"><span class="pre">save_summary_to_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.perform_regression"><code class="docutils literal notranslate"><span class="pre">perform_regression()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.process_reads"><code class="docutils literal notranslate"><span class="pre">process_reads()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.apply_transformation"><code class="docutils literal notranslate"><span class="pre">apply_transformation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.check_normality"><code class="docutils literal notranslate"><span class="pre">check_normality()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.clean_controls"><code class="docutils literal notranslate"><span class="pre">clean_controls()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.process_scores"><code class="docutils literal notranslate"><span class="pre">process_scores()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.generate_ml_scores"><code class="docutils literal notranslate"><span class="pre">generate_ml_scores()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.ml_analysis"><code class="docutils literal notranslate"><span class="pre">ml_analysis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.shap_analysis"><code class="docutils literal notranslate"><span class="pre">shap_analysis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.find_optimal_threshold"><code class="docutils literal notranslate"><span class="pre">find_optimal_threshold()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/ml/index.html#spacr.ml.interperate_vision_model"><code class="docutils literal notranslate"><span class="pre">interperate_vision_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html">Deep Learning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.apply_model"><code class="docutils literal notranslate"><span class="pre">apply_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.apply_model_to_tar"><code class="docutils literal notranslate"><span class="pre">apply_model_to_tar()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.evaluate_model_performance"><code class="docutils literal notranslate"><span class="pre">evaluate_model_performance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.test_model_core"><code class="docutils literal notranslate"><span class="pre">test_model_core()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.test_model_performance"><code class="docutils literal notranslate"><span class="pre">test_model_performance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.train_test_model"><code class="docutils literal notranslate"><span class="pre">train_test_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.train_model"><code class="docutils literal notranslate"><span class="pre">train_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.generate_activation_map"><code class="docutils literal notranslate"><span class="pre">generate_activation_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.visualize_classes"><code class="docutils literal notranslate"><span class="pre">visualize_classes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.visualize_integrated_gradients"><code class="docutils literal notranslate"><span class="pre">visualize_integrated_gradients()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.SmoothGrad"><code class="docutils literal notranslate"><span class="pre">SmoothGrad</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.SmoothGrad.model"><code class="docutils literal notranslate"><span class="pre">SmoothGrad.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.SmoothGrad.n_samples"><code class="docutils literal notranslate"><span class="pre">SmoothGrad.n_samples</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.SmoothGrad.stdev_spread"><code class="docutils literal notranslate"><span class="pre">SmoothGrad.stdev_spread</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.SmoothGrad.compute_smooth_grad"><code class="docutils literal notranslate"><span class="pre">SmoothGrad.compute_smooth_grad()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.visualize_smooth_grad"><code class="docutils literal notranslate"><span class="pre">visualize_smooth_grad()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.deep_spacr"><code class="docutils literal notranslate"><span class="pre">deep_spacr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.model_knowledge_transfer"><code class="docutils literal notranslate"><span class="pre">model_knowledge_transfer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.model_fusion"><code class="docutils literal notranslate"><span class="pre">model_fusion()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/deep_spacr/index.html#spacr.deep_spacr.annotate_filter_vision"><code class="docutils literal notranslate"><span class="pre">annotate_filter_vision()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">GUI Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/gui/index.html">GUI Main App</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/gui/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp"><code class="docutils literal notranslate"><span class="pre">MainApp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.color_settings"><code class="docutils literal notranslate"><span class="pre">MainApp.color_settings</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.main_buttons"><code class="docutils literal notranslate"><span class="pre">MainApp.main_buttons</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.additional_buttons"><code class="docutils literal notranslate"><span class="pre">MainApp.additional_buttons</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.main_gui_apps"><code class="docutils literal notranslate"><span class="pre">MainApp.main_gui_apps</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.additional_gui_apps"><code class="docutils literal notranslate"><span class="pre">MainApp.additional_gui_apps</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.selected_app"><code class="docutils literal notranslate"><span class="pre">MainApp.selected_app</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.create_widgets"><code class="docutils literal notranslate"><span class="pre">MainApp.create_widgets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.create_startup_screen"><code class="docutils literal notranslate"><span class="pre">MainApp.create_startup_screen()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.update_description"><code class="docutils literal notranslate"><span class="pre">MainApp.update_description()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.show_description"><code class="docutils literal notranslate"><span class="pre">MainApp.show_description()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.clear_description"><code class="docutils literal notranslate"><span class="pre">MainApp.clear_description()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.load_app"><code class="docutils literal notranslate"><span class="pre">MainApp.load_app()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.MainApp.clear_frame"><code class="docutils literal notranslate"><span class="pre">MainApp.clear_frame()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui/index.html#spacr.gui.gui_app"><code class="docutils literal notranslate"><span class="pre">gui_app()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/gui_core/index.html">GUI Core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/gui_core/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.q"><code class="docutils literal notranslate"><span class="pre">q</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.console_output"><code class="docutils literal notranslate"><span class="pre">console_output</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.parent_frame"><code class="docutils literal notranslate"><span class="pre">parent_frame</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.vars_dict"><code class="docutils literal notranslate"><span class="pre">vars_dict</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.canvas"><code class="docutils literal notranslate"><span class="pre">canvas</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.canvas_widget"><code class="docutils literal notranslate"><span class="pre">canvas_widget</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.scrollable_frame"><code class="docutils literal notranslate"><span class="pre">scrollable_frame</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.progress_label"><code class="docutils literal notranslate"><span class="pre">progress_label</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.fig_queue"><code class="docutils literal notranslate"><span class="pre">fig_queue</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.figures"><code class="docutils literal notranslate"><span class="pre">figures</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.figure_index"><code class="docutils literal notranslate"><span class="pre">figure_index</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.progress_bar"><code class="docutils literal notranslate"><span class="pre">progress_bar</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.usage_bars"><code class="docutils literal notranslate"><span class="pre">usage_bars</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.index_control"><code class="docutils literal notranslate"><span class="pre">index_control</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.thread_control"><code class="docutils literal notranslate"><span class="pre">thread_control</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.toggle_settings"><code class="docutils literal notranslate"><span class="pre">toggle_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.display_figure"><code class="docutils literal notranslate"><span class="pre">display_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.clear_unused_figures"><code class="docutils literal notranslate"><span class="pre">clear_unused_figures()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.show_previous_figure"><code class="docutils literal notranslate"><span class="pre">show_previous_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.show_next_figure"><code class="docutils literal notranslate"><span class="pre">show_next_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.process_fig_queue"><code class="docutils literal notranslate"><span class="pre">process_fig_queue()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.update_figure"><code class="docutils literal notranslate"><span class="pre">update_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.setup_plot_section"><code class="docutils literal notranslate"><span class="pre">setup_plot_section()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.set_globals"><code class="docutils literal notranslate"><span class="pre">set_globals()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.import_settings"><code class="docutils literal notranslate"><span class="pre">import_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.setup_settings_panel"><code class="docutils literal notranslate"><span class="pre">setup_settings_panel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.setup_console"><code class="docutils literal notranslate"><span class="pre">setup_console()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.setup_button_section"><code class="docutils literal notranslate"><span class="pre">setup_button_section()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.setup_usage_panel"><code class="docutils literal notranslate"><span class="pre">setup_usage_panel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.initiate_abort"><code class="docutils literal notranslate"><span class="pre">initiate_abort()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.check_src_folders_files"><code class="docutils literal notranslate"><span class="pre">check_src_folders_files()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.start_process"><code class="docutils literal notranslate"><span class="pre">start_process()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.process_console_queue"><code class="docutils literal notranslate"><span class="pre">process_console_queue()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.main_thread_update_function"><code class="docutils literal notranslate"><span class="pre">main_thread_update_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.cleanup_previous_instance"><code class="docutils literal notranslate"><span class="pre">cleanup_previous_instance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_core/index.html#spacr.gui_core.initiate_root"><code class="docutils literal notranslate"><span class="pre">initiate_root()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/gui_elements/index.html">GUI Elements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.fig"><code class="docutils literal notranslate"><span class="pre">fig</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.restart_gui_app"><code class="docutils literal notranslate"><span class="pre">restart_gui_app()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.create_menu_bar"><code class="docutils literal notranslate"><span class="pre">create_menu_bar()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.set_element_size"><code class="docutils literal notranslate"><span class="pre">set_element_size()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.set_dark_style"><code class="docutils literal notranslate"><span class="pre">set_dark_style()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont"><code class="docutils literal notranslate"><span class="pre">spacrFont</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.font_name"><code class="docutils literal notranslate"><span class="pre">spacrFont.font_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.font_style"><code class="docutils literal notranslate"><span class="pre">spacrFont.font_style</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.font_size"><code class="docutils literal notranslate"><span class="pre">spacrFont.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.font_path"><code class="docutils literal notranslate"><span class="pre">spacrFont.font_path</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.get_font_path"><code class="docutils literal notranslate"><span class="pre">spacrFont.get_font_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.load_font"><code class="docutils literal notranslate"><span class="pre">spacrFont.load_font()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFont.get_font"><code class="docutils literal notranslate"><span class="pre">spacrFont.get_font()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer"><code class="docutils literal notranslate"><span class="pre">spacrContainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.orient"><code class="docutils literal notranslate"><span class="pre">spacrContainer.orient</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.bg"><code class="docutils literal notranslate"><span class="pre">spacrContainer.bg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.sash_thickness"><code class="docutils literal notranslate"><span class="pre">spacrContainer.sash_thickness</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.panes"><code class="docutils literal notranslate"><span class="pre">spacrContainer.panes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.sashes"><code class="docutils literal notranslate"><span class="pre">spacrContainer.sashes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.add"><code class="docutils literal notranslate"><span class="pre">spacrContainer.add()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.create_sash"><code class="docutils literal notranslate"><span class="pre">spacrContainer.create_sash()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.reposition_panes"><code class="docutils literal notranslate"><span class="pre">spacrContainer.reposition_panes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.on_configure"><code class="docutils literal notranslate"><span class="pre">spacrContainer.on_configure()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.on_enter_sash"><code class="docutils literal notranslate"><span class="pre">spacrContainer.on_enter_sash()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.on_leave_sash"><code class="docutils literal notranslate"><span class="pre">spacrContainer.on_leave_sash()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.start_resize"><code class="docutils literal notranslate"><span class="pre">spacrContainer.start_resize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrContainer.perform_resize"><code class="docutils literal notranslate"><span class="pre">spacrContainer.perform_resize()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry"><code class="docutils literal notranslate"><span class="pre">spacrEntry</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrEntry.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.active_color"><code class="docutils literal notranslate"><span class="pre">spacrEntry.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrEntry.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.outline"><code class="docutils literal notranslate"><span class="pre">spacrEntry.outline</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.font_family"><code class="docutils literal notranslate"><span class="pre">spacrEntry.font_family</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.font_size"><code class="docutils literal notranslate"><span class="pre">spacrEntry.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrEntry.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.canvas_height"><code class="docutils literal notranslate"><span class="pre">spacrEntry.canvas_height</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.canvas"><code class="docutils literal notranslate"><span class="pre">spacrEntry.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.draw_rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrEntry.draw_rounded_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.on_focus_in"><code class="docutils literal notranslate"><span class="pre">spacrEntry.on_focus_in()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrEntry.on_focus_out"><code class="docutils literal notranslate"><span class="pre">spacrEntry.on_focus_out()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck"><code class="docutils literal notranslate"><span class="pre">spacrCheck</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrCheck.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.active_color"><code class="docutils literal notranslate"><span class="pre">spacrCheck.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrCheck.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrCheck.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.variable"><code class="docutils literal notranslate"><span class="pre">spacrCheck.variable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.canvas_width"><code class="docutils literal notranslate"><span class="pre">spacrCheck.canvas_width</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.canvas_height"><code class="docutils literal notranslate"><span class="pre">spacrCheck.canvas_height</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.canvas"><code class="docutils literal notranslate"><span class="pre">spacrCheck.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.draw_rounded_square"><code class="docutils literal notranslate"><span class="pre">spacrCheck.draw_rounded_square()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.update_check"><code class="docutils literal notranslate"><span class="pre">spacrCheck.update_check()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheck.toggle_variable"><code class="docutils literal notranslate"><span class="pre">spacrCheck.toggle_variable()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo"><code class="docutils literal notranslate"><span class="pre">spacrCombo</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrCombo.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.active_color"><code class="docutils literal notranslate"><span class="pre">spacrCombo.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrCombo.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrCombo.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.font_family"><code class="docutils literal notranslate"><span class="pre">spacrCombo.font_family</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.font_size"><code class="docutils literal notranslate"><span class="pre">spacrCombo.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrCombo.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.values"><code class="docutils literal notranslate"><span class="pre">spacrCombo.values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.canvas_width"><code class="docutils literal notranslate"><span class="pre">spacrCombo.canvas_width</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.canvas_height"><code class="docutils literal notranslate"><span class="pre">spacrCombo.canvas_height</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.canvas"><code class="docutils literal notranslate"><span class="pre">spacrCombo.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.var"><code class="docutils literal notranslate"><span class="pre">spacrCombo.var</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.selected_value"><code class="docutils literal notranslate"><span class="pre">spacrCombo.selected_value</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.dropdown_menu"><code class="docutils literal notranslate"><span class="pre">spacrCombo.dropdown_menu</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.draw_rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrCombo.draw_rounded_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.on_click"><code class="docutils literal notranslate"><span class="pre">spacrCombo.on_click()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.open_dropdown"><code class="docutils literal notranslate"><span class="pre">spacrCombo.open_dropdown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.close_dropdown"><code class="docutils literal notranslate"><span class="pre">spacrCombo.close_dropdown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.on_select"><code class="docutils literal notranslate"><span class="pre">spacrCombo.on_select()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCombo.set"><code class="docutils literal notranslate"><span class="pre">spacrCombo.set()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.variable"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.variable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.options"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.options</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.command"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.command</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.text"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.size"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.font_size"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.button_width"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.button_width</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.canvas_width"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.canvas_width</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.canvas_height"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.canvas_height</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.canvas"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.active_color"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.button_bg"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.button_bg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.button_text"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.button_text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.menu"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.menu</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.create_rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.create_rounded_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.on_enter"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.on_enter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.on_leave"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.on_leave()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.on_click"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.on_click()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.post_menu"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.post_menu()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.on_select"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.on_select()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrDropdownMenu.update_styles"><code class="docutils literal notranslate"><span class="pre">spacrDropdownMenu.update_styles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheckbutton"><code class="docutils literal notranslate"><span class="pre">spacrCheckbutton</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheckbutton.text"><code class="docutils literal notranslate"><span class="pre">spacrCheckbutton.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheckbutton.variable"><code class="docutils literal notranslate"><span class="pre">spacrCheckbutton.variable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrCheckbutton.command"><code class="docutils literal notranslate"><span class="pre">spacrCheckbutton.command</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.active_color"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.font_size"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.style"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.style</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.label"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.label</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.operation_type"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.operation_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.additional_info"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.additional_info</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.set_label_position"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.set_label_position()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrProgressBar.update_label"><code class="docutils literal notranslate"><span class="pre">spacrProgressBar.update_label()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider"><code class="docutils literal notranslate"><span class="pre">spacrSlider</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.specified_length"><code class="docutils literal notranslate"><span class="pre">spacrSlider.specified_length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.knob_radius"><code class="docutils literal notranslate"><span class="pre">spacrSlider.knob_radius</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.thickness"><code class="docutils literal notranslate"><span class="pre">spacrSlider.thickness</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.knob_position"><code class="docutils literal notranslate"><span class="pre">spacrSlider.knob_position</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.slider_line"><code class="docutils literal notranslate"><span class="pre">spacrSlider.slider_line</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.knob"><code class="docutils literal notranslate"><span class="pre">spacrSlider.knob</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.position"><code class="docutils literal notranslate"><span class="pre">spacrSlider.position</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.offset"><code class="docutils literal notranslate"><span class="pre">spacrSlider.offset</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.from_"><code class="docutils literal notranslate"><span class="pre">spacrSlider.from_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.to"><code class="docutils literal notranslate"><span class="pre">spacrSlider.to</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.value"><code class="docutils literal notranslate"><span class="pre">spacrSlider.value</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.show_index"><code class="docutils literal notranslate"><span class="pre">spacrSlider.show_index</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.command"><code class="docutils literal notranslate"><span class="pre">spacrSlider.command</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrSlider.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrSlider.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.active_color"><code class="docutils literal notranslate"><span class="pre">spacrSlider.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrSlider.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.canvas"><code class="docutils literal notranslate"><span class="pre">spacrSlider.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.length"><code class="docutils literal notranslate"><span class="pre">spacrSlider.length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.resize_slider"><code class="docutils literal notranslate"><span class="pre">spacrSlider.resize_slider()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.value_to_position"><code class="docutils literal notranslate"><span class="pre">spacrSlider.value_to_position()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.position_to_value"><code class="docutils literal notranslate"><span class="pre">spacrSlider.position_to_value()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.draw_slider"><code class="docutils literal notranslate"><span class="pre">spacrSlider.draw_slider()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.move_knob"><code class="docutils literal notranslate"><span class="pre">spacrSlider.move_knob()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.activate_knob"><code class="docutils literal notranslate"><span class="pre">spacrSlider.activate_knob()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.release_knob"><code class="docutils literal notranslate"><span class="pre">spacrSlider.release_knob()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.set_to"><code class="docutils literal notranslate"><span class="pre">spacrSlider.set_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.get"><code class="docutils literal notranslate"><span class="pre">spacrSlider.get()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.set"><code class="docutils literal notranslate"><span class="pre">spacrSlider.set()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.jump_to_click"><code class="docutils literal notranslate"><span class="pre">spacrSlider.jump_to_click()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSlider.update_slider_from_entry"><code class="docutils literal notranslate"><span class="pre">spacrSlider.update_slider_from_entry()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrScrollbarStyle"><code class="docutils literal notranslate"><span class="pre">spacrScrollbarStyle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFrame"><code class="docutils literal notranslate"><span class="pre">spacrFrame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFrame.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrFrame.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFrame.active_color"><code class="docutils literal notranslate"><span class="pre">spacrFrame.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFrame.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrFrame.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrFrame.rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrFrame.rounded_rectangle()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel"><code class="docutils literal notranslate"><span class="pre">spacrLabel</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.text"><code class="docutils literal notranslate"><span class="pre">spacrLabel.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.align"><code class="docutils literal notranslate"><span class="pre">spacrLabel.align</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.style_out"><code class="docutils literal notranslate"><span class="pre">spacrLabel.style_out</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.font_style"><code class="docutils literal notranslate"><span class="pre">spacrLabel.font_style</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.font_size"><code class="docutils literal notranslate"><span class="pre">spacrLabel.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.font_family"><code class="docutils literal notranslate"><span class="pre">spacrLabel.font_family</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrLabel.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.canvas"><code class="docutils literal notranslate"><span class="pre">spacrLabel.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.style"><code class="docutils literal notranslate"><span class="pre">spacrLabel.style</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrLabel.set_text"><code class="docutils literal notranslate"><span class="pre">spacrLabel.set_text()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton"><code class="docutils literal notranslate"><span class="pre">spacrButton</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.text"><code class="docutils literal notranslate"><span class="pre">spacrButton.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.command"><code class="docutils literal notranslate"><span class="pre">spacrButton.command</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.icon_name"><code class="docutils literal notranslate"><span class="pre">spacrButton.icon_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.size"><code class="docutils literal notranslate"><span class="pre">spacrButton.size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.show_text"><code class="docutils literal notranslate"><span class="pre">spacrButton.show_text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.outline"><code class="docutils literal notranslate"><span class="pre">spacrButton.outline</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.animation"><code class="docutils literal notranslate"><span class="pre">spacrButton.animation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.font_size"><code class="docutils literal notranslate"><span class="pre">spacrButton.font_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.font_loader"><code class="docutils literal notranslate"><span class="pre">spacrButton.font_loader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.canvas"><code class="docutils literal notranslate"><span class="pre">spacrButton.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.inactive_color"><code class="docutils literal notranslate"><span class="pre">spacrButton.inactive_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.bg_color"><code class="docutils literal notranslate"><span class="pre">spacrButton.bg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.active_color"><code class="docutils literal notranslate"><span class="pre">spacrButton.active_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.fg_color"><code class="docutils literal notranslate"><span class="pre">spacrButton.fg_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.is_zoomed_in"><code class="docutils literal notranslate"><span class="pre">spacrButton.is_zoomed_in</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.load_icon"><code class="docutils literal notranslate"><span class="pre">spacrButton.load_icon()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.get_icon_path"><code class="docutils literal notranslate"><span class="pre">spacrButton.get_icon_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.on_enter"><code class="docutils literal notranslate"><span class="pre">spacrButton.on_enter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.on_leave"><code class="docutils literal notranslate"><span class="pre">spacrButton.on_leave()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.on_click"><code class="docutils literal notranslate"><span class="pre">spacrButton.on_click()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.create_rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrButton.create_rounded_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.update_description"><code class="docutils literal notranslate"><span class="pre">spacrButton.update_description()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.clear_description"><code class="docutils literal notranslate"><span class="pre">spacrButton.clear_description()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.animate_zoom"><code class="docutils literal notranslate"><span class="pre">spacrButton.animate_zoom()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrButton.zoom_icon"><code class="docutils literal notranslate"><span class="pre">spacrButton.zoom_icon()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch"><code class="docutils literal notranslate"><span class="pre">spacrSwitch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.text"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.variable"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.variable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.command"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.command</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.canvas"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.canvas</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.switch_bg"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.switch_bg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.switch"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.switch</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.label"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.label</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.toggle"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.toggle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.update_switch"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.update_switch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.animate_switch"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.animate_switch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.animate_movement"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.animate_movement()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.get"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.get()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.set"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.set()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrSwitch.create_rounded_rectangle"><code class="docutils literal notranslate"><span class="pre">spacrSwitch.create_rounded_rectangle()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip"><code class="docutils literal notranslate"><span class="pre">spacrToolTip</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip.widget"><code class="docutils literal notranslate"><span class="pre">spacrToolTip.widget</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip.text"><code class="docutils literal notranslate"><span class="pre">spacrToolTip.text</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip.tooltip_window"><code class="docutils literal notranslate"><span class="pre">spacrToolTip.tooltip_window</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip.show_tooltip"><code class="docutils literal notranslate"><span class="pre">spacrToolTip.show_tooltip()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.spacrToolTip.hide_tooltip"><code class="docutils literal notranslate"><span class="pre">spacrToolTip.hide_tooltip()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.standardize_figure"><code class="docutils literal notranslate"><span class="pre">standardize_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.modify_figure_properties"><code class="docutils literal notranslate"><span class="pre">modify_figure_properties()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.save_figure_as_format"><code class="docutils literal notranslate"><span class="pre">save_figure_as_format()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.modify_figure"><code class="docutils literal notranslate"><span class="pre">modify_figure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_elements/index.html#spacr.gui_elements.generate_dna_matrix"><code class="docutils literal notranslate"><span class="pre">generate_dna_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/gui_utils/index.html">GUI Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.initialize_cuda"><code class="docutils literal notranslate"><span class="pre">initialize_cuda()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.set_high_priority"><code class="docutils literal notranslate"><span class="pre">set_high_priority()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.set_cpu_affinity"><code class="docutils literal notranslate"><span class="pre">set_cpu_affinity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.proceed_with_app"><code class="docutils literal notranslate"><span class="pre">proceed_with_app()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.load_app"><code class="docutils literal notranslate"><span class="pre">load_app()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.parse_list"><code class="docutils literal notranslate"><span class="pre">parse_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.create_input_field"><code class="docutils literal notranslate"><span class="pre">create_input_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.process_stdout_stderr"><code class="docutils literal notranslate"><span class="pre">process_stdout_stderr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.WriteToQueue"><code class="docutils literal notranslate"><span class="pre">WriteToQueue</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.WriteToQueue.q"><code class="docutils literal notranslate"><span class="pre">WriteToQueue.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.WriteToQueue.write"><code class="docutils literal notranslate"><span class="pre">WriteToQueue.write()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.WriteToQueue.flush"><code class="docutils literal notranslate"><span class="pre">WriteToQueue.flush()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.cancel_after_tasks"><code class="docutils literal notranslate"><span class="pre">cancel_after_tasks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.load_next_app"><code class="docutils literal notranslate"><span class="pre">load_next_app()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.convert_settings_dict_for_gui"><code class="docutils literal notranslate"><span class="pre">convert_settings_dict_for_gui()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.spacrFigShow"><code class="docutils literal notranslate"><span class="pre">spacrFigShow()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.function_gui_wrapper"><code class="docutils literal notranslate"><span class="pre">function_gui_wrapper()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.run_function_gui"><code class="docutils literal notranslate"><span class="pre">run_function_gui()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.hide_all_settings"><code class="docutils literal notranslate"><span class="pre">hide_all_settings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.setup_frame"><code class="docutils literal notranslate"><span class="pre">setup_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.download_hug_dataset"><code class="docutils literal notranslate"><span class="pre">download_hug_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.download_dataset"><code class="docutils literal notranslate"><span class="pre">download_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.ensure_after_tasks"><code class="docutils literal notranslate"><span class="pre">ensure_after_tasks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.display_gif_in_plot_frame"><code class="docutils literal notranslate"><span class="pre">display_gif_in_plot_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.display_media_in_plot_frame"><code class="docutils literal notranslate"><span class="pre">display_media_in_plot_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.print_widget_structure"><code class="docutils literal notranslate"><span class="pre">print_widget_structure()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.get_screen_dimensions"><code class="docutils literal notranslate"><span class="pre">get_screen_dimensions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/gui_utils/index.html#spacr.gui_utils.convert_to_number"><code class="docutils literal notranslate"><span class="pre">convert_to_number()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Sequencing &amp; Submodules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/sequencing/index.html">Sequencing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/sequencing/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.map_sequences_to_names"><code class="docutils literal notranslate"><span class="pre">map_sequences_to_names()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.save_df_to_hdf5"><code class="docutils literal notranslate"><span class="pre">save_df_to_hdf5()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.save_unique_combinations_to_csv"><code class="docutils literal notranslate"><span class="pre">save_unique_combinations_to_csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.save_qc_df_to_csv"><code class="docutils literal notranslate"><span class="pre">save_qc_df_to_csv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.extract_sequence_and_quality"><code class="docutils literal notranslate"><span class="pre">extract_sequence_and_quality()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.create_consensus"><code class="docutils literal notranslate"><span class="pre">create_consensus()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.get_consensus_base"><code class="docutils literal notranslate"><span class="pre">get_consensus_base()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.reverse_complement"><code class="docutils literal notranslate"><span class="pre">reverse_complement()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.process_chunk"><code class="docutils literal notranslate"><span class="pre">process_chunk()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.saver_process"><code class="docutils literal notranslate"><span class="pre">saver_process()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.paired_read_chunked_processing"><code class="docutils literal notranslate"><span class="pre">paired_read_chunked_processing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.single_read_chunked_processing"><code class="docutils literal notranslate"><span class="pre">single_read_chunked_processing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.generate_barecode_mapping"><code class="docutils literal notranslate"><span class="pre">generate_barecode_mapping()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.barecodes_reverse_complement"><code class="docutils literal notranslate"><span class="pre">barecodes_reverse_complement()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/sequencing/index.html#spacr.sequencing.graph_sequencing_stats"><code class="docutils literal notranslate"><span class="pre">graph_sequencing_stats()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/toxo/index.html">Toxoplasma Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/toxo/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/toxo/index.html#spacr.toxo.custom_volcano_plot"><code class="docutils literal notranslate"><span class="pre">custom_volcano_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/toxo/index.html#spacr.toxo.go_term_enrichment_by_column"><code class="docutils literal notranslate"><span class="pre">go_term_enrichment_by_column()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/toxo/index.html#spacr.toxo.plot_gene_phenotypes"><code class="docutils literal notranslate"><span class="pre">plot_gene_phenotypes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/toxo/index.html#spacr.toxo.plot_gene_heatmaps"><code class="docutils literal notranslate"><span class="pre">plot_gene_heatmaps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/toxo/index.html#spacr.toxo.generate_score_heatmap"><code class="docutils literal notranslate"><span class="pre">generate_score_heatmap()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/spacr/submodules/index.html">Submodules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/spacr/submodules/index.html#module-contents">Module Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.normalize"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.normalize</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.percentiles"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.percentiles</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.target_size"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.target_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.augment"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.augment</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.__len__"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.__len__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.apply_augmentation"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.apply_augmentation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.CellposeLazyDataset.__getitem__"><code class="docutils literal notranslate"><span class="pre">CellposeLazyDataset.__getitem__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.train_cellpose"><code class="docutils literal notranslate"><span class="pre">train_cellpose()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.test_cellpose_model"><code class="docutils literal notranslate"><span class="pre">test_cellpose_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.apply_cellpose_model"><code class="docutils literal notranslate"><span class="pre">apply_cellpose_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.plot_cellpose_batch"><code class="docutils literal notranslate"><span class="pre">plot_cellpose_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.analyze_percent_positive"><code class="docutils literal notranslate"><span class="pre">analyze_percent_positive()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.analyze_recruitment"><code class="docutils literal notranslate"><span class="pre">analyze_recruitment()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.analyze_plaques"><code class="docutils literal notranslate"><span class="pre">analyze_plaques()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.count_phenotypes"><code class="docutils literal notranslate"><span class="pre">count_phenotypes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.compare_reads_to_scores"><code class="docutils literal notranslate"><span class="pre">compare_reads_to_scores()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.interperate_vision_model"><code class="docutils literal notranslate"><span class="pre">interperate_vision_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.analyze_endodyogeny"><code class="docutils literal notranslate"><span class="pre">analyze_endodyogeny()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.analyze_class_proportion"><code class="docutils literal notranslate"><span class="pre">analyze_class_proportion()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.generate_score_heatmap"><code class="docutils literal notranslate"><span class="pre">generate_score_heatmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/spacr/submodules/index.html#spacr.submodules.post_regression_analysis"><code class="docutils literal notranslate"><span class="pre">post_regression_analysis()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a><ul class="simple">
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #005f73" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">spacr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spacr.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spacr.utils</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">sqlite3</span><span class="o">,</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">torchvision</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">string</span><span class="o">,</span> <span class="nn">shutil</span><span class="o">,</span> <span class="nn">cv2</span><span class="o">,</span> <span class="nn">tarfile</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">psutil</span><span class="o">,</span> <span class="nn">platform</span><span class="o">,</span> <span class="nn">gzip</span><span class="o">,</span> <span class="nn">subprocess</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">requests</span><span class="o">,</span> <span class="nn">ast</span><span class="o">,</span> <span class="nn">traceback</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">cellpose</span> <span class="kn">import</span> <span class="n">models</span> <span class="k">as</span> <span class="n">cp_models</span>
<span class="kn">from</span> <span class="nn">cellpose</span> <span class="kn">import</span> <span class="n">denoise</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops_table</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">measure</span>
<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span> <span class="k">as</span> <span class="n">resizescikit</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">square</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">find_contours</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span><span class="p">,</span> <span class="n">find_boundaries</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.outliers_influence</span> <span class="kn">import</span> <span class="n">variance_inflation_factor</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="kn">import</span> <span class="n">durbin_watson</span>
<span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.multitest</span> <span class="kn">import</span> <span class="n">multipletests</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">,</span> <span class="n">set_start_method</span><span class="p">,</span> <span class="n">get_start_method</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">torch.utils.checkpoint</span> <span class="kn">import</span> <span class="n">checkpoint</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Subset</span>
<span class="kn">from</span> <span class="nn">torch.autograd</span> <span class="kn">import</span> <span class="n">grad</span>

<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">torchvision.models.resnet</span> <span class="kn">import</span> <span class="n">ResNet18_Weights</span><span class="p">,</span> <span class="n">ResNet34_Weights</span><span class="p">,</span> <span class="n">ResNet50_Weights</span><span class="p">,</span> <span class="n">ResNet101_Weights</span><span class="p">,</span> <span class="n">ResNet152_Weights</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.models</span> <span class="kn">import</span> <span class="n">resnet50</span>

<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.offsetbox</span> <span class="kn">import</span> <span class="n">OffsetImage</span><span class="p">,</span> <span class="n">AnnotationBbox</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndi</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">fisher_exact</span><span class="p">,</span> <span class="n">f_oneway</span><span class="p">,</span> <span class="n">kruskal</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">splprep</span><span class="p">,</span> <span class="n">splev</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">binary_dilation</span><span class="p">,</span> <span class="n">binary_fill_holes</span>

<span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">auc</span><span class="p">,</span> <span class="n">precision_recall_curve</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span><span class="p">,</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span><span class="p">,</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>

<span class="kn">from</span> <span class="nn">huggingface_hub</span> <span class="kn">import</span> <span class="n">list_repo_files</span>

<span class="c1">#from spacr import __file__ as spacr_path</span>
<div class="viewcode-block" id="spacr_path">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.spacr_path">[docs]</a>
<span class="n">spacr_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;__init__.py&#39;</span><span class="p">)</span></div>


<span class="kn">import</span> <span class="nn">umap.umap_</span> <span class="k">as</span> <span class="nn">umap</span>

<span class="k">def</span> <span class="nf">_generate_mask_random_cmap</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a random colormap based on the unique labels in the given mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    mask (ndarray): The mask array containing unique labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ListedColormap: A random colormap generated based on the unique labels in the mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">num_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_objects</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">random_colors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">random_colors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">random_cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">random_colors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_cmap</span>

<div class="viewcode-block" id="filepaths_to_database">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.filepaths_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">filepaths_to_database</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">crop_mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert image paths and metadata into a SQLite database.</span>

<span class="sd">    Args:</span>
<span class="sd">        img_paths (list of str): Image file paths to insert.</span>
<span class="sd">        settings (dict): Configuration dictionary. Must contain a &#39;timelapse&#39; key (bool).</span>
<span class="sd">        source_folder (str): Folder containing the SQLite database.</span>
<span class="sd">        crop_mode (str): One of &#39;cell&#39;, &#39;nucleus&#39;, &#39;pathogen&#39;, or &#39;cytoplasm&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        sqlite3.OperationalError: On database connection or write errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>

    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;timelapse&#39;</span><span class="p">])))</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;timelapse&#39;</span><span class="p">]:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;time_id&#39;</span><span class="p">]</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;nucleus_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pathogen_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cytoplasm_id&#39;</span><span class="p">]</span>

    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s1">/measurements/measurements.db&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">png_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="activation_maps_to_database">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.activation_maps_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">activation_maps_to_database</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_create_database</span>

    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>
    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">database_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/measurements/</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">.db&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">database_name</span><span class="p">):</span>
        <span class="n">_create_database</span><span class="p">(</span><span class="n">database_name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">database_name</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">png_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cam_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_list&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="activation_correlations_to_database">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.activation_correlations_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">activation_correlations_to_database</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">img_paths</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save activation correlation data to a SQLite database.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame with correlation data. Must include &#39;file_name&#39;.</span>
<span class="sd">        img_paths (list): List of image file paths.</span>
<span class="sd">        source_folder (str): Folder where the database is stored.</span>
<span class="sd">        settings (dict): Must include &#39;dataset&#39; and &#39;cam_type&#39; keys.</span>

<span class="sd">    Raises:</span>
<span class="sd">        sqlite3.OperationalError: On database errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_create_database</span>

    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>
    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="c1"># Align both DataFrames by file_name</span>
    <span class="n">png_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">png_df</span><span class="p">,</span> <span class="n">df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">merged_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">database_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/measurements/</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">.db&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">database_name</span><span class="p">):</span>
        <span class="n">_create_database</span><span class="p">(</span><span class="n">database_name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">database_name</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cam_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_correlations&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="calculate_activation_correlations">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.calculate_activation_correlations">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_activation_correlations</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">activation_maps</span><span class="p">,</span> <span class="n">file_names</span><span class="p">,</span> <span class="n">manders_thresholds</span><span class="o">=</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates Pearson and Manders correlations between input image channels and activation map channels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        inputs: A batch of input images, Tensor of shape (batch_size, channels, height, width)</span>
<span class="sd">        activation_maps: A batch of activation maps, Tensor of shape (batch_size, channels, height, width)</span>
<span class="sd">        file_names: List of file names corresponding to each image in the batch.</span>
<span class="sd">        manders_thresholds: List of intensity percentiles to calculate Manders correlation.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        df_correlations: A DataFrame with columns for pairwise correlations (Pearson and Manders) </span>
<span class="sd">                         between input channels and activation map channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Ensure tensors are detached and moved to CPU before converting to numpy</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

    <span class="n">batch_size</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="k">if</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># If activation maps have no channels, add a dummy channel dimension</span>
        <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Now shape is (batch_size, 1, height, width)</span>
    
    <span class="n">_</span><span class="p">,</span> <span class="n">act_channels</span><span class="p">,</span> <span class="n">act_height</span><span class="p">,</span> <span class="n">act_width</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Ensure that the inputs and activation maps are the same size</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">height</span> <span class="o">!=</span> <span class="n">act_height</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">width</span> <span class="o">!=</span> <span class="n">act_width</span><span class="p">):</span>
        <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">activation_maps</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>

    <span class="c1"># Dictionary to collect correlation results</span>
    <span class="n">correlations_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;file_name&#39;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="c1"># Initialize correlation columns based on input channels and activation map channels</span>
    <span class="k">for</span> <span class="n">in_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_channels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">act_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">act_channels</span><span class="p">):</span>
            <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_pearsons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">manders_thresholds</span><span class="p">:</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Loop over the batch</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
        <span class="n">input_img</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>  <span class="c1"># Input image channels (C, H, W)</span>
        <span class="n">activation_map</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>  <span class="c1"># Activation map channels (C, H, W)</span>

        <span class="c1"># Add the file name to the current row</span>
        <span class="n">correlations_dict</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_names</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

        <span class="c1"># Calculate correlations for each channel pair</span>
        <span class="k">for</span> <span class="n">in_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_channels</span><span class="p">):</span>
            <span class="n">input_channel</span> <span class="o">=</span> <span class="n">input_img</span><span class="p">[</span><span class="n">in_c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Flatten the input image channel</span>
            <span class="n">input_channel</span> <span class="o">=</span> <span class="n">input_channel</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">input_channel</span><span class="p">)]</span>  <span class="c1"># Remove NaN or inf values</span>

            <span class="k">for</span> <span class="n">act_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">act_channels</span><span class="p">):</span>
                <span class="n">activation_channel</span> <span class="o">=</span> <span class="n">activation_map</span><span class="p">[</span><span class="n">act_c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Flatten the activation map channel</span>
                <span class="n">activation_channel</span> <span class="o">=</span> <span class="n">activation_channel</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">)]</span>  <span class="c1"># Remove NaN or inf values</span>

                <span class="c1"># Check if there are valid (non-empty) arrays left to calculate the Pearson correlation</span>
                <span class="k">if</span> <span class="n">input_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">activation_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pearson_corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">input_channel</span><span class="p">,</span> <span class="n">activation_channel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pearson_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Assign NaN if there are no valid data points</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_pearsons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pearson_corr</span><span class="p">)</span>

                <span class="c1"># Compute Manders correlations for each threshold</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">manders_thresholds</span><span class="p">:</span>
                    <span class="c1"># Get the top percentile pixels based on intensity in both channels</span>
                    <span class="k">if</span> <span class="n">input_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">activation_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">input_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">input_channel</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
                        <span class="n">activation_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

                        <span class="c1"># Mask the pixels above the threshold</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_channel</span> <span class="o">&gt;=</span> <span class="n">input_threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">activation_channel</span> <span class="o">&gt;=</span> <span class="n">activation_threshold</span><span class="p">)</span>

                        <span class="c1"># If we have enough pixels, calculate Manders correlation</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                            <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                    <span class="c1"># Store the Manders correlation for this threshold</span>
                    <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">manders_corr_M1</span><span class="p">)</span>
                    <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">manders_corr_M2</span><span class="p">)</span>

    <span class="c1"># Convert the dictionary to a DataFrame</span>
    <span class="n">df_correlations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">correlations_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_correlations</span></div>


<div class="viewcode-block" id="load_settings">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.load_settings">[docs]</a>
<span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setting_key</span><span class="o">=</span><span class="s1">&#39;setting_key&#39;</span><span class="p">,</span> <span class="n">setting_value</span><span class="o">=</span><span class="s1">&#39;setting_value&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a CSV file with &#39;settings_key&#39; and &#39;settings_value&#39; columns into a dictionary.</span>
<span class="sd">    Handles special cases where values are lists, tuples, booleans, None, integers, floats, and nested dictionaries.</span>

<span class="sd">    Args:</span>
<span class="sd">        csv_file_path (str): The path to the CSV file.</span>
<span class="sd">        show (bool): Whether to display the dataframe (for debugging).</span>
<span class="sd">        setting_key (str): The name of the column that contains the setting keys.</span>
<span class="sd">        setting_value (str): The name of the column that contains the setting values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where &#39;settings_key&#39; are the keys and &#39;settings_value&#39; are the values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the CSV file into a DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Ensure the columns &#39;setting_key&#39; and &#39;setting_value&#39; exist</span>
    <span class="k">if</span> <span class="n">setting_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">setting_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CSV file must contain </span><span class="si">{</span><span class="n">setting_key</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">setting_value</span><span class="si">}</span><span class="s2"> columns.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the string value into the appropriate Python data type.&quot;&quot;&quot;</span>
        <span class="c1"># Handle empty values</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Handle boolean values</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Handle lists, tuples, dictionaries, and other literals</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;{&#39;</span><span class="p">)):</span>  <span class="c1"># If it starts with (, [ or {, use ast.literal_eval</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parsed_value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="c1"># If parsed_value is a dict, recursively parse its values</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsed_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">parsed_value</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">parsed_value</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">return</span> <span class="n">parsed_value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">SyntaxError</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># If there&#39;s an error, return the value as-is</span>
        
        <span class="c1"># Handle numeric values (integers and floats)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># If it contains a dot, convert to float</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># Otherwise, convert to integer</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># If it&#39;s not a valid number, return the value as-is</span>

        <span class="c1"># Return the original value if no other type matched</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Convert the DataFrame to a dictionary, with parsing of each value</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">setting_key</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">setting_value</span><span class="p">])}</span>

    <span class="k">return</span> <span class="n">result_dict</span></div>


<div class="viewcode-block" id="save_settings">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.save_settings">[docs]</a>
<span class="k">def</span> <span class="nf">save_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;settings&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save a dictionary of settings to a CSV file.</span>

<span class="sd">    This function takes a dictionary of settings, processes it, and saves it </span>
<span class="sd">    as a CSV file in a specified directory. It also provides an option to </span>
<span class="sd">    display the settings as a DataFrame.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): A dictionary containing the settings to be saved.</span>
<span class="sd">        name (str, optional): The base name for the output CSV file. Defaults to &#39;settings&#39;.</span>
<span class="sd">        show (bool, optional): If True, displays the settings as a DataFrame. Defaults to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: If the &#39;src&#39; key is not present in the settings dictionary.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If the &#39;src&#39; key in the settings dictionary is a list, the first element </span>
<span class="sd">          is used as the source directory, and the file name is appended with &#39;_list&#39;.</span>
<span class="sd">        - If the &#39;test_mode&#39; key exists in the settings dictionary, it is set to False.</span>
<span class="sd">        - If the &#39;plot&#39; key exists in the settings dictionary, it is set to False.</span>
<span class="sd">        - A directory named &#39;settings&#39; is created inside the source directory if it does not exist.</span>
<span class="sd">        - The settings are saved as a CSV file in the &#39;settings&#39; directory.</span>
<span class="sd">        - The file path where the settings are saved is printed.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; settings = {</span>
<span class="sd">        ...     &#39;src&#39;: &#39;/path/to/source&#39;,</span>
<span class="sd">        ...     &#39;test_mode&#39;: True,</span>
<span class="sd">        ...     &#39;plot&#39;: True,</span>
<span class="sd">        ...     &#39;param1&#39;: 42</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; save_settings(settings, name=&#39;experiment1&#39;, show=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">settings_2</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">settings_2</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">settings_2</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_list&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">settings_2</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="s1">&#39;test_mode&#39;</span> <span class="ow">in</span> <span class="n">settings_2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">settings_2</span><span class="p">[</span><span class="s1">&#39;test_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="s1">&#39;plot&#39;</span> <span class="ow">in</span> <span class="n">settings_2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">settings_2</span><span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            
    <span class="n">settings_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">settings_2</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Key&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">settings_df</span><span class="p">)</span>

    <span class="n">settings_csv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;settings&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;settings&#39;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving settings to </span><span class="si">{</span><span class="n">settings_csv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">settings_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">settings_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_progress">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.print_progress">[docs]</a>
<span class="k">def</span> <span class="nf">print_progress</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="n">files_to_process</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints the progress of a file processing operation along with estimated time information.</span>

<span class="sd">    Args:</span>
<span class="sd">        files_processed (int or list): The number of files processed so far. If a list is provided, </span>
<span class="sd">            its unique length will be used.</span>
<span class="sd">        files_to_process (int or list): The total number of files to process. If a list is provided, </span>
<span class="sd">            its unique length will be used.</span>
<span class="sd">        n_jobs (int): The number of parallel jobs being used for processing.</span>
<span class="sd">        time_ls (list, optional): A list of time durations for processing batches or files. Used to </span>
<span class="sd">            calculate average time and estimated time left. Defaults to None.</span>
<span class="sd">        batch_size (int or list, optional): The size of each batch being processed. If a list is </span>
<span class="sd">            provided, its length will be used. Defaults to None.</span>
<span class="sd">        operation_type (str, optional): A string describing the type of operation being performed. </span>
<span class="sd">            Defaults to an empty string.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function prints the progress and time information to the console.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If `time_ls` is provided, the function calculates the average time per batch or file and </span>
<span class="sd">          estimates the time remaining for the operation.</span>
<span class="sd">        - If `batch_size` is provided, the function calculates the average time per image within </span>
<span class="sd">          a batch.</span>
<span class="sd">        - Handles cases where inputs are lists or non-integer types by converting them to integers </span>
<span class="sd">          or calculating their lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">files_processed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">files_processed</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">files_processed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">files_processed</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">files_processed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">files_to_process</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">time_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_ls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">average_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">time_ls</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">time_left</span> <span class="o">=</span> <span class="p">(((</span><span class="n">files_to_process</span> <span class="o">-</span> <span class="n">files_processed</span><span class="p">)</span> <span class="o">*</span> <span class="n">average_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_jobs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Time/image: </span><span class="si">{</span><span class="n">average_time</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time_left: </span><span class="si">{</span><span class="n">time_left</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> min.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">average_time_img</span> <span class="o">=</span> <span class="n">average_time</span> <span class="o">/</span> <span class="n">batch_size</span>
            <span class="n">time_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Time/batch: </span><span class="si">{</span><span class="n">average_time</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time/image: </span><span class="si">{</span><span class="n">average_time_img</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time_left: </span><span class="si">{</span><span class="n">time_left</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> min.&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_info</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Progress: </span><span class="si">{</span><span class="n">files_processed</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">files_to_process</span><span class="si">}</span><span class="s1">, operation_type: </span><span class="si">{</span><span class="n">operation_type</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">time_info</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="reset_mp">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.reset_mp">[docs]</a>
<span class="k">def</span> <span class="nf">reset_mp</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resets the multiprocessing start method based on the operating system.</span>
<span class="sd">    On Windows, the start method is set to &#39;spawn&#39; if it is not already set.</span>
<span class="sd">    On Linux and macOS (Darwin), the start method is set to &#39;fork&#39; if it is not already set.</span>
<span class="sd">    This function ensures compatibility with the multiprocessing module by</span>
<span class="sd">    enforcing the appropriate start method for the current platform.</span>
<span class="sd">    Note:</span>
<span class="sd">        - The function uses `get_start_method` to retrieve the current start method.</span>
<span class="sd">        - The `set_start_method` function is called with `force=True` to override</span>
<span class="sd">          the existing start method if necessary.</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If an invalid start method is encountered or if the start</span>
<span class="sd">                    method cannot be set for some reason.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_method</span> <span class="o">=</span> <span class="n">get_start_method</span><span class="p">()</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">system</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">current_method</span> <span class="o">!=</span> <span class="s1">&#39;spawn&#39;</span><span class="p">:</span>
            <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">system</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Linux&#39;</span><span class="p">,</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">):</span>  <span class="c1"># Darwin is macOS</span>
        <span class="k">if</span> <span class="n">current_method</span> <span class="o">!=</span> <span class="s1">&#39;fork&#39;</span><span class="p">:</span>
            <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;fork&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_multiprocessing_process">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.is_multiprocessing_process">[docs]</a>
<span class="k">def</span> <span class="nf">is_multiprocessing_process</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the given process is a multiprocessing process.</span>

<span class="sd">    This function examines the command-line arguments of the provided process</span>
<span class="sd">    to determine if it is associated with Python&#39;s multiprocessing module.</span>

<span class="sd">    Args:</span>
<span class="sd">        process (psutil.Process): A psutil Process object representing the process to check.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the process is a multiprocessing process, False otherwise.</span>

<span class="sd">    Raises:</span>
<span class="sd">        psutil.NoSuchProcess: If the process no longer exists.</span>
<span class="sd">        psutil.AccessDenied: If access to the process information is denied.</span>
<span class="sd">        psutil.ZombieProcess: If the process is a zombie process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Check if the process is a multiprocessing process. &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">process</span><span class="o">.</span><span class="n">cmdline</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;multiprocessing&#39;</span> <span class="ow">in</span> <span class="n">cmd</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">psutil</span><span class="o">.</span><span class="n">NoSuchProcess</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">AccessDenied</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">ZombieProcess</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="close_file_descriptors">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.close_file_descriptors">[docs]</a>
<span class="k">def</span> <span class="nf">close_file_descriptors</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Closes all open file descriptors starting from 3 up to the soft limit </span>
<span class="sd">    of the maximum number of file descriptors allowed for the process.</span>

<span class="sd">    This function is useful for cleaning up resources by ensuring that </span>
<span class="sd">    no unnecessary file descriptors remain open. It skips standard input, </span>
<span class="sd">    output, and error (file descriptors 0, 1, and 2).</span>

<span class="sd">    Exceptions during the closing of file descriptors are caught and ignored.</span>

<span class="sd">    Note:</span>
<span class="sd">        The function uses the `resource` module to retrieve the soft limit </span>
<span class="sd">        for the maximum number of file descriptors.</span>

<span class="sd">    Raises:</span>
<span class="sd">        OSError: If an error occurs while closing a file descriptor, it is </span>
<span class="sd">        caught and ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Close file descriptors and shared memory objects. &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">resource</span>

    <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_NOFILE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">soft</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="close_multiprocessing_processes">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.close_multiprocessing_processes">[docs]</a>
<span class="k">def</span> <span class="nf">close_multiprocessing_processes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Close all multiprocessing processes and clean up associated resources.</span>
<span class="sd">    This function iterates through all running processes and terminates any</span>
<span class="sd">    that are identified as multiprocessing processes, excluding the current</span>
<span class="sd">    process. It waits for up to 5 seconds for each process to terminate and</span>
<span class="sd">    logs the termination status. Additionally, it handles exceptions that may</span>
<span class="sd">    occur during the termination process, such as access denial or the process</span>
<span class="sd">    no longer existing.</span>
<span class="sd">    After terminating the processes, it ensures that any open file descriptors</span>
<span class="sd">    are properly closed.</span>
<span class="sd">    Note:</span>
<span class="sd">        This function relies on the `psutil` library to inspect and manage</span>
<span class="sd">        processes, and assumes the existence of helper functions:</span>
<span class="sd">        - `is_multiprocessing_process(proc)`: Determines if a process is a</span>
<span class="sd">          multiprocessing process.</span>
<span class="sd">        - `close_file_descriptors()`: Closes any open file descriptors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Close all multiprocessing processes. &quot;&quot;&quot;</span>
    <span class="n">current_pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">psutil</span><span class="o">.</span><span class="n">process_iter</span><span class="p">([</span><span class="s1">&#39;pid&#39;</span><span class="p">,</span> <span class="s1">&#39;cmdline&#39;</span><span class="p">]):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Skip the current process</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_pid</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Check if the process is a multiprocessing process</span>
            <span class="k">if</span> <span class="n">is_multiprocessing_process</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Wait up to 5 seconds for the process to terminate</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Terminated process </span><span class="si">{</span><span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">except</span> <span class="p">(</span><span class="n">psutil</span><span class="o">.</span><span class="n">NoSuchProcess</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">AccessDenied</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">ZombieProcess</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to terminate process </span><span class="si">{</span><span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Close file descriptors</span>
    <span class="n">close_file_descriptors</span><span class="p">()</span></div>


<div class="viewcode-block" id="check_mask_folder">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.check_mask_folder">[docs]</a>
<span class="k">def</span> <span class="nf">check_mask_folder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">mask_fldr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">check_mask_folder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">mask_fldr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the status of a mask folder within a given source directory.</span>
<span class="sd">        This function verifies whether the specified mask folder exists and </span>
<span class="sd">        whether the number of mask files matches the number of stack files </span>
<span class="sd">        in the corresponding stack folder. It returns a boolean indicating </span>
<span class="sd">        whether further processing is needed.</span>
<span class="sd">        Args:</span>
<span class="sd">            src (str): The source directory containing the &#39;masks&#39; and &#39;stack&#39; subdirectories.</span>
<span class="sd">            mask_fldr (str): The name of the mask folder to check within the &#39;masks&#39; directory.</span>
<span class="sd">        Returns:</span>
<span class="sd">            bool: </span>
<span class="sd">                - True if the mask folder does not exist or if the number of mask files </span>
<span class="sd">                  does not match the number of stack files.</span>
<span class="sd">                - False if the mask folder exists and all masks have been generated.</span>
<span class="sd">        Side Effects:</span>
<span class="sd">            Prints a message if all masks have been generated for the specified mask folder.</span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; check_mask_folder(&#39;/home/user/data&#39;, &#39;experiment1&#39;)</span>
<span class="sd">            All masks have been generated for experiment1</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
    <span class="n">mask_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;masks&#39;</span><span class="p">,</span><span class="n">mask_fldr</span><span class="p">)</span>
    <span class="n">stack_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;stack&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="n">mask_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">))</span>
    <span class="n">stack_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">stack_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">mask_count</span> <span class="o">==</span> <span class="n">stack_count</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All masks have been generated for </span><span class="si">{</span><span class="n">mask_fldr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="smooth_hull_lines">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.smooth_hull_lines">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_hull_lines</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooths the convex hull of a set of 2D points using spline interpolation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        cluster_data (numpy.ndarray): A 2D array of shape (n_points, 2) representing </span>
<span class="sd">                                       the coordinates of the points in the cluster.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: Two 1D numpy arrays representing the x and y coordinates of the smoothed </span>
<span class="sd">               convex hull, respectively. Each array contains 100 points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
    <span class="c1"># Extract vertices of the hull</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
    <span class="c1"># Close the loop</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]])</span>
    <span class="c1"># Parameterize the vertices</span>
    <span class="n">tck</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">splprep</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># Evaluate spline at new parameter values</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">tck</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_gen_rgb_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate an RGB image from the specified channels of the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (ndarray): The input image.</span>
<span class="sd">        channels (list): List of channel indices to use for RGB.</span>

<span class="sd">    Returns:</span>
<span class="sd">        rgb_image (ndarray): The generated RGB image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">rgb_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">chan</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rgb_image</span>

<span class="k">def</span> <span class="nf">_outline_and_overlay</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rgb_image</span><span class="p">,</span> <span class="n">mask_dims</span><span class="p">,</span> <span class="n">outline_colors</span><span class="p">,</span> <span class="n">outline_thickness</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate outlines for specified mask dimensions and overlay them onto an RGB image.</span>

<span class="sd">    This function processes a multi-dimensional mask to extract contours for each specified</span>
<span class="sd">    dimension, creates outlines with specified thickness, and overlays these outlines onto</span>
<span class="sd">    the provided RGB image using the given colors.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (numpy.ndarray): The input image containing multi-dimensional masks.</span>
<span class="sd">        rgb_image (numpy.ndarray): The RGB image onto which the outlines will be overlaid.</span>
<span class="sd">        mask_dims (list[int]): A list of dimensions (indices) in the mask to process.</span>
<span class="sd">        outline_colors (list[tuple[int, int, int]]): A list of RGB color tuples for the outlines.</span>
<span class="sd">        outline_thickness (int): The thickness of the outlines to be drawn.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - overlayed_image (numpy.ndarray): The RGB image with outlines overlaid.</span>
<span class="sd">            - outlines (list[numpy.ndarray]): A list of binary masks representing the outlines</span>
<span class="sd">              for each processed dimension.</span>
<span class="sd">            - image (numpy.ndarray): The original input image (unchanged).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outlines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">overlayed_image</span> <span class="o">=</span> <span class="n">rgb_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process_dim</span><span class="p">(</span><span class="n">mask_dim</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask_dim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Use uint8 for contour detection efficiency</span>

        <span class="c1"># Find and draw contours</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip background</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="n">find_contours</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># Convert contours for OpenCV format and draw directly to optimize</span>
            <span class="n">cv_contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">contour</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">]</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span> <span class="n">cv_contours</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="n">outline_thickness</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">dilation</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="n">outline_thickness</span><span class="p">))</span>

    <span class="c1"># Parallel processing</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">outlines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process_dim</span><span class="p">,</span> <span class="n">mask_dims</span><span class="p">))</span>

    <span class="c1"># Overlay outlines onto the RGB image</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outlines</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outline_colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">outline_colors</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">outline</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip background</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">outline</span> <span class="o">==</span> <span class="n">j</span>
            <span class="n">overlayed_image</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>  <span class="c1"># Direct assignment with broadcasting</span>

    <span class="k">return</span> <span class="n">overlayed_image</span><span class="p">,</span> <span class="n">outlines</span><span class="p">,</span> <span class="n">image</span>

<span class="k">def</span> <span class="nf">_convert_cq1_well_id</span><span class="p">(</span><span class="n">well_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a well ID to the CQ1 well format.</span>

<span class="sd">    Args:</span>
<span class="sd">        well_id (int): The well ID to be converted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The well ID in CQ1 well format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">well_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">well_id</span><span class="p">)</span>
    <span class="c1"># ASCII code for &#39;A&#39;</span>
    <span class="n">ascii_A</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="c1"># Calculate row and column</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">well_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="c1"># Convert row to letter (A-P) and adjust col to start from 1</span>
    <span class="n">row_letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">ascii_A</span> <span class="o">+</span> <span class="n">row</span><span class="p">)</span>
    <span class="c1"># Format column as two digits</span>
    <span class="n">well_format</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row_letter</span><span class="si">}{</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span> 
    <span class="k">return</span> <span class="n">well_format</span>

<span class="k">def</span> <span class="nf">_get_cellpose_batch_size</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the appropriate batch size for Cellpose based on the available GPU&#39;s VRAM.</span>

<span class="sd">    This function checks if CUDA is available and retrieves the VRAM (Video RAM) of the first GPU device.</span>
<span class="sd">    Based on the VRAM size, it assigns a batch size for Cellpose processing. If CUDA is not available</span>
<span class="sd">    or an error occurs, a default batch size of 8 is returned.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The batch size for Cellpose. Possible values are:</span>
<span class="sd">             - 8 (default or if VRAM &lt; 8 GB)</span>
<span class="sd">             - 16 (if 8 GB &lt;= VRAM &lt; 12 GB)</span>
<span class="sd">             - 48 (if 12 GB &lt;= VRAM &lt; 24 GB)</span>
<span class="sd">             - 96 (if VRAM &gt;= 24 GB)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Check if CUDA is available</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">device_properties</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_device_properties</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vram_gb</span> <span class="o">=</span> <span class="n">device_properties</span><span class="o">.</span><span class="n">total_memory</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Convert bytes to gigabytes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CUDA is not available. Please check your installation and GPU.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">12</span> <span class="ow">and</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">48</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">96</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device </span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">device_properties</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, VRAM: </span><span class="si">{</span><span class="n">vram_gb</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> GB, cellpose batch size: </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">batch_size</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">8</span>

<span class="k">def</span> <span class="nf">_extract_filename_metadata</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">regular_expression</span><span class="p">,</span> <span class="n">metadata_type</span><span class="o">=</span><span class="s1">&#39;cellvoyager&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts metadata from a list of filenames based on a provided regular expression</span>
<span class="sd">    and organizes the files into a dictionary grouped by metadata keys.</span>
<span class="sd">    Args:</span>
<span class="sd">        filenames (list of str): A list of filenames to process.</span>
<span class="sd">        src (str): The source directory containing the files.</span>
<span class="sd">        regular_expression (re.Pattern): A compiled regular expression used to extract metadata</span>
<span class="sd">            from the filenames. The regex should define named groups such as &#39;plateID&#39;, &#39;wellID&#39;,</span>
<span class="sd">            &#39;fieldID&#39;, &#39;chanID&#39;, &#39;timeID&#39;, and &#39;sliceID&#39; as applicable.</span>
<span class="sd">        metadata_type (str, optional): The type of metadata to process. Defaults to &#39;cellvoyager&#39;.</span>
<span class="sd">            If set to &#39;cq1&#39;, well IDs will be converted using `_convert_cq1_well_id`.</span>
<span class="sd">    Returns:</span>
<span class="sd">        defaultdict: A dictionary where keys are tuples of metadata values </span>
<span class="sd">        (plate, well, field, channel, timeID, sliceID), and values are lists of file paths</span>
<span class="sd">        corresponding to those metadata keys.</span>
<span class="sd">    Raises:</span>
<span class="sd">        IndexError: If the filename matches the regex but does not contain the expected groups.</span>
<span class="sd">        Prints warnings for filenames that do not match the regex or fail to extract metadata.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes that the provided regular expression includes named groups</span>
<span class="sd">          for extracting metadata.</span>
<span class="sd">        - If a metadata group (e.g., &#39;timeID&#39; or &#39;sliceID&#39;) is not present in the regex,</span>
<span class="sd">          its value will be set to `None`.</span>
<span class="sd">        - The function handles numeric metadata values by converting them to integers</span>
<span class="sd">          where applicable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">images_by_key</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plate</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;plateID&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">plate</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

                <span class="n">well</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wellID&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">well</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">well</span><span class="p">))</span>
                
                <span class="n">field</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;fieldID&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">field</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    
                <span class="n">channel</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;chanID&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
                    
                <span class="k">if</span> <span class="s1">&#39;timeID&#39;</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">():</span>
                    <span class="n">timeID</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;timeID&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">timeID</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                        <span class="n">timeID</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">timeID</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">timeID</span> <span class="o">=</span> <span class="kc">None</span>
                        
                <span class="k">if</span> <span class="s1">&#39;sliceID&#39;</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">():</span>
                    <span class="n">sliceID</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;sliceID&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sliceID</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                        <span class="n">sliceID</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">sliceID</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sliceID</span> <span class="o">=</span> <span class="kc">None</span>
                    
                <span class="k">if</span> <span class="n">metadata_type</span> <span class="o">==</span><span class="s1">&#39;cq1&#39;</span><span class="p">:</span>
                    <span class="n">orig_wellID</span> <span class="o">=</span> <span class="n">wellID</span>
                    <span class="n">wellID</span> <span class="o">=</span> <span class="n">_convert_cq1_well_id</span><span class="p">(</span><span class="n">wellID</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Converted Well ID: </span><span class="si">{</span><span class="n">orig_wellID</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">wellID</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">timeID</span><span class="p">,</span> <span class="n">sliceID</span><span class="p">)</span>
                <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="n">images_by_key</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not extract information from filename </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> using provided regex&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filename </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> did not match provided regex: </span><span class="si">{</span><span class="n">regular_expression</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
    <span class="k">return</span> <span class="n">images_by_key</span>

<div class="viewcode-block" id="mask_object_count">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.mask_object_count">[docs]</a>
<span class="k">def</span> <span class="nf">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of objects in a given mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - mask: numpy.ndarray. The mask containing object labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - int. The number of objects in the mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">num_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">num_objects</span></div>


<span class="k">def</span> <span class="nf">_update_database_with_merged_info</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges additional columns into the png_list table in the SQLite database and updates it.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The path to the SQLite database file.</span>
<span class="sd">        df (pd.DataFrame): DataFrame containing the additional info to be merged.</span>
<span class="sd">        table (str): Name of the table to update in the database. Defaults to &#39;png_list&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Connect to the SQLite database</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>

    <span class="c1"># Read the existing table into a DataFrame</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">existing_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SELECT * FROM </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to read table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> from database: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span>
    
    <span class="k">if</span> <span class="s1">&#39;prcfo&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;generating prcfo columns&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;rowID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;columnID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fieldID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_o&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging on cell failed, trying with cell_id&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;rowID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;columnID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fieldID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_o&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        
    <span class="c1"># Merge the existing DataFrame with the new info based on the &#39;prcfo&#39; column</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">existing_df</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">],</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    
    <span class="c1"># Drop the existing table and replace it with the updated DataFrame</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DROP TABLE IF EXISTS </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> successfully updated in the database.&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to update table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> in the database: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_generate_representative_images</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">cells</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;HeLa&#39;</span><span class="p">],</span> <span class="n">cell_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogens</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;rh&#39;</span><span class="p">],</span> <span class="n">pathogen_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatments</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cm&#39;</span><span class="p">],</span> <span class="n">treatment_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">compartments</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span><span class="s1">&#39;cytoplasm&#39;</span><span class="p">],</span> <span class="n">measurement</span> <span class="o">=</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">,</span> <span class="n">nr_imgs</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">channel_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">um_per_pixel</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">show_filename</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_db</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates representative images based on the provided parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The path to the SQLite database file.</span>
<span class="sd">        cells (list, optional): The list of host cell types. Defaults to [&#39;HeLa&#39;].</span>
<span class="sd">        cell_loc (list, optional): The list of location identifiers for host cells. Defaults to None.</span>
<span class="sd">        pathogens (list, optional): The list of pathogens. Defaults to [&#39;rh&#39;].</span>
<span class="sd">        pathogen_loc (list, optional): The list of location identifiers for pathogens. Defaults to None.</span>
<span class="sd">        treatments (list, optional): The list of treatments. Defaults to [&#39;cm&#39;].</span>
<span class="sd">        treatment_loc (list, optional): The list of location identifiers for treatments. Defaults to None.</span>
<span class="sd">        channel_of_interest (int, optional): The index of the channel of interest. Defaults to 1.</span>
<span class="sd">        compartments (list or str, optional): The compartments to compare. Defaults to [&#39;pathogen&#39;, &#39;cytoplasm&#39;].</span>
<span class="sd">        measurement (str, optional): The measurement to compare. Defaults to &#39;mean_intensity&#39;.</span>
<span class="sd">        nr_imgs (int, optional): The number of representative images to generate. Defaults to 16.</span>
<span class="sd">        channel_indices (list, optional): The indices of the channels to include in the representative images. Defaults to [0, 1, 2].</span>
<span class="sd">        um_per_pixel (float, optional): The scale factor for converting pixels to micrometers. Defaults to 0.1.</span>
<span class="sd">        scale_bar_length_um (float, optional): The length of the scale bar in micrometers. Defaults to 10.</span>
<span class="sd">        plot (bool, optional): Whether to plot the representative images. Defaults to False.</span>
<span class="sd">        fontsize (int, optional): The font size for the plot. Defaults to 12.</span>
<span class="sd">        show_filename (bool, optional): Whether to show the filename on the plot. Defaults to True.</span>
<span class="sd">        channel_names (list, optional): The names of the channels. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_read_and_join_tables</span><span class="p">,</span> <span class="n">_save_figure</span>
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">_plot_images_on_grid</span>
    
    <span class="n">df</span> <span class="o">=</span> <span class="n">_read_and_join_tables</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">annotate_conditions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_loc</span><span class="p">,</span> <span class="n">pathogens</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="p">,</span> <span class="n">treatments</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">update_db</span><span class="p">:</span>
        <span class="n">_update_database_with_merged_info</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">compartments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">measurement</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">compartments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">measurement</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">condition</span><span class="p">:</span> <span class="n">df_group</span> <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">df_group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;condition&#39;</span><span class="p">)}</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_filter_closest_to_stat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">,</span> <span class="n">n_rows</span><span class="o">=</span><span class="n">nr_imgs</span><span class="p">,</span> <span class="n">use_median</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">png_paths_by_condition</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">_plot_images_on_grid</span><span class="p">(</span><span class="n">png_paths_by_condition</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">,</span> <span class="n">um_per_pixel</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">show_filename</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_save_figure</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_indices</span><span class="p">:</span>
            <span class="n">channel_indices</span><span class="o">=</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">_plot_images_on_grid</span><span class="p">(</span><span class="n">png_paths_by_condition</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">,</span> <span class="n">um_per_pixel</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">show_filename</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>
            <span class="n">_save_figure</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
<span class="c1"># Adjusted mapping function to infer type from location identifiers</span>
<span class="k">def</span> <span class="nf">_map_values</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps values to a specific location in the row or column based on the given locs.</span>

<span class="sd">    Args:</span>
<span class="sd">        row (dict): The row dictionary containing the location identifier.</span>
<span class="sd">        values (list): The list of values to be mapped.</span>
<span class="sd">        locs (list): The list of location identifiers.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The mapped value corresponding to the given row or column location, or None if not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">locs</span><span class="p">:</span>
        <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">loc</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">loc_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">loc_list</span><span class="p">}</span>
        <span class="c1"># Determine if we&#39;re dealing with row or column based on first location identifier</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;rowID&#39;</span> <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span> <span class="k">else</span> <span class="s1">&#39;columnID&#39;</span>
        <span class="k">return</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">type_</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">values</span> <span class="k">else</span> <span class="kc">None</span>

<div class="viewcode-block" id="is_list_of_lists">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.is_list_of_lists">[docs]</a>
<span class="k">def</span> <span class="nf">is_list_of_lists</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="normalize_to_dtype">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.normalize_to_dtype">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_to_dtype</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="mi">98</span><span class="p">,</span> <span class="n">percentile_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize each image in the stack to its own percentiles.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - array: numpy array</span>
<span class="sd">    The input stack to be normalized.</span>
<span class="sd">    - p1: int, optional</span>
<span class="sd">    The lower percentile value for normalization. Default is 2.</span>
<span class="sd">    - p2: int, optional</span>
<span class="sd">    The upper percentile value for normalization. Default is 98.</span>
<span class="sd">    - percentile_list: list, optional</span>
<span class="sd">    A list of pre-calculated percentiles for each image in the stack. Default is None.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - new_stack: numpy array</span>
<span class="sd">    The normalized stack with the same shape as the input stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">new_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">new_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">]:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">new_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">]:</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="k">if</span> <span class="n">new_dtype</span> <span class="o">==</span> <span class="s1">&#39;uint8&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

    <span class="n">nimg</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">new_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">non_zero_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">percentile_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">percentile_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentile_1</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">percentile_2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="k">if</span> <span class="n">percentile_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">non_zero_img</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">percentile_1</span><span class="p">)</span>
                <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">percentile_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">percentile_1</span><span class="p">)</span>
                <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">percentile_2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Normalize to the range (0, 1) for visualization</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">out_range</span><span class="p">)</span>
        <span class="n">new_stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
    <span class="k">return</span> <span class="n">new_stack</span></div>

    
<span class="k">def</span> <span class="nf">_list_endpoint_subdirectories</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of subdirectories within the given base directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        base_dir (str): The base directory to search for subdirectories.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of subdirectories within the base directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">endpoint_subdirectories</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="n">endpoint_subdirectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            
    <span class="n">endpoint_subdirectories</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">endpoint_subdirectories</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;figure&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">endpoint_subdirectories</span>
    
<span class="k">def</span> <span class="nf">_generate_names</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_nucleus_ids</span><span class="p">,</span> <span class="n">cell_pathogen_ids</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">crop_mode</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate names for the image, folder, and table based on the given parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        cell_id (numpy.ndarray): An array of cell IDs.</span>
<span class="sd">        cell_nucleus_ids (numpy.ndarray): An array of cell nucleus IDs.</span>
<span class="sd">        cell_pathogen_ids (numpy.ndarray): An array of cell pathogen IDs.</span>
<span class="sd">        source_folder (str): The source folder path.</span>
<span class="sd">        crop_mode (str, optional): The crop mode. Defaults to &#39;cell&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the image name, folder path, and table name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_zero_cell_ids</span> <span class="o">=</span> <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">non_zero_cell_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">non_zero_cell_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">non_zero_cell_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">cell_nucleus_ids</span> <span class="o">=</span> <span class="n">cell_nucleus_ids</span><span class="p">[</span><span class="n">cell_nucleus_ids</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_nucleus_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cell_nucleus_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">cell_pathogen_ids</span> <span class="o">=</span> <span class="n">cell_pathogen_ids</span><span class="p">[</span><span class="n">cell_pathogen_ids</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_pathogen_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cell_pathogen_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">fldr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/data/&quot;</span>
    <span class="n">img_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_nucleus_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_pathogen/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_pathogens/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="k">elif</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_pathogen_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;infected/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="k">elif</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">or</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_pathogen/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_pathogens/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">plate</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">metadata</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">plate</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">well</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">fldr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fldr</span><span class="p">,</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="n">fldr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_name</span><span class="p">,</span> <span class="n">fldr</span><span class="p">,</span> <span class="n">table_name</span>

<span class="k">def</span> <span class="nf">_find_bounding_box</span><span class="p">(</span><span class="n">crop_mask</span><span class="p">,</span> <span class="n">_id</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the bounding box coordinates for a given object ID in a crop mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    crop_mask (ndarray): The crop mask containing object IDs.</span>
<span class="sd">    _id (int): The object ID to find the bounding box for.</span>
<span class="sd">    buffer (int, optional): The buffer size to add to the bounding box coordinates. Defaults to 10.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ndarray: A new mask with the same dimensions as crop_mask, where the bounding box area is filled with the object ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">object_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">crop_mask</span> <span class="o">==</span> <span class="n">_id</span><span class="p">)</span>

    <span class="c1"># Determine the bounding box coordinates</span>
    <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># Add buffer to the bounding box coordinates</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_min</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_max</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_min</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Create a new mask with the same dimensions as crop_mask</span>
    <span class="n">new_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">crop_mask</span><span class="p">)</span>

    <span class="c1"># Fill in the bounding box area with the _id</span>
    <span class="n">new_mask</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_id</span>

    <span class="k">return</span> <span class="n">new_mask</span>
    
<span class="k">def</span> <span class="nf">_merge_and_save_to_database</span><span class="p">(</span><span class="n">morph_df</span><span class="p">,</span> <span class="n">intensity_df</span><span class="p">,</span> <span class="n">table_type</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges morphology and intensity dataframes, renames columns, adds additional columns, rearranges columns,</span>
<span class="sd">        and saves the merged dataframe to a SQLite database.</span>

<span class="sd">        Args:</span>
<span class="sd">            morph_df (pd.DataFrame): Dataframe containing morphology data.</span>
<span class="sd">            intensity_df (pd.DataFrame): Dataframe containing intensity data.</span>
<span class="sd">            table_type (str): Type of table to save the merged dataframe to.</span>
<span class="sd">            source_folder (str): Path to the source folder.</span>
<span class="sd">            file_name (str): Name of the file.</span>
<span class="sd">            experiment (str): Name of the experiment.</span>
<span class="sd">            timelapse (bool, optional): Indicates if the data is from a timelapse experiment. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If an invalid table_type is provided or if columns are missing in the dataframe.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">morph_df</span> <span class="o">=</span> <span class="n">_check_integrity</span><span class="p">(</span><span class="n">morph_df</span><span class="p">)</span>
        <span class="n">intensity_df</span> <span class="o">=</span> <span class="n">_check_integrity</span><span class="p">(</span><span class="n">intensity_df</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">morph_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensity_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">morph_df</span><span class="p">,</span> <span class="n">intensity_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;label_list_x&quot;</span><span class="p">:</span> <span class="s2">&quot;label_list_morphology&quot;</span><span class="p">,</span> <span class="s2">&quot;label_list_y&quot;</span><span class="p">:</span> <span class="s2">&quot;label_list_intensity&quot;</span><span class="p">})</span>
            <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_name</span>
            <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;path_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source_folder</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
                <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;timeid&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="p">)))</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># get the list of all columns</span>
            <span class="k">if</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">or</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span> <span class="ow">or</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid table_type: </span><span class="si">{</span><span class="n">table_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Check if all columns in column_list are in cols</span>
            <span class="n">missing_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_list</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">missing_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span>
                <span class="n">missing_columns</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Columns missing in DataFrame: </span><span class="si">{</span><span class="n">missing_columns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_list</span><span class="p">):</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>  <span class="c1"># rearrange the columns</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s1">/measurements/measurements.db&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="n">table_type</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SQLite error:&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    
<span class="k">def</span> <span class="nf">_safe_int_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the given value to an integer if possible, otherwise returns the default value.</span>

<span class="sd">    Args:</span>
<span class="sd">        value: The value to be converted to an integer.</span>
<span class="sd">        default: The default value to be returned if the conversion fails. Default is 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The converted integer value if successful, otherwise the default value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not convert </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> to int using </span><span class="si">{</span><span class="n">default</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">default</span>

<span class="k">def</span> <span class="nf">_map_wells</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps the components of a file name to plate, row, column, field, and timeid (if timelapse is True).</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        timelapse (bool, optional): Indicates whether the file is part of a timelapse sequence. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the mapped values for plate, row, column, field, and timeid (if timelapse is True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">timeid</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="n">row</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">well</span><span class="p">,</span> <span class="n">well</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>    
            <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing filename: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">prcf</span>

<span class="k">def</span> <span class="nf">_map_wells_png</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps the components of a file name to their corresponding values.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        timelapse (bool, optional): Indicates whether the file is part of a timelapse sequence. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the mapped components of the file name.</span>

<span class="sd">    Raises:</span>
<span class="sd">        None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">timeid</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">object_id</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="n">row</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">well</span><span class="p">,</span> <span class="n">well</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">object_id</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">object_id</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing filename: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">object_id</span><span class="p">,</span> <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcfo</span><span class="p">,</span> <span class="n">object_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">prcfo</span><span class="p">,</span> <span class="n">object_id</span>
        
<span class="k">def</span> <span class="nf">_check_integrity</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the integrity of the DataFrame and perform necessary modifications.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The modified DataFrame with integrity checks and modifications applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">col</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
    <span class="n">label_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">label_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">label_cols</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>
    
<span class="k">def</span> <span class="nf">_get_percentiles</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the percentiles of each image in the given array.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - array: numpy.ndarray</span>
<span class="sd">        The input array containing the images.</span>
<span class="sd">    - q1: float, optional</span>
<span class="sd">        The lower percentile value to calculate. Default is 2.</span>
<span class="sd">    - q2: float, optional</span>
<span class="sd">        The upper percentile value to calculate. Default is 98.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - percentiles: list</span>
<span class="sd">        A list of tuples, where each tuple contains the minimum and maximum</span>
<span class="sd">        values of the corresponding image in the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nimg</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">])</span>
        <span class="n">non_zero_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">non_zero_img</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># check if there are non-zero values</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>  <span class="c1"># change percentile from 0.02 to 2</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>  <span class="c1"># change percentile from 0.98 to 98</span>
            <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if there are no non-zero values, just use the image as it is</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>  <span class="c1"># change percentile from 0.02 to 2</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>  <span class="c1"># change percentile from 0.98 to 98</span>
            <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">percentiles</span>

<span class="k">def</span> <span class="nf">_crop_center</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">new_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the image around the center of the cell mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - img: numpy.ndarray</span>
<span class="sd">        The input image.</span>
<span class="sd">    - cell_mask: numpy.ndarray</span>
<span class="sd">        The binary mask of the cell.</span>
<span class="sd">    - new_width: int</span>
<span class="sd">        The desired width of the cropped image.</span>
<span class="sd">    - new_height: int</span>
<span class="sd">        The desired height of the cropped image.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - img: numpy.ndarray</span>
<span class="sd">        The cropped image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert all non-zero values in mask to 1</span>
    <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># Create 3D mask</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># Multiply image with mask to set pixel values outside of the mask to 0</span>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ndi</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># Compute centroid of the mask</span>
    
    <span class="c1"># Pad the image and mask to ensure the crop will not go out of bounds</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    
    <span class="c1"># Update centroid coordinates due to padding</span>
    <span class="n">centroid</span> <span class="o">+=</span> <span class="n">pad_width</span>
    
    <span class="c1"># Compute bounding box</span>
    <span class="n">start_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_height</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">end_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_y</span> <span class="o">+</span> <span class="n">new_height</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">end_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_x</span> <span class="o">+</span> <span class="n">new_width</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Crop to bounding box</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">start_y</span><span class="p">:</span><span class="n">end_y</span><span class="p">,</span> <span class="n">start_x</span><span class="p">:</span><span class="n">end_x</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">img</span>
    
<span class="k">def</span> <span class="nf">_masks_to_masks_stack</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a list of masks into a stack of masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        masks (list): A list of masks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A stack of masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
        <span class="n">mask_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask_stack</span>

<span class="k">def</span> <span class="nf">_get_diam</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mag</span> <span class="o">+</span> <span class="mi">80</span>
        
    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;cell_large&#39;</span><span class="p">:</span>
        <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mag</span> <span class="o">+</span> <span class="mi">120</span>
                                
    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">diamiter</span> <span class="o">=</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">mag</span> <span class="o">+</span> <span class="mi">45</span>
                                
    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">diamiter</span> <span class="o">=</span> <span class="n">mag</span>
                                
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">diamiter</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_object_settings</span><span class="p">(</span><span class="n">object_type</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate and return a dictionary of settings for a specific object type.</span>
<span class="sd">    This function configures object-specific settings based on the provided</span>
<span class="sd">    `object_type` and `settings`. It supports three object types: &#39;cell&#39;,</span>
<span class="sd">    &#39;nucleus&#39;, and &#39;pathogen&#39;. If an unsupported object type is provided, </span>
<span class="sd">    a message is printed, and no settings are returned.</span>
<span class="sd">    Args:</span>
<span class="sd">        object_type (str): The type of object to configure settings for. </span>
<span class="sd">                           Supported values are &#39;cell&#39;, &#39;nucleus&#39;, and &#39;pathogen&#39;.</span>
<span class="sd">        settings (dict): A dictionary containing global settings, which may include:</span>
<span class="sd">            - &#39;magnification&#39; (float): Magnification level used to calculate diameter.</span>
<span class="sd">            - &#39;nucleus_channel&#39; (optional): Specifies if a nucleus channel is present.</span>
<span class="sd">            - &#39;cell_restore_type&#39; (optional): Restore type for cell objects.</span>
<span class="sd">            - &#39;nucleus_restore_type&#39; (optional): Restore type for nucleus objects.</span>
<span class="sd">            - &#39;pathogen_restore_type&#39; (optional): Restore type for pathogen objects.</span>
<span class="sd">            - &#39;merge_pathogens&#39; (bool): Whether to merge pathogens.</span>
<span class="sd">            - &#39;verbose&#39; (bool): Whether to print the generated settings.</span>
<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary containing the configured settings for the specified object type.</span>
<span class="sd">              The dictionary includes keys such as &#39;diameter&#39;, &#39;minimum_size&#39;, &#39;maximum_size&#39;,</span>
<span class="sd">              &#39;merge&#39;, &#39;resample&#39;, &#39;remove_border_objects&#39;, &#39;model_name&#39;, &#39;filter_size&#39;,</span>
<span class="sd">              &#39;filter_intensity&#39;, and &#39;restore_type&#39;.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The &#39;diameter&#39; is calculated using the `_get_diam` function based on the </span>
<span class="sd">          magnification level and object type.</span>
<span class="sd">        - The &#39;minimum_size&#39; and &#39;maximum_size&#39; are derived from the diameter.</span>
<span class="sd">        - The &#39;model_name&#39; varies depending on the object type and other settings.</span>
<span class="sd">        - If `settings[&#39;verbose&#39;]` is True, the generated settings are printed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">object_settings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_diam</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">],</span> <span class="n">obj</span><span class="o">=</span><span class="n">object_type</span><span class="p">)</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;minimum_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;maximum_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;resample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;remove_border_objects&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
    
    <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;nucleus_channel&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto2&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nuclei&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nucleus_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;resample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pathogen_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;merge_pathogens&#39;</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Object type: </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> not supported. Supported object types are : cell, nucleus and pathogen&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">object_settings</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">object_settings</span>
    
<span class="k">def</span> <span class="nf">_pivot_counts_table</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_read_table_to_dataframe</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">table_name</span><span class="o">=</span><span class="s1">&#39;object_counts&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a table from an SQLite database into a pandas DataFrame.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - db_path (str): The path to the SQLite database file.</span>
<span class="sd">        - table_name (str): The name of the table to read. Default is &#39;object_counts&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - df (pandas.DataFrame): The table data as a pandas DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Connect to the SQLite database</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="c1"># Read the entire table into a pandas DataFrame</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SELECT * FROM </span><span class="si">{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="c1"># Close the connection</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">_pivot_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pivot the DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The input DataFrame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: The pivoted DataFrame with filled NaN values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pivot the DataFrame</span>
        <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;count_type&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;object_count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># Because the pivot operation can introduce NaN values for missing data,</span>
        <span class="c1"># you might want to fill those NaNs with a default value, like 0</span>
        <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">pivoted_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pivoted_df</span>

    <span class="c1"># Read the original &#39;object_counts&#39; table</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_read_table_to_dataframe</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="s1">&#39;object_counts&#39;</span><span class="p">)</span>
    <span class="c1"># Pivot the DataFrame to have one row per filename and a column for each object type</span>
    <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">_pivot_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="c1"># Reconnect to the SQLite database to overwrite the &#39;object_counts&#39; table with the pivoted DataFrame</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
    <span class="c1"># When overwriting, ensure that you drop the existing table or use if_exists=&#39;replace&#39; to overwrite it</span>
    <span class="n">pivoted_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;pivoted_counts&#39;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">_get_cellpose_channels_v2</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dictionary of Cellpose channels based on the provided input channels.</span>

<span class="sd">    This function constructs a mapping of Cellpose channels for nucleus, pathogen, </span>
<span class="sd">    and cell segmentation. It also checks for the existence of precomputed mask </span>
<span class="sd">    files and issues a warning if any channel is `None` while masks already exist.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str): The source directory containing the &#39;masks&#39; folder with precomputed </span>
<span class="sd">                   mask files (&#39;cell_mask_stack&#39;, &#39;nucleus_mask_stack&#39;, &#39;pathogen_mask_stack&#39;).</span>
<span class="sd">        nucleus_channel (int or None): The channel index for the nucleus. If `None`, </span>
<span class="sd">                                       the nucleus channel is not included.</span>
<span class="sd">        pathogen_channel (int or None): The channel index for the pathogen. If `None`, </span>
<span class="sd">                                        the pathogen channel is not included.</span>
<span class="sd">        cell_channel (int or None): The channel index for the cell. If `None`, the cell </span>
<span class="sd">                                    channel is not included.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where keys are &#39;nucleus&#39;, &#39;pathogen&#39;, and &#39;cell&#39;, and values </span>
<span class="sd">              are lists of two integers representing the channels to be used for each </span>
<span class="sd">              type. If a channel is not provided (`None`), it is excluded from the dictionary.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        Prints a warning if any of the channels (`nucleus_channel`, `pathogen_channel`, </span>
<span class="sd">        `cell_channel`) is `None` while precomputed mask files already exist in the </span>
<span class="sd">        specified source directory.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The nucleus and pathogen channels are always duplicated as [channel, channel].</span>
<span class="sd">        - The cell channel prefers the nucleus channel as the first channel if available; </span>
<span class="sd">          otherwise, it duplicates the cell channel as [cell_channel, cell_channel].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">nucleus_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">pathogen_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen_mask_stack&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_mask_path</span><span class="p">,</span> <span class="n">nucleus_mask_path</span><span class="p">,</span> <span class="n">pathogen_mask_path</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Cellpose masks already exist. Unexpected behaviour if any channel is None while masks exist.&#39;</span><span class="p">)</span>

    <span class="n">cellpose_channels</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Nucleus: always duplicated single channel</span>
    <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;nucleus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">]</span>

    <span class="c1"># Pathogen: always duplicated single channel</span>
    <span class="k">if</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">]</span>

    <span class="c1"># Cell: prefer nucleus as second if available</span>
    <span class="k">if</span> <span class="n">cell_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cellpose_channels</span>
    
<span class="k">def</span> <span class="nf">_get_cellpose_channels_v1</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a dictionary mapping object types (nucleus, pathogen, cell) to their respective </span>
<span class="sd">    Cellpose channel configurations based on the provided input channels.</span>
<span class="sd">    This function checks for the existence of pre-generated Cellpose masks in the specified </span>
<span class="sd">    source directory and warns the user if any of the input channels are set to None while </span>
<span class="sd">    masks already exist. The function then constructs a dictionary of Cellpose channel </span>
<span class="sd">    configurations for the specified object types.</span>
<span class="sd">    Args:</span>
<span class="sd">        src (str): The source directory path where the Cellpose masks are stored.</span>
<span class="sd">        nucleus_channel (int or None): The channel index for the nucleus. If None, the nucleus </span>
<span class="sd">            is not included in the configuration.</span>
<span class="sd">        pathogen_channel (int or None): The channel index for the pathogen. If None, the pathogen </span>
<span class="sd">            is not included in the configuration.</span>
<span class="sd">        cell_channel (int or None): The channel index for the cell. If None, the cell is not </span>
<span class="sd">            included in the configuration.</span>
<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where keys are object types (&#39;nucleus&#39;, &#39;pathogen&#39;, &#39;cell&#39;) and </span>
<span class="sd">        values are lists specifying the Cellpose channel configuration for each object type.</span>
<span class="sd">    Warnings:</span>
<span class="sd">        Prints a warning if any of the input channels are set to None while Cellpose masks </span>
<span class="sd">        already exist in the specified source directory.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes that the Cellpose masks are stored in subdirectories named </span>
<span class="sd">          &#39;masks/cell_mask_stack&#39;, &#39;masks/nucleus_mask_stack&#39;, and &#39;masks/pathogen_mask_stack&#39; </span>
<span class="sd">          within the source directory.</span>
<span class="sd">        - The channel configuration is represented as a list of two integers, where the first </span>
<span class="sd">          integer is always 0, and the second integer depends on the presence of other channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cell_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">nucleus_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">pathogen_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen_mask_stack&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_mask_path</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nucleus_mask_path</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathogen_mask_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Cellpose masks already exist. Unexpected behaviour when setting any object dimention to None when the object masks have been created.&#39;</span><span class="p">)</span>
        
    <span class="n">cellpose_channels</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;nucleus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
    <span class="k">return</span> <span class="n">cellpose_channels</span>

<span class="k">def</span> <span class="nf">_get_cellpose_channels</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mapping of channels for Cellpose segmentation based on the provided input channels.</span>

<span class="sd">    This function determines the logical order of channels for nucleus, cell, and pathogen,</span>
<span class="sd">    removes duplicates while preserving the first occurrence, and maps the channels to indices</span>
<span class="sd">    capped at a maximum value of 2. It then assigns these indices to the respective Cellpose</span>
<span class="sd">    segmentation categories.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str): The source directory containing the mask files.</span>
<span class="sd">        nucleus_channel (int or None): The channel index for the nucleus. If None, the nucleus</span>
<span class="sd">            is not included in the mapping.</span>
<span class="sd">        pathogen_channel (int or None): The channel index for the pathogen. If None, the pathogen</span>
<span class="sd">            is not included in the mapping.</span>
<span class="sd">        cell_channel (int or None): The channel index for the cell. If None, the cell is not</span>
<span class="sd">            included in the mapping.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary mapping segmentation categories (&#39;nucleus&#39;, &#39;cell&#39;, &#39;pathogen&#39;) to</span>
<span class="sd">        their respective channel indices. Each category is assigned a list of two indices,</span>
<span class="sd">        which are either identical or derived from the logical order of the input channels.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        If any of the mask files already exist in the `src` directory and any of the input</span>
<span class="sd">        channels (`nucleus_channel`, `pathogen_channel`, `cell_channel`) are None, a warning</span>
<span class="sd">        is printed indicating potential unexpected behavior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">nucleus_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">pathogen_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen_mask_stack&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_mask_path</span><span class="p">,</span> <span class="n">nucleus_mask_path</span><span class="p">,</span> <span class="n">pathogen_mask_path</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Cellpose masks already exist. Unexpected behaviour if any channel is None while masks exist.&#39;</span><span class="p">)</span>

    <span class="c1"># Enforced order: nucleus → cell → pathogen</span>
    <span class="n">logical_order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logical_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;nucleus&#39;</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">cell_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logical_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logical_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">))</span>

    <span class="c1"># Remove duplicate values while preserving first occurrence</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">ordered_channels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">logical_order</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">ordered_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

    <span class="c1"># Map actual channel values to capped indices</span>
    <span class="n">remap</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ordered_channels</span><span class="p">)}</span>

    <span class="c1"># Final channel assignments</span>
    <span class="n">cellpose_channels</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">remap</span><span class="p">[</span><span class="n">nucleus_channel</span><span class="p">]</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;nucleus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cell_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">remap</span><span class="p">[</span><span class="n">cell_channel</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">remap</span><span class="p">[</span><span class="n">nucleus_channel</span><span class="p">]</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">remap</span><span class="p">[</span><span class="n">pathogen_channel</span><span class="p">]</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cellpose_channels</span>

<div class="viewcode-block" id="annotate_conditions">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.annotate_conditions">[docs]</a>
<span class="k">def</span> <span class="nf">annotate_conditions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotates conditions in a DataFrame based on specified criteria and combines them into a &#39;condition&#39; column.</span>
<span class="sd">    NaN is used for missing values, and they are excluded from the &#39;condition&#39; column.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The DataFrame to annotate.</span>
<span class="sd">        cells (list/str, optional): Host cell types. Defaults to None.</span>
<span class="sd">        cell_loc (list of lists, optional): Values for each host cell type. Defaults to None.</span>
<span class="sd">        pathogens (list/str, optional): Pathogens. Defaults to None.</span>
<span class="sd">        pathogen_loc (list of lists, optional): Values for each pathogen. Defaults to None.</span>
<span class="sd">        treatments (list/str, optional): Treatments. Defaults to None.</span>
<span class="sd">        treatment_loc (list of lists, optional): Values for each treatment. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: Annotated DataFrame with a combined &#39;condition&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if a value maps to &#39;rowID&#39; or &#39;columnID&#39;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;columnID&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;rowID&#39;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_map_or_default</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consolidates the logic for mapping values or assigning defaults when loc is None.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            column_name (str): The column in the DataFrame to annotate.</span>
<span class="sd">            values (list/str): The list of values or a single string to annotate.</span>
<span class="sd">            loc (list of lists): Location mapping for the values, or None if not used.</span>
<span class="sd">            df (pandas.DataFrame): The DataFrame to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a single string is provided and loc is None, assign the value to all rows</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>  
    
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a list of values is provided but no loc, assign the first value to all rows</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
        <span class="k">elif</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Perform location-based mapping</span>
            <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">loc_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">loc_list</span><span class="p">}</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Start with NaN</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">loc_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">loc_type</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">loc_type</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="c1"># Handle cells, pathogens, and treatments using the consolidated logic</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="n">pathogens</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="n">treatments</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

    <span class="c1"># Conditionally fill NaN for pathogen and treatment columns if applicable</span>
    <span class="k">if</span> <span class="n">pathogens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">treatments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;treatment&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Create the &#39;condition&#39; column by excluding any NaN values, safely checking if &#39;host_cells&#39;, &#39;pathogen&#39;, and &#39;treatment&#39; exist</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;host_cells&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pathogen&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;treatment&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">v</span><span class="p">)]),</span> 
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">NA</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_split_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_by</span><span class="p">,</span> <span class="n">object_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input dataframe into numeric and non-numeric parts, groups them by the specified column,</span>
<span class="sd">    and returns the grouped dataframes with conditional aggregation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The input dataframe.</span>
<span class="sd">    group_by (str): The column name to group the dataframes by.</span>
<span class="sd">    object_type (str): The column name to concatenate with &#39;prcf&#39; to create a new column &#39;prcfo&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    grouped_numeric (pandas.DataFrame): The grouped dataframe containing numeric columns with conditional aggregation.</span>
<span class="sd">    grouped_non_numeric (pandas.DataFrame): The grouped dataframe containing non-numeric columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Ensure &#39;prcf&#39; column exists by concatenating specific columns</span>
    <span class="k">if</span> <span class="s1">&#39;prcf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;rowID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;columnID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fieldID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>    
    
    <span class="c1"># Create the &#39;prcfo&#39; column</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">object_type</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Split the DataFrame into numeric and non-numeric parts</span>
    <span class="n">df_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
    <span class="n">df_non_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="c1"># Define keywords for columns to be summed instead of averaged</span>
    <span class="n">sum_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;convex_area&#39;</span><span class="p">,</span> <span class="s1">&#39;bbox_area&#39;</span><span class="p">,</span> <span class="s1">&#39;filled_area&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent_diameter&#39;</span><span class="p">]</span>

    <span class="c1"># Create a dictionary for custom aggregation</span>
    <span class="n">agg_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df_numeric</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">column</span> <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">sum_keywords</span><span class="p">):</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span>

    <span class="c1"># Apply custom aggregation</span>
    <span class="n">grouped_numeric</span> <span class="o">=</span> <span class="n">df_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_dict</span><span class="p">)</span>
    <span class="n">grouped_non_numeric</span> <span class="o">=</span> <span class="n">df_non_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_non_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_numeric</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_non_numeric</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_calculate_recruitment</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate recruitment metrics based on intensity values in different channels.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame containing intensity values in different channels.</span>
<span class="sd">        channel (int): The channel number.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The DataFrame with calculated recruitment metrics.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cell_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cytoplasm_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_nucleus_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cell_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cytoplasm_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_nucleus_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">object_type</span> <span class="o">=</span> <span class="s1">&#39;pathogen&#39;</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_slope_channel_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">object_type</span> <span class="o">=</span> <span class="s1">&#39;nucleus&#39;</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_slope_channel_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">#for chan in channels:</span>
    <span class="c1">#    df[f&#39;nucleus_coordinates_{chan}&#39;] = df[[f&#39;nucleus_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;nucleus_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;pathogen_coordinates_{chan}&#39;] = df[[f&#39;pathogen_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;pathogen_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;cell_coordinates_{chan}&#39;] = df[[f&#39;cell_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;cell_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;cytoplasm_coordinates_{chan}&#39;] = df[[f&#39;cytoplasm_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;cytoplasm_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1"># </span>
    <span class="c1">#    df[f&#39;pathogen_cell_distance_channel_{chan}&#39;] = df.apply(lambda row: np.sqrt((row[f&#39;pathogen_coordinates_{chan}&#39;][0] - row[f&#39;cell_coordinates_{chan}&#39;][0])**2 + </span>
    <span class="c1">#                                                  (row[f&#39;pathogen_coordinates_{chan}&#39;][1] - row[f&#39;cell_coordinates_{chan}&#39;][1])**2), axis=1)</span>
    <span class="c1">#    df[f&#39;nucleus_cell_distance_channel_{chan}&#39;] = df.apply(lambda row: np.sqrt((row[f&#39;nucleus_coordinates_{chan}&#39;][0] - row[f&#39;cell_coordinates_{chan}&#39;][0])**2 + </span>
    <span class="c1">#                                                  (row[f&#39;nucleus_coordinates_{chan}&#39;][1] - row[f&#39;cell_coordinates_{chan}&#39;][1])**2), axis=1)</span>
    <span class="k">return</span> <span class="n">df</span>
    
<span class="k">def</span> <span class="nf">_group_by_well</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group the DataFrame by well coordinates (plate, row, col) and apply mean function to numeric columns</span>
<span class="sd">    and select the first value for non-numeric columns.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (DataFrame): The input DataFrame to be grouped.</span>

<span class="sd">    Returns:</span>
<span class="sd">    DataFrame: The grouped DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numeric_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">non_numeric_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>

    <span class="c1"># Apply mean function to numeric columns and first to non-numeric</span>
    <span class="n">df_grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">numeric_cols</span><span class="p">},</span> <span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="s1">&#39;first&#39;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">non_numeric_cols</span><span class="p">}})</span>
    <span class="k">return</span> <span class="n">df_grouped</span>

<span class="c1">###################################################</span>
<span class="c1">#  Classify</span>
<span class="c1">###################################################</span>

<div class="viewcode-block" id="Cache">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.Cache">[docs]</a>
<span class="k">class</span> <span class="nc">Cache</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing a cache with a maximum size.</span>

<span class="sd">    Args:</span>
<span class="sd">        max_size (int): The maximum size of the cache.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
<div class="viewcode-block" id="Cache.cache">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.Cache.cache">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span></div>

<div class="viewcode-block" id="Cache.max_size">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.Cache.max_size">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">max_size</span></div>


<div class="viewcode-block" id="Cache.get">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.Cache.get">[docs]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cache.put">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.Cache.put">[docs]</a>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>
</div>


<div class="viewcode-block" id="ScaledDotProductAttention_v1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1">[docs]</a>
<span class="k">class</span> <span class="nc">ScaledDotProductAttention_v1</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scaled Dot-Product Attention module.</span>

<span class="sd">    Args:</span>
<span class="sd">        d_k (int): The dimension of the key and query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScaledDotProductAttention_v1</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="ScaledDotProductAttention_v1.d_k">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1.d_k">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">d_k</span></div>


<div class="viewcode-block" id="ScaledDotProductAttention_v1.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention_v1.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the forward pass of the attention mechanism.</span>

<span class="sd">        Args:</span>
<span class="sd">            Q (torch.Tensor): The query tensor of shape (batch_size, seq_len_q, d_k).</span>
<span class="sd">            K (torch.Tensor): The key tensor of shape (batch_size, seq_len_k, d_k).</span>
<span class="sd">            V (torch.Tensor): The value tensor of shape (batch_size, seq_len_v, d_k).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor of shape (batch_size, seq_len_q, d_k).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="SelfAttention_v1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1">[docs]</a>
<span class="k">class</span> <span class="nc">SelfAttention_v1</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-Attention module that applies scaled dot-product attention mechanism.</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">        d_k (int): Dimensionality of the key and query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelfAttention_v1</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="SelfAttention_v1.W_q">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_q">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention_v1.W_k">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_k">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention_v1.W_v">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.W_v">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention_v1.attention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.attention">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">ScaledDotProductAttention</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span></div>


<div class="viewcode-block" id="SelfAttention_v1.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention_v1.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the SelfAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor of shape (batch_size, d_k).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="ScaledDotProductAttention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention">[docs]</a>
<span class="k">class</span> <span class="nc">ScaledDotProductAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the ScaledDotProductAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            d_k (int): The dimension of the key and query vectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScaledDotProductAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="ScaledDotProductAttention.d_k">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention.d_k">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">d_k</span></div>


<div class="viewcode-block" id="ScaledDotProductAttention.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ScaledDotProductAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the forward pass of the ScaledDotProductAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            Q (torch.Tensor): The query tensor.</span>
<span class="sd">            K (torch.Tensor): The key tensor.</span>
<span class="sd">            V (torch.Tensor): The value tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="SelfAttention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention">[docs]</a>
<span class="k">class</span> <span class="nc">SelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-Attention module that applies scaled dot-product attention mechanism.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">        d_k (int): Dimensionality of the key and query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelfAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="SelfAttention.W_q">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_q">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention.W_k">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_k">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention.W_v">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.W_v">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span></div>

<div class="viewcode-block" id="SelfAttention.attention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.attention">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">ScaledDotProductAttention</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SelfAttention.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelfAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the SelfAttention module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor after applying self-attention mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<span class="c1"># Early Fusion Block</span>
<div class="viewcode-block" id="EarlyFusion">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion">[docs]</a>
<span class="k">class</span> <span class="nc">EarlyFusion</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Early Fusion module for image classification.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EarlyFusion</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="EarlyFusion.conv1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion.conv1">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="EarlyFusion.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.EarlyFusion.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the Early Fusion module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels, height, width).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor of shape (batch_size, 64, height, width).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
</div>


<span class="c1"># Spatial Attention Mechanism</span>
<div class="viewcode-block" id="SpatialAttention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention">[docs]</a>
<span class="k">class</span> <span class="nc">SpatialAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the SpatialAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            kernel_size (int): The size of the convolutional kernel. Default is 7.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SpatialAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="SpatialAttention.conv1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.conv1">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">kernel_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpatialAttention.sigmoid">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.sigmoid">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpatialAttention.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SpatialAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs forward pass of the SpatialAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): The input tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor after applying spatial attention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">avg_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">max_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">avg_out</span><span class="p">,</span> <span class="n">max_out</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>

    
<span class="c1"># Multi-Scale Block with Attention</span>
<div class="viewcode-block" id="MultiScaleBlockWithAttention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention">[docs]</a>
<span class="k">class</span> <span class="nc">MultiScaleBlockWithAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch module implementing a multi-scale convolutional block with spatial attention.</span>

<span class="sd">    This module applies a dilated convolution followed by a spatial attention mechanism</span>
<span class="sd">    to enhance input feature maps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the MultiScaleBlockWithAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            in_channels (int): Number of input channels.</span>
<span class="sd">            out_channels (int): Number of output channels after convolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiScaleBlockWithAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="MultiScaleBlockWithAttention.dilated_conv1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.dilated_conv1">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">dilated_conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiScaleBlockWithAttention.spatial_attention">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.spatial_attention">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_attention</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="MultiScaleBlockWithAttention.custom_forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.custom_forward">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply dilated convolution followed by spatial attention.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (N, C, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor after attention-enhanced feature transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dilated_conv1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_attention</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="MultiScaleBlockWithAttention.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MultiScaleBlockWithAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard forward pass that delegates to `custom_forward`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>


<span class="c1"># Final Classifier</span>
<div class="viewcode-block" id="CustomCellClassifier">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier">[docs]</a>
<span class="k">class</span> <span class="nc">CustomCellClassifier</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom neural network module for single-cell classification using early fusion and multi-scale attention.</span>

<span class="sd">    This architecture supports optional gradient checkpointing for reduced memory usage during training.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">use_attention</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the classifier with early fusion and attention blocks.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_classes (int): Number of classification categories.</span>
<span class="sd">            pathogen_channel (int): Unused; reserved for future feature fusion.</span>
<span class="sd">            use_attention (bool): Unused; reserved for attention gating.</span>
<span class="sd">            use_checkpoint (bool): Whether to use checkpointing to reduce memory.</span>
<span class="sd">            dropout_rate (float): Unused; reserved for future regularization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomCellClassifier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="CustomCellClassifier.early_fusion">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.early_fusion">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">early_fusion</span> <span class="o">=</span> <span class="n">EarlyFusion</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="CustomCellClassifier.multi_scale_block_1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.multi_scale_block_1">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_scale_block_1</span> <span class="o">=</span> <span class="n">MultiScaleBlockWithAttention</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="CustomCellClassifier.fc1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.fc1">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span></div>

<div class="viewcode-block" id="CustomCellClassifier.use_checkpoint">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.use_checkpoint">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span></div>

        <span class="c1"># Explicitly require gradients for all parameters</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        
<div class="viewcode-block" id="CustomCellClassifier.custom_forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.custom_forward">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a standard forward pass without gradient checkpointing.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (N, C, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Logits for each class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">early_fusion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_scale_block_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">adaptive_avg_pool2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="CustomCellClassifier.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.CustomCellClassifier.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass with optional gradient checkpointing.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output logits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span> 
            <span class="k">return</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>


<span class="c1">#CNN and Transformer class, pick any Torch model.</span>
<div class="viewcode-block" id="TorchModel">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel">[docs]</a>
<span class="k">class</span> <span class="nc">TorchModel</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch wrapper for pretrained torchvision models with a custom SPACR classifier head.</span>

<span class="sd">    This class supports custom dropout insertion and optional gradient checkpointing</span>
<span class="sd">    for memory efficiency during training.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="s1">&#39;resnet50&#39;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TorchModel with optional dropout and checkpointing.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_name (str): The model architecture to load from torchvision.models.</span>
<span class="sd">            pretrained (bool): Whether to initialize with pretrained weights.</span>
<span class="sd">            dropout_rate (float or None): Dropout rate for the classifier head.</span>
<span class="sd">            use_checkpoint (bool): Whether to enable gradient checkpointing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TorchModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="TorchModel.model_name">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.model_name">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span></div>

<div class="viewcode-block" id="TorchModel.use_checkpoint">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.use_checkpoint">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span></div>

<div class="viewcode-block" id="TorchModel.base_model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.base_model">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_base_model</span><span class="p">(</span><span class="n">pretrained</span><span class="p">)</span></div>

        
        <span class="c1"># Retain layers up to and including the (5): Linear layer for model &#39;maxvit_t&#39;</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;maxvit_t&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">children</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">dropout_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_dropout_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">)</span>
            
<div class="viewcode-block" id="TorchModel.num_ftrs">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.num_ftrs">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ftrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ftrs</span><span class="p">()</span></div>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_spacr_classifier</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>

<div class="viewcode-block" id="TorchModel.apply_dropout_rate">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.apply_dropout_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_dropout_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively set dropout probability for all nn.Dropout layers in the model.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (nn.Module): The model to modify.</span>
<span class="sd">            dropout_rate (float): New dropout probability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">):</span>
                <span class="n">module</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">dropout_rate</span></div>


<div class="viewcode-block" id="TorchModel.init_base_model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.init_base_model">[docs]</a>
    <span class="k">def</span> <span class="nf">init_base_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pretrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the base model from torchvision.models.</span>

<span class="sd">        Args:</span>
<span class="sd">            pretrained (bool): Whether to load pretrained weights.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: The base feature extractor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model_func</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">model_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="si">}</span><span class="s2"> is not recognized.&quot;</span><span class="p">)</span>
        <span class="n">weight_choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_weight_choice</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">weight_choice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">model_func</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weight_choice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">model_func</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="n">pretrained</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.get_weight_choice">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.get_weight_choice">[docs]</a>
    <span class="k">def</span> <span class="nf">get_weight_choice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the default weights enum for the selected model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[torchvision.models.WeightsEnum]: Default weights or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weight_enum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="si">}</span><span class="s2">_weights&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">weight_enum</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">weight_enum</span><span class="o">.</span><span class="n">DEFAULT</span> <span class="k">if</span> <span class="n">weight_enum</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="TorchModel.get_num_ftrs">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.get_num_ftrs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_num_ftrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine output feature dimensionality from the base model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Feature vector size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="s1">&#39;fc&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="s1">&#39;classifier&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">!=</span> <span class="s1">&#39;maxvit_t&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>

        <span class="c1"># Forward a dummy input and check output size</span>
        <span class="n">dummy_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">(</span><span class="n">dummy_input</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.init_spacr_classifier">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.init_spacr_classifier">[docs]</a>
    <span class="k">def</span> <span class="nf">init_spacr_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the final classification layer and optional dropout.</span>

<span class="sd">        Args:</span>
<span class="sd">            dropout_rate (float or None): Dropout probability. If None, dropout is skipped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span> <span class="o">=</span> <span class="n">dropout_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacr_classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ftrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.TorchModel.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass through base model, optional dropout, and final classifier.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input image tensor of shape (N, 3, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output logits of shape (N,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacr_classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">logits</span></div>
</div>


<div class="viewcode-block" id="FocalLossWithLogits">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits">[docs]</a>
<span class="k">class</span> <span class="nc">FocalLossWithLogits</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Focal Loss with logits for binary classification.</span>

<span class="sd">    This loss function is especially useful for addressing class imbalance by focusing more</span>
<span class="sd">    on hard-to-classify examples.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (float): Balancing factor for positive/negative examples. Default is 1.</span>
<span class="sd">        gamma (float): Focusing parameter that down-weights easy examples. Default is 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the focal loss.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): Balancing factor for positive/negative examples. Default is 1.</span>
<span class="sd">            gamma (float): Focusing parameter to down-weight well-classified examples. Default is 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FocalLossWithLogits</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<div class="viewcode-block" id="FocalLossWithLogits.alpha">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.alpha">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span></div>

<div class="viewcode-block" id="FocalLossWithLogits.gamma">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.gamma">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span></div>


<div class="viewcode-block" id="FocalLossWithLogits.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.FocalLossWithLogits.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the focal loss between logits and targets.</span>

<span class="sd">        Args:</span>
<span class="sd">            logits (torch.Tensor): Predicted unnormalized scores (logits).</span>
<span class="sd">            target (torch.Tensor): Ground truth binary labels (same shape as logits).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Scalar focal loss value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BCE_loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">BCE_loss</span><span class="p">)</span>
        <span class="n">focal_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pt</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">BCE_loss</span>
        <span class="k">return</span> <span class="n">focal_loss</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>
</div>

    
<div class="viewcode-block" id="ResNet">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ResNet">[docs]</a>
<span class="k">class</span> <span class="nc">ResNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper around torchvision ResNet models with optional dropout, checkpointing, </span>
<span class="sd">    and a custom classifier head.</span>

<span class="sd">    Supported ResNet variants: resnet18, resnet34, resnet50, resnet101, resnet152.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnet_type</span><span class="o">=</span><span class="s1">&#39;resnet50&#39;</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="s1">&#39;imagenet&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ResNet model wrapper.</span>

<span class="sd">        Args:</span>
<span class="sd">            resnet_type (str): Which ResNet variant to use. Options: &#39;resnet18&#39;, &#39;resnet34&#39;, etc.</span>
<span class="sd">            dropout_rate (float or None): Dropout rate to apply before the final layer.</span>
<span class="sd">            use_checkpoint (bool): Whether to enable gradient checkpointing.</span>
<span class="sd">            init_weights (str): Either &#39;imagenet&#39; to load pretrained weights or &#39;none&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">resnet_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;resnet18&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet18</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet18_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet34&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet34</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet34_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet50&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet50</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet50_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet101&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet101</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet101_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet152&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet152</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet152_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">resnet_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resnet_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid resnet_type. Choose from </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">resnet_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_base</span><span class="p">(</span><span class="n">resnet_map</span><span class="p">[</span><span class="n">resnet_type</span><span class="p">],</span> <span class="n">dropout_rate</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">init_weights</span><span class="p">)</span>

<div class="viewcode-block" id="ResNet.initialize_base">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ResNet.initialize_base">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_model_dict</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">init_weights</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the base model and classifier layers.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_model_dict (dict): Contains model constructor and weight enum.</span>
<span class="sd">            dropout_rate (float or None): Dropout rate to use.</span>
<span class="sd">            use_checkpoint (bool): Whether to use gradient checkpointing.</span>
<span class="sd">            init_weights (str): Weight initialization mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">init_weights</span> <span class="o">==</span> <span class="s1">&#39;imagenet&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span> <span class="o">=</span> <span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">](</span><span class="n">weights</span><span class="o">=</span><span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">init_weights</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span> <span class="o">=</span> <span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">](</span><span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;init_weights should be either &#39;imagenet&#39; or &#39;none&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span> <span class="o">=</span> <span class="n">dropout_rate</span> <span class="o">!=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResNet.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.ResNet.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass through ResNet and classification layers.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (N, 3, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Logits of shape (N,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Ensure that the tensor has requires_grad set to True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># Use checkpointing for just the ResNet part</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">logits</span></div>
</div>


<div class="viewcode-block" id="split_my_dataset">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.split_my_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">split_my_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">split_ratio</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a dataset into training and validation subsets.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (torch.utils.data.Dataset): The dataset to be split.</span>
<span class="sd">        split_ratio (float, optional): The ratio of validation samples to total samples. Defaults to 0.1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the training dataset and validation dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">))</span>
    <span class="n">split_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">split_ratio</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">train_indices</span><span class="p">,</span> <span class="n">val_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">split_idx</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">split_idx</span><span class="p">:]</span>
    <span class="n">train_dataset</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">train_indices</span><span class="p">)</span>
    <span class="n">val_dataset</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">val_dataset</span></div>


<div class="viewcode-block" id="classification_metrics">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.classification_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">classification_metrics</span><span class="p">(</span><span class="n">all_labels</span><span class="p">,</span> <span class="n">prediction_pos_probs</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate classification metrics for binary classification.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - all_labels (list): List of true labels.</span>
<span class="sd">    - prediction_pos_probs (list): List of predicted positive probabilities.</span>
<span class="sd">    - loader_name (str): Name of the data loader.</span>
<span class="sd">    - loss (float): Loss value.</span>
<span class="sd">    - epoch (int): Epoch number.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - data_df (DataFrame): DataFrame containing the calculated metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prediction_pos_probs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_labels (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">) and pred_labels (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">prediction_pos_probs</span><span class="p">)</span><span class="si">}</span><span class="s2">) have different lengths&quot;</span><span class="p">)</span>
    
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pr_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">pr_labels</span><span class="p">,</span> <span class="n">prediction_pos_probs</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pr_auc</span> <span class="o">=</span> <span class="n">auc</span><span class="p">(</span><span class="n">recall</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">f1_scores</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span><span class="p">)</span>
        <span class="n">optimal_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">f1_scores</span><span class="p">)</span>
        <span class="n">optimal_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">optimal_idx</span><span class="p">]</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prediction_pos_probs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">optimal_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">optimal_threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prediction_pos_probs</span><span class="p">]</span>
        <span class="n">pr_auc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">all_labels</span><span class="p">,</span> <span class="s1">&#39;pred&#39;</span><span class="p">:</span> <span class="n">pred_labels</span><span class="p">}</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">pc_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">nc_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
    <span class="n">acc_all</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pc_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">correct_pc</span> <span class="o">=</span> <span class="n">pc_df</span><span class="p">[</span><span class="n">pc_df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pc_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
        <span class="n">acc_pc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct_pc</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pc_df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acc_pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">correct_nc</span> <span class="o">=</span> <span class="n">nc_df</span><span class="p">[</span><span class="n">nc_df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nc_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
        <span class="n">acc_nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct_nc</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc_df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acc_nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">acc_all</span><span class="p">,</span> <span class="s1">&#39;neg_accuracy&#39;</span><span class="p">:</span> <span class="n">acc_nc</span><span class="p">,</span> <span class="s1">&#39;pos_accuracy&#39;</span><span class="p">:</span> <span class="n">acc_pc</span><span class="p">,</span> <span class="s1">&#39;loss&#39;</span><span class="p">:</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="s1">&#39;prauc&#39;</span><span class="p">:</span><span class="n">pr_auc</span><span class="p">,</span> <span class="s1">&#39;optimal_threshold&#39;</span><span class="p">:</span><span class="n">optimal_threshold</span><span class="p">}</span>
    <span class="n">data_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)])</span> 
    <span class="k">return</span> <span class="n">data_df</span></div>

    
<div class="viewcode-block" id="compute_irm_penalty">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.compute_irm_penalty">[docs]</a>
<span class="k">def</span> <span class="nf">compute_irm_penalty</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Invariant Risk Minimization (IRM) penalty.</span>

<span class="sd">    Args:</span>
<span class="sd">        losses (list): A list of losses.</span>
<span class="sd">        dummy_w (torch.Tensor): A dummy weight tensor.</span>
<span class="sd">        device (torch.device): The device to perform computations on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The computed IRM penalty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weighted_losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">dummy_w</span> <span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">losses</span><span class="p">]</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="p">[</span><span class="n">grad</span><span class="p">(</span><span class="n">w_loss</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w_loss</span> <span class="ow">in</span> <span class="n">weighted_losses</span><span class="p">]</span>
    <span class="n">irm_penalty</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">irm_penalty</span> <span class="o">+=</span> <span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">irm_penalty</span></div>


<span class="c1">#def print_model_summary(base_model, channels, height, width):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Prints the summary of a given base model.</span>
<span class="c1">#</span>
<span class="c1">#    Args:</span>
<span class="c1">#        base_model (torch.nn.Module): The base model to print the summary of.</span>
<span class="c1">#        channels (int): The number of input channels.</span>
<span class="c1">#        height (int): The height of the input.</span>
<span class="c1">#        width (int): The width of the input.</span>
<span class="c1">#</span>
<span class="c1">#    Returns:</span>
<span class="c1">#        None</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span>
<span class="c1">#    base_model.to(device)</span>
<span class="c1">#    summary(base_model, (channels, height, width))</span>
<span class="c1">#    return</span>

<div class="viewcode-block" id="choose_model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.choose_model">[docs]</a>
<span class="k">def</span> <span class="nf">choose_model</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">chan_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a model for classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_type (str): The type of model to choose. Can be one of the pre-defined TorchVision models or &#39;custom&#39; for a custom model.</span>
<span class="sd">        device (str): The device to use for model inference.</span>
<span class="sd">        init_weights (bool, optional): Whether to initialize the model with pre-trained weights. Defaults to True.</span>
<span class="sd">        dropout_rate (float, optional): The dropout rate to use in the model. Defaults to 0.</span>
<span class="sd">        use_checkpoint (bool, optional): Whether to use checkpointing during model training. Defaults to False.</span>
<span class="sd">        channels (int, optional): The number of input channels for the model. Defaults to 3.</span>
<span class="sd">        height (int, optional): The height of the input images for the model. Defaults to 224.</span>
<span class="sd">        width (int, optional): The width of the input images for the model. Defaults to 224.</span>
<span class="sd">        chan_dict (dict, optional): A dictionary containing channel information for custom models. Defaults to None.</span>
<span class="sd">        num_classes (int, optional): The number of output classes for the model. Defaults to 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.nn.Module: The chosen model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">torch_model_types</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">list_models</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="p">)</span>
    <span class="n">model_types</span> <span class="o">=</span> <span class="n">torch_model_types</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;custom&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chan_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pathogen_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;pathogen_channel&#39;</span><span class="p">]</span>
        <span class="n">nucleus_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;nucleus_channel&#39;</span><span class="p">]</span>
        <span class="n">protein_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;protein_channel&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_types</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid model_type: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1">. Compatible model_types: </span><span class="si">{</span><span class="n">model_types</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Model parameters: Architecture: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1"> init_weights: </span><span class="si">{</span><span class="n">init_weights</span><span class="si">}</span><span class="s1"> dropout_rate: </span><span class="si">{</span><span class="n">dropout_rate</span><span class="si">}</span><span class="s1"> use_checkpoint: </span><span class="si">{</span><span class="n">use_checkpoint</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
        
        <span class="n">base_model</span> <span class="o">=</span> <span class="n">CustomCellClassifier</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="o">=</span><span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">use_attention</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="n">dropout_rate</span><span class="p">)</span>
        <span class="c1">#base_model = CustomCellClassifier(num_classes=2, pathogen_channel=pathogen_channel, nucleus_channel=nucleus_channel, protein_channel=protein_channel, dropout_rate=dropout_rate, use_checkpoint=use_checkpoint)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="ow">in</span> <span class="n">torch_model_types</span><span class="p">:</span>
        <span class="n">base_model</span> <span class="o">=</span> <span class="n">TorchModel</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="n">model_type</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="n">init_weights</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="n">dropout_rate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Compatible model_types: </span><span class="si">{</span><span class="n">model_types</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid model_type: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">base_model</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">base_model</span></div>


<div class="viewcode-block" id="calculate_loss">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.calculate_loss">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">loss_type</span><span class="o">=</span><span class="s1">&#39;binary_cross_entropy_with_logits&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the loss between the model output and the target based on the specified loss type.</span>

<span class="sd">    Args:</span>
<span class="sd">        output (Tensor): The predicted output from the model.</span>
<span class="sd">        target (Tensor): The ground truth target values.</span>
<span class="sd">        loss_type (str, optional): The type of loss function to use. </span>
<span class="sd">            Supported values are:</span>
<span class="sd">            - &#39;binary_cross_entropy_with_logits&#39;: Uses binary cross-entropy loss with logits.</span>
<span class="sd">            - &#39;focal_loss&#39;: Uses focal loss with logits. Defaults to &#39;binary_cross_entropy_with_logits&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: The computed loss value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If an unsupported loss_type is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">loss_type</span> <span class="o">==</span> <span class="s1">&#39;binary_cross_entropy_with_logits&#39;</span><span class="p">:</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">loss_type</span> <span class="o">==</span> <span class="s1">&#39;focal_loss&#39;</span><span class="p">:</span>
        <span class="n">focal_loss_fn</span> <span class="o">=</span> <span class="n">FocalLossWithLogits</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">focal_loss_fn</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span></div>


<div class="viewcode-block" id="pick_best_model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.pick_best_model">[docs]</a>
<span class="k">def</span> <span class="nf">pick_best_model</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the best model file from a given directory based on accuracy and epoch.</span>
<span class="sd">    This function scans the specified directory for files with a `.pth` extension,</span>
<span class="sd">    extracts accuracy and epoch information from their filenames using a predefined</span>
<span class="sd">    pattern, and selects the file with the highest accuracy. If multiple files have</span>
<span class="sd">    the same accuracy, the one with the highest epoch is selected.</span>
<span class="sd">    Args:</span>
<span class="sd">        src (str): The path to the directory containing the model files.</span>
<span class="sd">    Returns:</span>
<span class="sd">        str: The full path to the best model file based on accuracy and epoch.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The filenames are expected to follow the pattern `_epoch_&lt;epoch&gt;_acc_&lt;accuracy&gt;.pth`,</span>
<span class="sd">          where `&lt;epoch&gt;` is an integer and `&lt;accuracy&gt;` is a float.</span>
<span class="sd">        - If no files match the pattern, the function may raise an IndexError when</span>
<span class="sd">          attempting to access the first element of the sorted list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="n">pth_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_files</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pth&#39;</span><span class="p">)]</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_epoch_(\d+)_acc_(\d+(?:\.\d+)?)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make the primary sorting key float for consistency</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">g2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>  <span class="c1"># Primary sort by accuracy (g2) and secondary sort by epoch (g1)</span>
    
    <span class="n">sorted_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pth_files</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">best_model</span> <span class="o">=</span> <span class="n">sorted_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">best_model</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_paths_from_db">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_paths_from_db">[docs]</a>
<span class="k">def</span> <span class="nf">get_paths_from_db</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">png_df</span><span class="p">,</span> <span class="n">image_type</span><span class="o">=</span><span class="s1">&#39;cell_png&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters and retrieves paths from a DataFrame based on specified criteria.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): A DataFrame whose index contains the objects of interest.</span>
<span class="sd">        png_df (pd.DataFrame): A DataFrame containing a &#39;png_path&#39; column and a &#39;prcfo&#39; column.</span>
<span class="sd">        image_type (str, optional): A string to filter the &#39;png_path&#39; column. Defaults to &#39;cell_png&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A filtered DataFrame containing rows from `png_df` where the &#39;png_path&#39; </span>
<span class="sd">                      column contains the `image_type` string and the &#39;prcfo&#39; column matches </span>
<span class="sd">                      the index of `df`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">image_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">objects</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">filtered_df</span></div>


<div class="viewcode-block" id="save_file_lists">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.save_file_lists">[docs]</a>
<span class="k">def</span> <span class="nf">save_file_lists</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">data_set</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a list of file paths or data entries to a CSV file.</span>

<span class="sd">    Args:</span>
<span class="sd">        dst (str): The destination directory where the CSV file will be saved.</span>
<span class="sd">        data_set (str): The name of the dataset, which will also be used as the column name in the CSV file and the filename.</span>
<span class="sd">        ls (list): A list of file paths or data entries to be saved.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">data_set</span><span class="p">])</span>  
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dst</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">data_set</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="augment_single_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.augment_single_image">[docs]</a>
<span class="k">def</span> <span class="nf">augment_single_image</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augment a single image by applying various transformations and saving the results.</span>

<span class="sd">    This function reads an image from the specified file path, applies a series of </span>
<span class="sd">    transformations (original, rotations, and flips), and saves the transformed images </span>
<span class="sd">    to the destination directory with appropriate filenames.</span>

<span class="sd">    Args:</span>
<span class="sd">        args (tuple): A tuple containing:</span>
<span class="sd">            img_path (str): The file path to the input image.</span>
<span class="sd">            dst (str): The destination directory where the augmented images will be saved.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The following transformations are applied to the input image:</span>
<span class="sd">        - Original image (no transformation)</span>
<span class="sd">        - 90-degree clockwise rotation</span>
<span class="sd">        - 180-degree rotation</span>
<span class="sd">        - 270-degree clockwise rotation</span>
<span class="sd">        - Horizontal flip</span>
<span class="sd">        - Vertical flip</span>

<span class="sd">    Side Effects:</span>
<span class="sd">        Saves the augmented images to the specified destination directory.</span>
<span class="sd">        Filenames indicate the type of transformation applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_path</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_UNCHANGED</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Original Image</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_original.png&quot;</span><span class="p">),</span> <span class="n">img</span><span class="p">)</span>
    
    <span class="c1"># 90 degree rotation</span>
    <span class="n">img_rot_90</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_CLOCKWISE</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_90.png&quot;</span><span class="p">),</span> <span class="n">img_rot_90</span><span class="p">)</span>
    
    <span class="c1"># 180 degree rotation</span>
    <span class="n">img_rot_180</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_180</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_180.png&quot;</span><span class="p">),</span> <span class="n">img_rot_180</span><span class="p">)</span>

    <span class="c1"># 270 degree rotation</span>
    <span class="n">img_rot_270</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_COUNTERCLOCKWISE</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_270.png&quot;</span><span class="p">),</span> <span class="n">img_rot_270</span><span class="p">)</span>

    <span class="c1"># Horizontal Flip</span>
    <span class="n">img_flip_hor</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_flip_hor.png&quot;</span><span class="p">),</span> <span class="n">img_flip_hor</span><span class="p">)</span>

    <span class="c1"># Vertical Flip</span>
    <span class="n">img_flip_ver</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_flip_ver.png&quot;</span><span class="p">),</span> <span class="n">img_flip_ver</span><span class="p">)</span></div>


<div class="viewcode-block" id="augment_images">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.augment_images">[docs]</a>
<span class="k">def</span> <span class="nf">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augments a list of images and saves the augmented images to the specified destination directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_paths (list of str): A list of file paths to the images to be augmented.</span>
<span class="sd">        dst (str): The destination directory where the augmented images will be saved. </span>
<span class="sd">                   If the directory does not exist, it will be created.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="n">args_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">for</span> <span class="n">img_path</span> <span class="ow">in</span> <span class="n">file_paths</span><span class="p">]</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">augment_single_image</span><span class="p">,</span> <span class="n">args_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="augment_classes">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.augment_classes">[docs]</a>
<span class="k">def</span> <span class="nf">augment_classes</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">generate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">move</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">augment_classes</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">generate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augments and organizes image datasets into training and testing directories.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        dst : str</span>
<span class="sd">            The destination directory where augmented data will be stored.</span>
<span class="sd">        nc : list</span>
<span class="sd">            List of file paths for the &quot;negative class&quot; images to be augmented.</span>
<span class="sd">        pc : list</span>
<span class="sd">            List of file paths for the &quot;positive class&quot; images to be augmented.</span>
<span class="sd">        generate : bool, optional</span>
<span class="sd">            If True, generates augmented images for both classes and saves them in </span>
<span class="sd">            separate directories (`aug_nc` for negative class and `aug_pc` for positive class).</span>
<span class="sd">            Default is True.</span>
<span class="sd">        move : bool, optional</span>
<span class="sd">            If True, splits the augmented images into training and testing datasets, </span>
<span class="sd">            and organizes them into subdirectories under `aug/train` and `aug/test`.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        None</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">        - The function uses `train_test_split` to split the augmented images into </span>
<span class="sd">          training (90%) and testing (10%) datasets.</span>
<span class="sd">        - The progress of moving files is displayed in the console.</span>
<span class="sd">        - The final counts of training and testing images for each class are printed.</span>

<span class="sd">        Example Directory Structure:</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        After execution, the directory structure will look like this:</span>
<span class="sd">        dst/</span>
<span class="sd">        ├── aug_nc/       # Augmented negative class images</span>
<span class="sd">        ├── aug_pc/       # Augmented positive class images</span>
<span class="sd">        ├── aug/</span>
<span class="sd">            ├── train/</span>
<span class="sd">                ├── nc/  # Training negative class images</span>
<span class="sd">                ├── pc/  # Training positive class images</span>
<span class="sd">            ├── test/</span>
<span class="sd">                ├── nc/  # Testing negative class images</span>
<span class="sd">                ├── pc/  # Testing positive class images</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">aug_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug_nc&#39;</span><span class="p">)</span>
    <span class="n">aug_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug_pc&#39;</span><span class="p">)</span>
    <span class="n">all_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">generate</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
            <span class="n">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="o">=</span><span class="n">nc</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">aug_nc</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
            <span class="n">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="o">=</span><span class="n">pc</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">aug_pc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">move</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug&#39;</span><span class="p">)</span>
        <span class="n">aug_train_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;train/nc&#39;</span><span class="p">)</span>
        <span class="n">aug_train_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;train/pc&#39;</span><span class="p">)</span>
        <span class="n">aug_test_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;test/nc&#39;</span><span class="p">)</span>
        <span class="n">aug_test_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;test/pc&#39;</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">aug_nc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">)]</span>
        <span class="n">aug_pc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">)]</span>

        <span class="n">nc_train_data</span><span class="p">,</span> <span class="n">nc_test_data</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">aug_nc_list</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">pc_train_data</span><span class="p">,</span> <span class="n">pc_test_data</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">aug_pc_list</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">nc_train_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">nc_test_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pc_train_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pc_test_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Train nc: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Train pc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Test nc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Test pc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="annotate_predictions">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.annotate_predictions">[docs]</a>
<span class="k">def</span> <span class="nf">annotate_predictions</span><span class="p">(</span><span class="n">csv_loc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a CSV file containing image metadata, processes the data to extract</span>
<span class="sd">    additional information, and assigns a condition label to each row based on</span>
<span class="sd">    specific rules.</span>
<span class="sd">    Args:</span>
<span class="sd">        csv_loc (str): The file path to the CSV file containing the metadata.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame with the following additional columns:</span>
<span class="sd">            - &#39;filename&#39;: Extracted filename from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;plateID&#39;: Plate ID extracted from the filename.</span>
<span class="sd">            - &#39;well&#39;: Well information extracted from the filename.</span>
<span class="sd">            - &#39;fieldID&#39;: Field ID extracted from the filename.</span>
<span class="sd">            - &#39;object&#39;: Object ID extracted from the filename (with &#39;.png&#39; removed).</span>
<span class="sd">            - &#39;cond&#39;: Assigned condition label (&#39;screen&#39;, &#39;pc&#39;, &#39;nc&#39;, or &#39;&#39;) based on rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_loc</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">assign_condition</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">])</span>
        <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;well&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plate</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;screen&#39;</span>
            <span class="k">elif</span> <span class="n">plate</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;pc&#39;</span>
        <span class="k">elif</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;nc&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cond&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">assign_condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="initiate_counter">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.initiate_counter">[docs]</a>
<span class="k">def</span> <span class="nf">initiate_counter</span><span class="p">(</span><span class="n">counter_</span><span class="p">,</span> <span class="n">lock_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes global variables `counter` and `lock` with the provided arguments.</span>

<span class="sd">    This function sets the global variables `counter` and `lock` to the values</span>
<span class="sd">    passed as `counter_` and `lock_`, respectively. It is typically used to</span>
<span class="sd">    share a counter and a lock object across multiple threads or processes.</span>

<span class="sd">    Args:</span>
<span class="sd">        counter_ (Any): The counter object to be assigned to the global `counter`.</span>
<span class="sd">        lock_ (Any): The lock object to be assigned to the global `lock`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">counter</span><span class="p">,</span> <span class="n">lock</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">counter_</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">lock_</span></div>


<div class="viewcode-block" id="add_images_to_tar">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.add_images_to_tar">[docs]</a>
<span class="k">def</span> <span class="nf">add_images_to_tar</span><span class="p">(</span><span class="n">paths_chunk</span><span class="p">,</span> <span class="n">tar_path</span><span class="p">,</span> <span class="n">total_images</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a chunk of image files to a tar archive.</span>

<span class="sd">    Args:</span>
<span class="sd">        paths_chunk (list of str): A list of file paths to the images to be added to the tar archive.</span>
<span class="sd">        tar_path (str): The path where the tar archive will be created or overwritten.</span>
<span class="sd">        total_images (int): The total number of images being processed, used for progress tracking.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - Opens a tar archive at the specified `tar_path` in write mode.</span>
<span class="sd">        - Iterates through the provided `paths_chunk` and adds each image to the tar archive.</span>
<span class="sd">        - Tracks progress using a shared counter and prints progress updates every 10 images.</span>
<span class="sd">        - Handles missing files gracefully by printing a warning message if a file is not found.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - This function assumes the existence of a global `lock` object for thread-safe counter updates.</span>
<span class="sd">        - The `counter` object is expected to be a shared multiprocessing.Value or similar.</span>
<span class="sd">        - The `print_progress` function is used to display progress updates.</span>

<span class="sd">    Exceptions:</span>
<span class="sd">        - Prints a warning message if a file in `paths_chunk` is not found, but continues processing other files.</span>

<span class="sd">    Example:</span>
<span class="sd">        add_images_to_tar([&#39;/path/to/image1.jpg&#39;, &#39;/path/to/image2.jpg&#39;], &#39;/path/to/archive.tar&#39;, 100)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">tar_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths_chunk</span><span class="p">):</span>
            <span class="n">arcname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">arcname</span><span class="o">=</span><span class="n">arcname</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                    <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Print every 100 updates</span>
                        <span class="c1">#progress = (counter.value / total_images) * 100</span>
                        <span class="c1">#print(f&quot;Progress: {counter.value}/{total_images} ({progress:.2f}%)&quot;, end=&#39;\r&#39;, file=sys.stdout, flush=True)</span>
                        <span class="n">print_progress</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">total_images</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="s2">&quot;generating .tar dataset&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File not found: </span><span class="si">{</span><span class="n">img_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_fraction_map">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.generate_fraction_map">[docs]</a>
<span class="k">def</span> <span class="nf">generate_fraction_map</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">gene_column</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a fraction map from a given DataFrame and writes it to a CSV file.</span>

<span class="sd">    This function calculates the fraction of counts for each gene and well, </span>
<span class="sd">    organizes the data into a pivot table-like structure, and filters out </span>
<span class="sd">    columns based on a minimum frequency threshold. The resulting DataFrame </span>
<span class="sd">    is saved as a CSV file.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): Input DataFrame containing the data. It must include </span>
<span class="sd">            the columns &#39;count&#39;, &#39;well_read_sum&#39;, &#39;prc&#39;, and the specified </span>
<span class="sd">            `gene_column`.</span>
<span class="sd">        gene_column (str): The name of the column in `df` that contains gene </span>
<span class="sd">            identifiers.</span>
<span class="sd">        min_frequency (float, optional): The minimum frequency threshold for </span>
<span class="sd">            filtering columns. Columns with a maximum value below this </span>
<span class="sd">            threshold are dropped. Defaults to 0.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame containing the fraction map, with wells as </span>
<span class="sd">        rows and genes as columns. Cells contain the fraction values, and </span>
<span class="sd">        missing values are filled with 0.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;well_read_sum&#39;</span><span class="p">]</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">gene_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">wells</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">))</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">genes</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">wells</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span>
        <span class="n">gene</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">gene_column</span><span class="p">]</span>
        <span class="n">fraction</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;fraction&#39;</span><span class="p">]</span>
        <span class="n">independent_variables</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">prc</span><span class="p">,</span><span class="n">gene</span><span class="p">]</span><span class="o">=</span><span class="n">fraction</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">independent_variables</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">#sums = independent_variables[&#39;sum&#39;].unique().tolist()</span>
    <span class="c1">#print(sums)</span>
    <span class="c1">#independent_variables = independent_variables[(independent_variables[&#39;sum&#39;] == 0.0) | (independent_variables[&#39;sum&#39;] == 1.0)]</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">independent_variables</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frequency</span><span class="p">])</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">independent_variables</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;prc&#39;</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="s1">&#39;/mnt/data/CellVoyager/20x/tsg101/crispr_screen/all/measurements/iv.csv&#39;</span>
    <span class="n">independent_variables</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">independent_variables</span></div>


<div class="viewcode-block" id="fishers_odds">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.fishers_odds">[docs]</a>
<span class="k">def</span> <span class="nf">fishers_odds</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">phenotyp_col</span><span class="o">=</span><span class="s1">&#39;mean_pred&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Fisher&#39;s exact test to evaluate the association between mutants and a binned phenotype score.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): DataFrame containing binary mutant indicators and a phenotype score column.</span>
<span class="sd">        threshold (float, optional): Threshold to bin the phenotype score. Defaults to 0.5.</span>
<span class="sd">        phenotyp_col (str, optional): Name of the column containing phenotype scores. Defaults to &#39;mean_pred&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: DataFrame with columns &#39;Mutant&#39;, &#39;OddsRatio&#39;, &#39;PValue&#39;, and &#39;AdjustedPValue&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Binning based on phenotype score (e.g., above 0.8 as high)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;high_phenotype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">phenotyp_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mutants</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mutants</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">mutants</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;count_prc&#39;</span><span class="p">,</span><span class="s1">&#39;mean_pathogen_area&#39;</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fishers df&#39;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="c1"># Perform Fisher&#39;s exact test for each mutant</span>
    <span class="k">for</span> <span class="n">mutant</span> <span class="ow">in</span> <span class="n">mutants</span><span class="p">:</span>
        <span class="n">contingency_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">crosstab</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">mutant</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;high_phenotype&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">contingency_table</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Check for 2x2 shape</span>
            <span class="n">odds_ratio</span><span class="p">,</span> <span class="n">p_value</span> <span class="o">=</span> <span class="n">fisher_exact</span><span class="p">(</span><span class="n">contingency_table</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mutant</span><span class="p">,</span> <span class="n">odds_ratio</span><span class="p">,</span> <span class="n">p_value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Optionally handle non-2x2 tables (e.g., append NaN or other placeholders)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mutant</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)))</span>
    
    <span class="c1"># Convert results to DataFrame for easier handling</span>
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Mutant&#39;</span><span class="p">,</span> <span class="s1">&#39;OddsRatio&#39;</span><span class="p">,</span> <span class="s1">&#39;PValue&#39;</span><span class="p">])</span>
    <span class="c1"># Remove rows with undefined odds ratios or p-values</span>
    <span class="n">filtered_results_df</span> <span class="o">=</span> <span class="n">results_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;OddsRatio&#39;</span><span class="p">,</span> <span class="s1">&#39;PValue&#39;</span><span class="p">])</span>
    
    <span class="n">pvalues</span> <span class="o">=</span> <span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;PValue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Check if pvalues array is empty</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvalues</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Apply Benjamini-Hochberg correction</span>
        <span class="n">adjusted_pvalues</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fdr_bh&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Add adjusted p-values back to the dataframe</span>
        <span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;AdjustedPValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_pvalues</span>
        <span class="c1"># Filter significant results</span>
        <span class="n">significant_mutants</span> <span class="o">=</span> <span class="n">filtered_results_df</span><span class="p">[</span><span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;AdjustedPValue&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No p-values to adjust. Check your data filtering steps.&quot;</span><span class="p">)</span>
        <span class="n">significant_mutants</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># return empty DataFrame in this case</span>
    
    <span class="k">return</span> <span class="n">filtered_results_df</span></div>


<div class="viewcode-block" id="model_metrics">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.model_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate and display additional metrics and generate diagnostic plots for a given model.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    model : statsmodels.regression.linear_model.RegressionResultsWrapper</span>
<span class="sd">        A fitted regression model object from the statsmodels library.</span>

<span class="sd">    Metrics Calculated:</span>
<span class="sd">    --------------------</span>
<span class="sd">    - Root Mean Squared Error (RMSE): Measures the standard deviation of residuals.</span>
<span class="sd">    - Mean Absolute Error (MAE): Measures the average magnitude of residuals.</span>
<span class="sd">    - Durbin-Watson: Tests for the presence of autocorrelation in residuals.</span>

<span class="sd">    Diagnostic Plots:</span>
<span class="sd">    ------------------</span>
<span class="sd">    1. Residuals vs. Fitted: Scatter plot to check for non-linearity or unequal error variance.</span>
<span class="sd">    2. Histogram of Residuals: Distribution of residuals to check for normality.</span>
<span class="sd">    3. QQ Plot: Quantile-Quantile plot to assess if residuals follow a normal distribution.</span>
<span class="sd">    4. Scale-Location: Scatter plot of standardized residuals to check for homoscedasticity.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - This function uses matplotlib and seaborn for plotting.</span>
<span class="sd">    - Ensure that the input model is fitted and contains the necessary attributes like `resid`, </span>
<span class="sd">      `fittedvalues`, and `mse_resid`.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Calculate additional metrics</span>
    <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">mse_resid</span><span class="p">)</span>
    <span class="n">mae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">durbin_w_value</span> <span class="o">=</span> <span class="n">durbin_watson</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>

    <span class="c1"># Display the additional metrics</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Additional Metrics:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Root Mean Squared Error (RMSE): </span><span class="si">{</span><span class="n">rmse</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean Absolute Error (MAE): </span><span class="si">{</span><span class="n">mae</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Durbin-Watson: </span><span class="si">{</span><span class="n">durbin_w_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Residual Plots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

    <span class="c1"># Residual vs. Fitted</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">facecolors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Residuals vs Fitted&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Fitted values&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Residuals&#39;</span><span class="p">)</span>

    <span class="c1"># Histogram</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Histogram of Residuals&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Residuals&#39;</span><span class="p">)</span>

    <span class="c1"># QQ Plot</span>
    <span class="n">sm</span><span class="o">.</span><span class="n">qqplot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s1">&#39;45&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;QQ Plot&#39;</span><span class="p">)</span>

    <span class="c1"># Scale-Location</span>
    <span class="n">standardized_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">resid_studentized_internal</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">standardized_resid</span><span class="p">)),</span> <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">facecolors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Scale-Location&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Fitted values&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\sqrt{|Standardized Residuals|}$&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="check_multicollinearity">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.check_multicollinearity">[docs]</a>
<span class="k">def</span> <span class="nf">check_multicollinearity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks multicollinearity of the predictors by computing the Variance Inflation Factor (VIF).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x (pd.DataFrame): A DataFrame containing the predictor variables.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with two columns:</span>
<span class="sd">            - &#39;Variable&#39;: The names of the predictor variables.</span>
<span class="sd">            - &#39;VIF&#39;: The Variance Inflation Factor for each predictor variable.</span>
<span class="sd">              A VIF value greater than 10 indicates high multicollinearity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks multicollinearity of the predictors by computing the VIF.&quot;&quot;&quot;</span>
    <span class="n">vif_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">vif_data</span><span class="p">[</span><span class="s2">&quot;Variable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">vif_data</span><span class="p">[</span><span class="s2">&quot;VIF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">variance_inflation_factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">return</span> <span class="n">vif_data</span></div>


<div class="viewcode-block" id="lasso_reg">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.lasso_reg">[docs]</a>
<span class="k">def</span> <span class="nf">lasso_reg</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">alpha_value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;lasso&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Lasso or Ridge regression on the input DataFrame.</span>

<span class="sd">    Args:</span>
<span class="sd">        merged_df (pandas.DataFrame): DataFrame with columns &#39;gene&#39;, &#39;grna&#39;, &#39;plateID&#39;, &#39;rowID&#39;, &#39;columnID&#39;, and &#39;pred&#39;.</span>
<span class="sd">        alpha_value (float, optional): Regularization strength. Defaults to 0.01.</span>
<span class="sd">        reg_type (str, optional): Type of regression to perform, either &#39;lasso&#39; or &#39;ridge&#39;. Defaults to &#39;lasso&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: DataFrame with &#39;Feature&#39; and &#39;Coefficient&#39; columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Separate predictors and response</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;grna&#39;</span><span class="p">,</span> <span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">,</span> <span class="s1">&#39;columnID&#39;</span><span class="p">]]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]</span>

    <span class="c1"># One-hot encode the categorical predictors</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>  <span class="c1"># drop one category to avoid the dummy variable trap</span>
    <span class="n">X_encoded</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">feature_names</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">(</span><span class="n">input_features</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s1">&#39;ridge&#39;</span><span class="p">:</span>
        <span class="c1"># Fit ridge regression</span>
        <span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha_value</span><span class="p">)</span>
        <span class="n">ridge</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_encoded</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">ridge</span><span class="o">.</span><span class="n">coef_</span>
        <span class="n">coeff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">ridge</span><span class="o">.</span><span class="n">coef_</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s1">&#39;lasso&#39;</span><span class="p">:</span>
        <span class="c1"># Fit Lasso regression</span>
        <span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha_value</span><span class="p">)</span>
        <span class="n">lasso</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_encoded</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">lasso</span><span class="o">.</span><span class="n">coef_</span>
        <span class="n">coeff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">lasso</span><span class="o">.</span><span class="n">coef_</span><span class="p">))</span>
    <span class="n">coeff_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coeff_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;Coefficient&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">coeff_df</span></div>


<div class="viewcode-block" id="MLR">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.MLR">[docs]</a>
<span class="k">def</span> <span class="nf">MLR</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">refine_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform multiple linear regression (MLR) and extract interaction coefficients.</span>

<span class="sd">    Args:</span>
<span class="sd">        merged_df (pd.DataFrame): Input DataFrame with data for regression analysis.</span>
<span class="sd">        refine_model (bool): Whether to remove outliers before refitting the model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: Contains:</span>
<span class="sd">            - max_effects (dict): Maximum interaction effect size per gene.</span>
<span class="sd">            - max_effects_pvalues (dict): Corresponding p-values.</span>
<span class="sd">            - model (statsmodels.regression.linear_model.RegressionResultsWrapper): Fitted regression model.</span>
<span class="sd">            - df (pd.DataFrame): DataFrame with sorted interaction effects and p-values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">_reg_v_plot</span>
    
    <span class="c1">#model = smf.ols(&quot;pred ~ gene + grna + gene:grna + plate + row + column&quot;, merged_df).fit()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="s2">&quot;pred ~ gene:grna + plate + row + column&quot;</span><span class="p">,</span> <span class="n">merged_df</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="c1"># Display model metrics and summary</span>
    <span class="n">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">refine_model</span><span class="p">:</span>
        <span class="c1"># Filter outliers</span>
        <span class="n">std_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">resid_studentized_internal</span>
        <span class="n">outliers_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">std_resid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">cooks_distance</span>
        <span class="n">outliers_cooks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_df</span><span class="p">)</span><span class="o">-</span><span class="n">merged_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">,</span> <span class="p">(</span><span class="n">outliers_resid</span><span class="p">,</span> <span class="n">outliers_cooks</span><span class="p">))</span>
        <span class="n">merged_df_filtered</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">outliers</span><span class="p">])</span>

        <span class="n">display</span><span class="p">(</span><span class="n">merged_df_filtered</span><span class="p">)</span>

        <span class="c1"># Refit the model with filtered data</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="s2">&quot;pred ~ gene + grna + gene:grna + row + column&quot;</span><span class="p">,</span> <span class="n">merged_df_filtered</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of outliers detected by standardized residuals:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers_resid</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of outliers detected by Cook&#39;s distance:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers_cooks</span><span class="p">))</span>

        <span class="n">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="c1"># Extract interaction coefficients and determine the maximum effect size</span>
    <span class="n">interaction_coeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;gene[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="s2">&quot;:grna[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>
    <span class="n">interaction_pvalues</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">pvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;gene[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="s2">&quot;:grna[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>

    <span class="n">max_effects</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_effects_pvalues</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">interaction_coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gene_name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;gene[T.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gene_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">max_effects</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">max_effects</span><span class="p">[</span><span class="n">gene_name</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">max_effects</span><span class="p">[</span><span class="n">gene_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">max_effects_pvalues</span><span class="p">[</span><span class="n">gene_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_pvalues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">max_effects</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">max_effects</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">, p:</span><span class="si">{</span><span class="n">max_effects_pvalues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">max_effects</span><span class="p">,</span> <span class="n">max_effects_pvalues</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s1">&#39;effect&#39;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="s1">&#39;p&#39;</span><span class="p">})</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;effect&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>

    <span class="n">_reg_v_plot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">max_effects</span><span class="p">,</span> <span class="n">max_effects_pvalues</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_files_from_dir">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_files_from_dir">[docs]</a>
<span class="k">def</span> <span class="nf">get_files_from_dir</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">file_extension</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves a list of files from the specified directory that match the given file extension.</span>

<span class="sd">    Args:</span>
<span class="sd">        dir_path (str): The path to the directory from which to retrieve files.</span>
<span class="sd">        file_extension (str, optional): The file extension to filter files by. Defaults to &quot;*&quot; </span>
<span class="sd">                                         (matches all files).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of file paths matching the specified file extension in the given directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">file_extension</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="create_circular_mask">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.create_circular_mask">[docs]</a>
<span class="k">def</span> <span class="nf">create_circular_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a circular mask for a 2D array with the specified dimensions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        h (int): The height of the 2D array.</span>
<span class="sd">        w (int): The width of the 2D array.</span>
<span class="sd">        center (tuple, optional): The (x, y) coordinates of the circle&#39;s center. </span>
<span class="sd">                                  Defaults to the center of the array.</span>
<span class="sd">        radius (int, optional): The radius of the circle. Defaults to the smallest </span>
<span class="sd">                                distance from the center to the array&#39;s edges.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A boolean 2D array where `True` represents the pixels </span>
<span class="sd">                       inside the circle and `False` represents the pixels outside.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the middle of the image</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the smallest distance between the center and image walls</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">w</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">h</span><span class="p">,</span> <span class="p">:</span><span class="n">w</span><span class="p">]</span>
    <span class="n">dist_from_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">dist_from_center</span> <span class="o">&lt;=</span> <span class="n">radius</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="apply_mask">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.apply_mask">[docs]</a>
<span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">output_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a circular mask to an image, setting pixels outside the mask to a specified value.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (np.ndarray): Input image (2D grayscale or 3D RGB array).</span>
<span class="sd">        output_value (int, optional): Value for pixels outside the mask. Defaults to 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Image with circular mask applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Assuming image is grayscale or RGB</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">create_circular_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    
    <span class="c1"># If the image has more than one channel, repeat the mask for each channel</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Apply the mask - set pixels outside of the mask to output_value</span>
    <span class="n">masked_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">output_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_image</span></div>

    
<div class="viewcode-block" id="invert_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.invert_image">[docs]</a>
<span class="k">def</span> <span class="nf">invert_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts the pixel values of an image.</span>

<span class="sd">    The function calculates the inverted image by subtracting each pixel value </span>
<span class="sd">    from the maximum possible value for the image&#39;s data type. For example, </span>
<span class="sd">    for an image with dtype `uint8`, the maximum value is 255.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image (numpy.ndarray): The input image to be inverted. The image should </span>
<span class="sd">        be a NumPy array with a valid integer data type (e.g., uint8, uint16).</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The inverted image, with the same shape and dtype as the input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The maximum value depends on the image dtype (e.g., 255 for uint8)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">inverted_image</span> <span class="o">=</span> <span class="n">max_value</span> <span class="o">-</span> <span class="n">image</span>
    <span class="k">return</span> <span class="n">inverted_image</span>  </div>


<div class="viewcode-block" id="resize_images_and_labels">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.resize_images_and_labels">[docs]</a>
<span class="k">def</span> <span class="nf">resize_images_and_labels</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">show_example</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize images and labels to the specified target dimensions.</span>
<span class="sd">    This function resizes a list of images and their corresponding labels to the </span>
<span class="sd">    specified target height and width. It supports both 2D and 3D images. Optionally, </span>
<span class="sd">    it can display an example of the resizing process.</span>
<span class="sd">    Args:</span>
<span class="sd">        images (list or None): A list of images to be resized. Each image can be a </span>
<span class="sd">            2D or 3D numpy array. If None, only labels will be resized.</span>
<span class="sd">        labels (list or None): A list of labels to be resized. Each label should be </span>
<span class="sd">            a 2D numpy array. If None, only images will be resized.</span>
<span class="sd">        target_height (int): The target height for resizing.</span>
<span class="sd">        target_width (int): The target width for resizing.</span>
<span class="sd">        show_example (bool, optional): Whether to display an example of the resizing </span>
<span class="sd">            process. Defaults to True.</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two lists:</span>
<span class="sd">            - resized_images (list): A list of resized images. If `images` is None, </span>
<span class="sd">              this will be an empty list.</span>
<span class="sd">            - resized_labels (list): A list of resized labels. If `labels` is None, </span>
<span class="sd">              this will be an empty list.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function uses `resizescikit` for resizing images and labels.</span>
<span class="sd">        - For images, anti-aliasing is applied during resizing.</span>
<span class="sd">        - For labels, resizing is performed with `order=0` to preserve label integrity.</span>
<span class="sd">        - If `show_example` is True, the function uses `plot_resize` to visualize </span>
<span class="sd">          the original and resized images/labels.</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both `images` and `labels` are None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">plot_resize</span>
    
    <span class="n">resized_images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">resized_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="n">resized_image</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">resized_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">resized_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
            <span class="n">resized_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
        
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="n">resized_image</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">resized_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">resized_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
            <span class="n">resized_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">show_example</span><span class="p">:</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">resized_labels</span></div>


<div class="viewcode-block" id="resize_labels_back">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.resize_labels_back">[docs]</a>
<span class="k">def</span> <span class="nf">resize_labels_back</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">orig_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize a list of label arrays back to their original dimensions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        labels (list of numpy.ndarray): A list of label arrays to be resized.</span>
<span class="sd">        orig_dims (list of tuple): A list of tuples where each tuple contains </span>
<span class="sd">            two integers representing the original dimensions (width, height) </span>
<span class="sd">            of the corresponding label array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of numpy.ndarray: A list of resized label arrays with dimensions </span>
<span class="sd">        matching the corresponding tuples in `orig_dims`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the length of `labels` and `orig_dims` do not match.</span>
<span class="sd">        ValueError: If any element in `orig_dims` is not a tuple of two integers.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The resizing operation uses nearest-neighbor interpolation (order=0).</span>
<span class="sd">        - The `preserve_range` parameter ensures that the data range of the </span>
<span class="sd">          input is preserved during resizing.</span>
<span class="sd">        - Anti-aliasing is disabled for this operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resized_labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_dims</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of labels and orig_dims must match.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">orig_dims</span><span class="p">):</span>
        <span class="c1"># Ensure dims is a tuple of two integers (width, height)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element in orig_dims must be a tuple of two integers representing the original dimensions (width, height)&quot;</span><span class="p">)</span>

        <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resized_labels</span></div>


<div class="viewcode-block" id="calculate_iou">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.calculate_iou">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_iou</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Intersection over Union (IoU) between two binary masks.</span>

<span class="sd">    The IoU is a measure of the overlap between two binary masks, defined as the </span>
<span class="sd">    ratio of the intersection area to the union area of the masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask1 (numpy.ndarray): The first binary mask. Must be a 2D array.</span>
<span class="sd">        mask2 (numpy.ndarray): The second binary mask. Must be a 2D array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The IoU value, ranging from 0 to 1. Returns 0 if the union of the </span>
<span class="sd">        masks is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">pad_to_same_shape</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">union</span> <span class="k">if</span> <span class="n">union</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>

    
<div class="viewcode-block" id="match_masks">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.match_masks">[docs]</a>
<span class="k">def</span> <span class="nf">match_masks</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches predicted masks to ground truth masks based on Intersection over Union (IoU) threshold.</span>

<span class="sd">    Args:</span>
<span class="sd">        true_masks (list): A list of ground truth masks.</span>
<span class="sd">        pred_masks (list): A list of predicted masks.</span>
<span class="sd">        iou_threshold (float): The IoU threshold for determining a match between a true mask and a predicted mask.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of tuples where each tuple contains a matched pair of (true_mask, pred_mask).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">matched_true_masks_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Use set to store indices of matched true masks</span>

    <span class="k">for</span> <span class="n">pred_mask</span> <span class="ow">in</span> <span class="n">pred_masks</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">true_mask_index</span><span class="p">,</span> <span class="n">true_mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_masks</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">true_mask_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matched_true_masks_indices</span><span class="p">:</span>
                <span class="n">iou</span> <span class="o">=</span> <span class="n">calculate_iou</span><span class="p">(</span><span class="n">true_mask</span><span class="p">,</span> <span class="n">pred_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iou</span> <span class="o">&gt;=</span> <span class="n">iou_threshold</span><span class="p">:</span>
                    <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">true_mask</span><span class="p">,</span> <span class="n">pred_mask</span><span class="p">))</span>
                    <span class="n">matched_true_masks_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">true_mask_index</span><span class="p">)</span>  <span class="c1"># Store the index of the matched true mask</span>
                    <span class="k">break</span>  <span class="c1"># Move on to the next predicted mask</span>
    <span class="k">return</span> <span class="n">matches</span></div>

    
<div class="viewcode-block" id="compute_average_precision">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.compute_average_precision">[docs]</a>
<span class="k">def</span> <span class="nf">compute_average_precision</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">num_true_masks</span><span class="p">,</span> <span class="n">num_pred_masks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the precision and recall based on the provided matches, number of true masks, </span>
<span class="sd">    and number of predicted masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        matches (list): A list of matched predictions to ground truth masks.</span>
<span class="sd">        num_true_masks (int): The total number of ground truth masks.</span>
<span class="sd">        num_pred_masks (int): The total number of predicted masks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - precision (float): The precision value, calculated as TP / (TP + FP).</span>
<span class="sd">            - recall (float): The recall value, calculated as TP / (TP + FN).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TP</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
    <span class="n">FP</span> <span class="o">=</span> <span class="n">num_pred_masks</span> <span class="o">-</span> <span class="n">TP</span>
    <span class="n">FN</span> <span class="o">=</span> <span class="n">num_true_masks</span> <span class="o">-</span> <span class="n">TP</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="k">if</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="k">if</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span></div>


<div class="viewcode-block" id="pad_to_same_shape">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.pad_to_same_shape">[docs]</a>
<span class="k">def</span> <span class="nf">pad_to_same_shape</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads two 2D arrays (masks) to the same shape by adding zero-padding to the </span>
<span class="sd">    right and bottom of each array as needed.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        mask1 (numpy.ndarray): The first 2D array to be padded.</span>
<span class="sd">        mask2 (numpy.ndarray): The second 2D array to be padded.</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two 2D numpy arrays:</span>
<span class="sd">            - padded_mask1 (numpy.ndarray): The first array padded to match the shape of the larger array.</span>
<span class="sd">            - padded_mask2 (numpy.ndarray): The second array padded to match the shape of the larger array.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The padding is applied with constant values of 0.</span>
<span class="sd">        - The function assumes that both inputs are 2D arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the shape differences</span>
    <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">pad_mask1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">pad_mask2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="n">padded_mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">pad_mask1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">padded_mask2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">pad_mask2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">padded_mask1</span><span class="p">,</span> <span class="n">padded_mask2</span></div>

    
<div class="viewcode-block" id="compute_ap_over_iou_thresholds">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.compute_ap_over_iou_thresholds">[docs]</a>
<span class="k">def</span> <span class="nf">compute_ap_over_iou_thresholds</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Average Precision (AP) over a range of Intersection over Union (IoU) thresholds.</span>

<span class="sd">    This function calculates the precision-recall pairs for each IoU threshold, validates that</span>
<span class="sd">    precision and recall values are within the range [0, 1], and computes the Average Precision</span>
<span class="sd">    by integrating the precision-recall curve using the trapezoidal rule.</span>

<span class="sd">    Args:</span>
<span class="sd">        true_masks (list or array-like): Ground truth masks.</span>
<span class="sd">        pred_masks (list or array-like): Predicted masks.</span>
<span class="sd">        iou_thresholds (list or array-like): A list of IoU thresholds to evaluate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The computed Average Precision (AP) over the specified IoU thresholds.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If precision or recall values are out of the valid range [0, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">precision_recall_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iou_threshold</span> <span class="ow">in</span> <span class="n">iou_thresholds</span><span class="p">:</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">match_masks</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="p">)</span>
        <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span> <span class="o">=</span> <span class="n">compute_average_precision</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_masks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_masks</span><span class="p">))</span>
        <span class="c1"># Check that precision and recall are within the range [0, 1]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">precision</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">recall</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Precision or recall out of bounds. Precision: </span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s1">, Recall: </span><span class="si">{</span><span class="n">recall</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">precision_recall_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">))</span>

    <span class="c1"># Sort by recall values</span>
    <span class="n">precision_recall_pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">precision_recall_pairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sorted_precisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">precision_recall_pairs</span><span class="p">]</span>
    <span class="n">sorted_recalls</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">precision_recall_pairs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">sorted_precisions</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">sorted_recalls</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="compute_segmentation_ap">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.compute_segmentation_ap">[docs]</a>
<span class="k">def</span> <span class="nf">compute_segmentation_ap</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Average Precision (AP) for segmentation masks over a range of IoU thresholds.</span>

<span class="sd">    This function calculates the AP by comparing the ground truth masks (`true_masks`) with the</span>
<span class="sd">    predicted masks (`pred_masks`) across multiple Intersection over Union (IoU) thresholds.</span>

<span class="sd">    Args:</span>
<span class="sd">        true_masks (ndarray): A binary array representing the ground truth segmentation masks.</span>
<span class="sd">                              Each connected component is treated as a separate object.</span>
<span class="sd">        pred_masks (ndarray): A binary array representing the predicted segmentation masks.</span>
<span class="sd">                              Each connected component is treated as a separate object.</span>
<span class="sd">        iou_thresholds (ndarray, optional): A 1D array of IoU thresholds to evaluate AP over.</span>
<span class="sd">                                            Defaults to `np.linspace(0.5, 0.95, 10)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The computed Average Precision (AP) over the specified IoU thresholds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">true_mask_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">true_masks</span><span class="p">)</span>
    <span class="n">pred_mask_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">pred_masks</span><span class="p">)</span>
    <span class="n">true_mask_regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">true_mask_labels</span><span class="p">)]</span>
    <span class="n">pred_mask_regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">pred_mask_labels</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">compute_ap_over_iou_thresholds</span><span class="p">(</span><span class="n">true_mask_regions</span><span class="p">,</span> <span class="n">pred_mask_regions</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="p">)</span></div>


<div class="viewcode-block" id="jaccard_index">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.jaccard_index">[docs]</a>
<span class="k">def</span> <span class="nf">jaccard_index</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Jaccard Index (Intersection over Union) between two binary masks.</span>

<span class="sd">    The Jaccard Index is a measure of similarity between two sets, defined as the size</span>
<span class="sd">    of the intersection divided by the size of the union of the sets.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mask1 (numpy.ndarray): A binary mask (e.g., a 2D array of boolean or 0/1 values).</span>
<span class="sd">        mask2 (numpy.ndarray): Another binary mask of the same shape as `mask1`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The Jaccard Index, a value between 0 and 1, where 1 indicates perfect overlap</span>
<span class="sd">               and 0 indicates no overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">union</span><span class="p">)</span></div>


<div class="viewcode-block" id="dice_coefficient">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.dice_coefficient">[docs]</a>
<span class="k">def</span> <span class="nf">dice_coefficient</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Dice coefficient, a measure of overlap between two binary masks.</span>
<span class="sd">    The Dice coefficient is calculated as:</span>
<span class="sd">        Dice = 2 * |A ∩ B| / (|A| + |B|)</span>
<span class="sd">    where A and B are the two binary masks, |A ∩ B| is the size of their intersection,</span>
<span class="sd">    and |A| + |B| is the sum of their sizes.</span>
<span class="sd">    Args:</span>
<span class="sd">        mask1 (numpy.ndarray): The first mask, can be any array-like structure.</span>
<span class="sd">        mask2 (numpy.ndarray): The second mask, can be any array-like structure.</span>
<span class="sd">    Returns:</span>
<span class="sd">        float: The Dice coefficient, ranging from 0.0 (no overlap) to 1.0 (perfect overlap).</span>
<span class="sd">               If both masks are empty, the function returns 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert to binary masks</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate intersection and total</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask2</span><span class="p">)</span>
    
    <span class="c1"># Handle the case where both masks are empty</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    
    <span class="c1"># Return the Dice coefficient</span>
    <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">total</span></div>


<div class="viewcode-block" id="extract_boundaries">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.extract_boundaries">[docs]</a>
<span class="k">def</span> <span class="nf">extract_boundaries</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the boundaries of a binary mask by applying morphological dilation </span>
<span class="sd">    and erosion operations and computing their difference.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mask (numpy.ndarray): A 2D array representing the input mask. Non-zero </span>
<span class="sd">                              values are considered part of the mask.</span>
<span class="sd">        dilation_radius (int, optional): The radius of the structuring element </span>
<span class="sd">                                         used for dilation and erosion. </span>
<span class="sd">                                         Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A binary array of the same shape as the input mask, </span>
<span class="sd">                       where the boundary pixels are marked as 1 and all </span>
<span class="sd">                       other pixels are 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">struct_elem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dilation_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">dilated</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">struct_elem</span><span class="p">)</span>
    <span class="n">eroded</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">struct_elem</span><span class="p">)</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">dilated</span> <span class="o">^</span> <span class="n">eroded</span>
    <span class="k">return</span> <span class="n">boundary</span></div>


<div class="viewcode-block" id="boundary_f1_score">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.boundary_f1_score">[docs]</a>
<span class="k">def</span> <span class="nf">boundary_f1_score</span><span class="p">(</span><span class="n">mask_true</span><span class="p">,</span> <span class="n">mask_pred</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the boundary F1 score between two binary masks.</span>
<span class="sd">    The boundary F1 score is a metric used to evaluate the similarity between </span>
<span class="sd">    the boundaries of two binary masks. It computes the harmonic mean of </span>
<span class="sd">    precision and recall for boundary detection.</span>
<span class="sd">    Args:</span>
<span class="sd">        mask_true (np.ndarray): Ground truth binary mask. Non-zero values are </span>
<span class="sd">            considered as the object.</span>
<span class="sd">        mask_pred (np.ndarray): Predicted binary mask. Non-zero values are </span>
<span class="sd">            considered as the object.</span>
<span class="sd">        dilation_radius (int, optional): Radius for boundary dilation when </span>
<span class="sd">            extracting boundaries. Defaults to 1.</span>
<span class="sd">    Returns:</span>
<span class="sd">        float: The boundary F1 score, a value between 0 and 1, where 1 indicates </span>
<span class="sd">        perfect boundary alignment and 0 indicates no alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Assume extract_boundaries is defined to extract object boundaries with given dilation_radius</span>
    <span class="n">boundary_true</span> <span class="o">=</span> <span class="n">extract_boundaries</span><span class="p">(</span><span class="n">mask_true</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="p">)</span>
    <span class="n">boundary_pred</span> <span class="o">=</span> <span class="n">extract_boundaries</span><span class="p">(</span><span class="n">mask_pred</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="p">)</span>
    
    <span class="c1"># Calculate intersection of boundaries</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">boundary_true</span><span class="p">,</span> <span class="n">boundary_pred</span><span class="p">)</span>
    
    <span class="c1"># Calculate precision and recall for boundary detection</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">boundary_pred</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">boundary_true</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="c1"># Calculate F1 score as harmonic mean of precision and recall</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">f1</span></div>


<span class="k">def</span> <span class="nf">_remove_noninfected</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove non-infected cells from the stack based on the provided dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        cell_dim (int or None): The dimension index for the cell mask. If None, a zero-filled mask will be used.</span>
<span class="sd">        nucleus_dim (int or None): The dimension index for the nucleus mask. If None, a zero-filled mask will be used.</span>
<span class="sd">        pathogen_dim (int or None): The dimension index for the pathogen mask. If None, a zero-filled mask will be used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with non-infected cells removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">labels_in_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_in_cell</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="k">return</span> <span class="n">stack</span>

<span class="k">def</span> <span class="nf">_remove_outside_objects</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove outside objects from the stack based on the provided dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        cell_dim (int): The dimension index of the cell mask in the stack.</span>
<span class="sd">        nucleus_dim (int): The dimension index of the nucleus mask in the stack.</span>
<span class="sd">        pathogen_dim (int): The dimension index of the pathogen mask in the stack.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with outside objects removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="n">pathogen_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">pathogen_label</span> <span class="ow">in</span> <span class="n">pathogen_labels</span><span class="p">:</span>
        <span class="n">pathogen_region</span> <span class="o">=</span> <span class="n">pathogen_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span>
        <span class="n">cell_in_pathogen_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">[</span><span class="n">pathogen_region</span><span class="p">])</span>
        <span class="n">cell_in_pathogen_region</span> <span class="o">=</span> <span class="n">cell_in_pathogen_region</span><span class="p">[</span><span class="n">cell_in_pathogen_region</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude background</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_in_pathogen_region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pathogen_mask</span><span class="p">[</span><span class="n">pathogen_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">corresponding_nucleus_region</span> <span class="o">=</span> <span class="n">nucleus_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">corresponding_nucleus_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathogen_mask</span>
    <span class="k">return</span> <span class="n">stack</span>

<span class="k">def</span> <span class="nf">_remove_multiobject_cells</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">mask_dim</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">,</span> <span class="n">object_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove multi-object cells from the stack.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        mask_dim (int): The dimension of the mask in the stack.</span>
<span class="sd">        cell_dim (int): The dimension of the cell in the stack.</span>
<span class="sd">        nucleus_dim (int): The dimension of the nucleus in the stack.</span>
<span class="sd">        pathogen_dim (int): The dimension of the pathogen in the stack.</span>
<span class="sd">        object_dim (int): The dimension of the object in the stack.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with multi-object cells removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">mask_dim</span><span class="p">]</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="n">object_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">object_dim</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">labels_in_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">object_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_in_cell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pathogen_label</span> <span class="ow">in</span> <span class="n">labels_in_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Skip the first label (0)</span>
                <span class="n">pathogen_mask</span><span class="p">[</span><span class="n">pathogen_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathogen_mask</span>
    <span class="k">return</span> <span class="n">stack</span>
    
<div class="viewcode-block" id="merge_touching_objects">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.merge_touching_objects">[docs]</a>
<span class="k">def</span> <span class="nf">merge_touching_objects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges touching objects in a binary mask based on the percentage of their shared boundary.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (ndarray): Binary mask representing objects.</span>
<span class="sd">        threshold (float, optional): Threshold value for merging objects. Defaults to 0.25.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Merged mask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perimeters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="c1"># Calculating perimeter of each object</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Ignore background</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">erosion</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="n">perimeters</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="c1"># Detect touching objects and find the shared boundary</span>
    <span class="n">shared_perimeters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dilated</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Ignore background</span>
            <span class="c1"># Find the objects that this object is touching</span>
            <span class="n">dilated_label</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="n">touching_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">dilated</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dilated_label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">touching_label</span> <span class="ow">in</span> <span class="n">touching_labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">touching_label</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>  <span class="c1"># Exclude the object itself</span>
                    <span class="n">shared_boundary</span> <span class="o">=</span> <span class="n">dilated_label</span> <span class="o">&amp;</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">touching_label</span><span class="p">)</span>
                    <span class="n">shared_perimeters</span><span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">touching_label</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shared_boundary</span><span class="p">)</span>
    <span class="c1"># Merge objects if more than 25% of their boundary is touching</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">label2</span><span class="p">),</span> <span class="n">shared_perimeter</span> <span class="ow">in</span> <span class="n">shared_perimeters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">shared_perimeter</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">perimeters</span><span class="p">[</span><span class="n">label1</span><span class="p">],</span> <span class="n">perimeters</span><span class="p">[</span><span class="n">label2</span><span class="p">]):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label2</span><span class="p">]</span> <span class="o">=</span> <span class="n">label1</span>  <span class="c1"># Merge label2 into label1</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="remove_intensity_objects">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_intensity_objects">[docs]</a>
<span class="k">def</span> <span class="nf">remove_intensity_objects</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">intensity_threshold</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes objects from the mask based on their mean intensity in the original image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (ndarray): The original image.</span>
<span class="sd">        mask (ndarray): The mask containing labeled objects.</span>
<span class="sd">        intensity_threshold (float): The threshold value for mean intensity.</span>
<span class="sd">        mode (str): The mode for intensity comparison. Can be &#39;low&#39; or &#39;high&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated mask with objects removed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the mean intensity of each object in the original image</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">))</span>
    <span class="c1"># Find the labels of the objects with mean intensity below the threshold</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span><span class="p">:</span>
        <span class="n">labels_to_remove</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intensity_threshold</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">:</span>
        <span class="n">labels_to_remove</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intensity_threshold</span><span class="p">]</span>
    <span class="c1"># Remove these objects from the mask</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">labels_to_remove</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<span class="k">def</span> <span class="nf">_filter_closest_to_stat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">use_median</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the DataFrame to include the closest rows to a statistical measure.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame.</span>
<span class="sd">        column (str): The column name to calculate the statistical measure.</span>
<span class="sd">        n_rows (int): The number of closest rows to include in the result.</span>
<span class="sd">        use_median (bool, optional): Whether to use the median or mean as the statistical measure. </span>
<span class="sd">            Defaults to False (mean).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The filtered DataFrame with the closest rows to the statistical measure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_median</span><span class="p">:</span>
        <span class="n">target_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_value</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;diff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result_df</span>
    
<span class="k">def</span> <span class="nf">_find_similar_sized_images</span><span class="p">(</span><span class="n">file_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the largest group of images with the most similar size and shape.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_list (list): List of file paths to the images.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: List of file paths belonging to the largest group of images with the most similar size and shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Dictionary to hold image sizes and their paths</span>
    <span class="n">size_to_paths</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="c1"># Iterate over image paths to get their dimensions</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_UNCHANGED</span><span class="p">)</span>  <span class="c1"># Read with unchanged color space to support different image types</span>
        <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Find indices where the image is not padded (non-zero)</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Color image</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Grayscale image</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># Find the bounding box of non-zero regions</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip images that are completely padded</span>
                <span class="k">continue</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Add 1 because slice end index is exclusive</span>
            <span class="c1"># Crop the image to remove padding</span>
            <span class="n">cropped_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span>
            <span class="c1"># Get dimensions of the cropped image</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">cropped_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span>
            <span class="n">size_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Group by width, height, and aspect ratio</span>
            <span class="n">size_to_paths</span><span class="p">[</span><span class="n">size_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="c1"># Find the largest group of images with the most similar size and shape</span>
    <span class="n">largest_group</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">size_to_paths</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">largest_group</span>
    
<span class="k">def</span> <span class="nf">_relabel_parent_with_child_labels</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">,</span> <span class="n">child_mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relabels the parent mask based on overlapping child labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        parent_mask (ndarray): Binary mask representing the parent objects.</span>
<span class="sd">        child_mask (ndarray): Binary mask representing the child objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the relabeled parent mask and the original child mask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Label parent mask to identify unique objects</span>
    <span class="n">parent_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Use the original child mask labels directly, without relabeling</span>
    <span class="n">child_labels</span> <span class="o">=</span> <span class="n">child_mask</span>

    <span class="c1"># Create a new parent mask for updated labels</span>
    <span class="n">parent_mask_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">)</span>

    <span class="c1"># Directly relabel parent cells based on overlapping child labels</span>
    <span class="n">unique_child_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">child_labels</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Skip background</span>
    <span class="k">for</span> <span class="n">child_label</span> <span class="ow">in</span> <span class="n">unique_child_labels</span><span class="p">:</span>
        <span class="n">child_area_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">child_labels</span> <span class="o">==</span> <span class="n">child_label</span><span class="p">)</span>
        <span class="n">overlapping_parent_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">parent_labels</span><span class="p">[</span><span class="n">child_area_mask</span><span class="p">])</span>

        <span class="c1"># Since each parent is assumed to overlap with exactly one nucleus,</span>
        <span class="c1"># directly set the parent label to the child label where overlap occurs</span>
        <span class="k">for</span> <span class="n">parent_label</span> <span class="ow">in</span> <span class="n">overlapping_parent_label</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent_label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip background</span>
                <span class="n">parent_mask_new</span><span class="p">[</span><span class="n">parent_labels</span> <span class="o">==</span> <span class="n">parent_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_label</span>

    <span class="c1"># For cells containing multiple nucleus, standardize all nucleus to the first label</span>
    <span class="c1"># This will be done only if needed, as per your condition</span>
    <span class="k">for</span> <span class="n">parent_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">parent_mask_new</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Skip background</span>
        <span class="n">parent_area_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent_mask_new</span> <span class="o">==</span> <span class="n">parent_label</span><span class="p">)</span>
        <span class="n">child_labels_in_parent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">child_mask</span><span class="p">[</span><span class="n">parent_area_mask</span><span class="p">])</span>
        <span class="n">child_labels_in_parent</span> <span class="o">=</span> <span class="n">child_labels_in_parent</span><span class="p">[</span><span class="n">child_labels_in_parent</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude background</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_labels_in_parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Standardize to the first child label within this parent</span>
            <span class="n">first_child_label</span> <span class="o">=</span> <span class="n">child_labels_in_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">child_label</span> <span class="ow">in</span> <span class="n">child_labels_in_parent</span><span class="p">:</span>
                <span class="n">child_mask</span><span class="p">[</span><span class="n">child_mask</span> <span class="o">==</span> <span class="n">child_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_child_label</span>

    <span class="k">return</span> <span class="n">parent_mask_new</span><span class="p">,</span> <span class="n">child_mask</span>
    
<span class="k">def</span> <span class="nf">_exclude_objects</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">pathogen_mask</span><span class="p">,</span> <span class="n">cytoplasm_mask</span><span class="p">,</span> <span class="n">uninfected</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exclude objects from the masks based on certain criteria.</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_mask (ndarray): Mask representing cells.</span>
<span class="sd">        nucleus_mask (ndarray): Mask representing nucleus.</span>
<span class="sd">        pathogen_mask (ndarray): Mask representing pathogens.</span>
<span class="sd">        cytoplasm_mask (ndarray): Mask representing cytoplasm.</span>
<span class="sd">        uninfected (bool, optional): Whether to include uninfected cells. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the filtered cell mask, nucleus mask, pathogen mask, and cytoplasm mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove cells with no nucleus or cytoplasm (or pathogen)</span>
    <span class="n">filtered_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span> <span class="c1"># Initialize a new mask to store the filtered cells.</span>
    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">):</span> <span class="c1"># Iterate over all cell labels in the cell mask.</span>
        <span class="k">if</span> <span class="n">cell_label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Skip background</span>
            <span class="k">continue</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span> <span class="c1"># Get a mask for the current cell.</span>
        <span class="c1"># Check existence of nucleus, cytoplasm and pathogen in the current cell.</span>
        <span class="n">has_nucleus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="n">has_cytoplasm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cytoplasm_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="n">has_pathogen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">uninfected</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_nucleus</span> <span class="ow">and</span> <span class="n">has_cytoplasm</span><span class="p">:</span>
                <span class="n">filtered_cells</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_nucleus</span> <span class="ow">and</span> <span class="n">has_cytoplasm</span> <span class="ow">and</span> <span class="n">has_pathogen</span><span class="p">:</span>
                <span class="n">filtered_cells</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_label</span>
    <span class="c1"># Remove objects outside of cells</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">nucleus_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">pathogen_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cytoplasm_mask</span> <span class="o">=</span> <span class="n">cytoplasm_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_cells</span><span class="p">,</span> <span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">pathogen_mask</span><span class="p">,</span> <span class="n">cytoplasm_mask</span>

<span class="k">def</span> <span class="nf">_merge_overlapping_objects</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge overlapping objects in two masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask1 (ndarray): First mask.</span>
<span class="sd">        mask2 (ndarray): Second mask.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the merged masks (mask1, mask2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labeled_1</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span>
    <span class="n">num_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m1_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_1_mask</span> <span class="o">=</span> <span class="n">labeled_1</span> <span class="o">==</span> <span class="n">m1_id</span>
        <span class="n">overlapping_2_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask2</span><span class="p">[</span><span class="n">current_1_mask</span><span class="p">])</span>
        <span class="n">overlapping_2_labels</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="n">overlapping_2_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_2_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_1_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_1_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">]</span>
            <span class="n">max_overlap_label</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">overlap_percentages</span><span class="p">)]</span>
            <span class="n">max_overlap_percentage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">overlap_percentages</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_overlap_percentage</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">m2_label</span> <span class="o">!=</span> <span class="n">max_overlap_label</span><span class="p">:</span>
                        <span class="n">mask1</span><span class="p">[(</span><span class="n">current_1_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">mask2</span><span class="p">[</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span>

<span class="k">def</span> <span class="nf">_filter_object</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">min_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter objects in a mask based on their frequency.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (ndarray): The input mask.</span>
<span class="sd">        min_value (int): The minimum frequency threshold.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The filtered mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">mask</span>

<span class="k">def</span> <span class="nf">_filter_cp_masks</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">filter_intensity</span><span class="p">,</span> <span class="n">minimum_size</span><span class="p">,</span> <span class="n">maximum_size</span><span class="p">,</span> <span class="n">remove_border_objects</span><span class="p">,</span> <span class="n">merge</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the masks based on various criteria such as size, border objects, merging, and intensity.</span>

<span class="sd">    Args:</span>
<span class="sd">        masks (list): List of masks.</span>
<span class="sd">        flows (list): List of flows.</span>
<span class="sd">        filter_size (bool): Flag indicating whether to filter based on size.</span>
<span class="sd">        filter_intensity (bool): Flag indicating whether to filter based on intensity.</span>
<span class="sd">        minimum_size (int): Minimum size of objects to keep.</span>
<span class="sd">        maximum_size (int): Maximum size of objects to keep.</span>
<span class="sd">        remove_border_objects (bool): Flag indicating whether to remove border objects.</span>
<span class="sd">        merge (bool): Flag indicating whether to merge adjacent objects.</span>
<span class="sd">        batch (ndarray): Batch of images.</span>
<span class="sd">        plot (bool): Flag indicating whether to plot the masks.</span>
<span class="sd">        figuresize (tuple): Size of the figure.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: List of filtered masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">plot_masks</span>
    
    <span class="n">mask_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch</span><span class="p">)):</span>
        
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects before filtration: </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">merge_touching_objects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.66</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after merging adjacent objects, : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_size</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">])</span>
            <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minimum_size</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maximum_size</span><span class="p">)]</span> 
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after size filtration &gt;</span><span class="si">{</span><span class="n">minimum_size</span><span class="si">}</span><span class="s1"> and &lt;</span><span class="si">{</span><span class="n">maximum_size</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_intensity</span><span class="p">:</span>
            <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>  
            <span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">intensity_image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span>
            <span class="n">mean_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mean_intensities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">mean_intensities</span><span class="p">)</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
            
                <span class="c1"># Calculate the Euclidean distance between the two centroids</span>
                <span class="n">dist_between_centroids</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="c1"># Set a threshold for the minimum distance to consider clusters distinct</span>
                <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mf">0.25</span> 
                
                <span class="k">if</span> <span class="n">dist_between_centroids</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="n">high_intensity_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
                    <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">])[</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">high_intensity_cluster</span><span class="p">]</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">props_after</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">intensity_image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span>
                <span class="n">mean_intensities_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props_after</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]))</span>
                <span class="n">average_intensity_before</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_intensities</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after potential intensity clustering: </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">. Mean intensity before:</span><span class="si">{</span><span class="n">average_intensity_before</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">. After:</span><span class="si">{</span><span class="n">mean_intensities_after</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">remove_border_objects</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after removing border objects, : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">mask_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mask_stack</span>
    
<span class="k">def</span> <span class="nf">_object_filter</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">object_type</span><span class="p">,</span> <span class="n">size_range</span><span class="p">,</span> <span class="n">intensity_range</span><span class="p">,</span> <span class="n">mask_chans</span><span class="p">,</span> <span class="n">mask_chan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the DataFrame based on object type, size range, and intensity range.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The DataFrame to filter.</span>
<span class="sd">        object_type (str): The type of object to filter.</span>
<span class="sd">        size_range (list or None): The range of object sizes to filter.</span>
<span class="sd">        intensity_range (list or None): The range of object intensities to filter.</span>
<span class="sd">        mask_chans (list): The list of mask channels.</span>
<span class="sd">        mask_chan (int): The index of the mask channel to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The filtered DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">size_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span> 
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_area&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> minimum area filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_area&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> maximum area filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">intensity_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">mask_chans</span><span class="p">[</span><span class="n">mask_chan</span><span class="p">]</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> minimum mean intensity filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">mask_chans</span><span class="p">[</span><span class="n">mask_chan</span><span class="p">]</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intensity_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> maximum mean intensity filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="k">def</span> <span class="nf">_get_regex</span><span class="p">(</span><span class="n">metadata_type</span><span class="p">,</span> <span class="n">img_format</span><span class="p">,</span> <span class="n">custom_regex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a regex pattern based on the specified metadata type and image format.</span>
<span class="sd">    Args:</span>
<span class="sd">        metadata_type (str): The type of metadata to generate the regex for. </span>
<span class="sd">            Supported values are:</span>
<span class="sd">            - &#39;cellvoyager&#39;: Generates a regex for CellVoyager metadata format.</span>
<span class="sd">            - &#39;cq1&#39;: Generates a regex for CQ1 metadata format.</span>
<span class="sd">            - &#39;auto&#39;: Generates a regex for automatic detection of metadata.</span>
<span class="sd">            - &#39;custom&#39;: Uses a custom regex provided by the user.</span>
<span class="sd">        img_format (str): The image file format (e.g., &#39;tif&#39;). If None, defaults to &#39;tif&#39;.</span>
<span class="sd">        custom_regex (str, optional): A custom regex pattern to use when metadata_type is &#39;custom&#39;.</span>
<span class="sd">    Returns:</span>
<span class="sd">        str: The generated regex pattern.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - Prints the image format and the generated regex for debugging purposes.</span>
<span class="sd">        - If `img_format` is None, it defaults to &#39;tif&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image_format: </span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">img_format</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img_format</span> <span class="o">==</span> <span class="s1">&#39;tif&#39;</span>
    <span class="k">if</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;cellvoyager&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;..)A(?P&lt;AID&gt;..)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*).</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;cq1&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;W(?P&lt;wellID&gt;.*)F(?P&lt;fieldID&gt;.*)T(?P&lt;timeID&gt;.*)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*).</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;.*)C(?P&lt;chanID&gt;.*).tif&quot;</span>     
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">custom_regex</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s2">&quot;</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;regex mode:</span><span class="si">{</span><span class="n">metadata_type</span><span class="si">}</span><span class="s1"> regex:</span><span class="si">{</span><span class="n">regex</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">regex</span>

<span class="k">def</span> <span class="nf">_run_test_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">test_images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_test</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepares a test dataset by selecting and copying a subset of images from the source directory </span>
<span class="sd">    based on a regular expression and other criteria.</span>
<span class="sd">    Args:</span>
<span class="sd">        src (str): The source directory containing the images.</span>
<span class="sd">        regex (str): A regular expression to match filenames. The regex should include named groups </span>
<span class="sd">                     &#39;plateID&#39;, &#39;wellID&#39;, and &#39;fieldID&#39; if applicable.</span>
<span class="sd">        timelapse (bool, optional): If True, limits the selection to one set of images to ensure </span>
<span class="sd">                                    full sequence inclusion. Defaults to False.</span>
<span class="sd">        test_images (int, optional): The number of image sets to include in the test dataset. </span>
<span class="sd">                                     Defaults to 10.</span>
<span class="sd">        random_test (bool, optional): If True, randomizes the selection of image sets. Defaults to True.</span>
<span class="sd">    Returns:</span>
<span class="sd">        str: The path to the test folder containing the selected images.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - If a subdirectory named &#39;orig&#39; exists within the source directory, it will be used as the </span>
<span class="sd">          source for image selection.</span>
<span class="sd">        - The selected images are grouped by a combination of plate, well, and field identifiers </span>
<span class="sd">          extracted from the filename using the provided regex.</span>
<span class="sd">        - The function ensures the test folder is created and populated with the selected images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="n">test_images</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Use only 1 set for timelapse to ensure full sequence inclusion</span>
    
    <span class="n">test_folder_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">test_folder_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">regular_expression</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;orig&#39;</span><span class="p">)):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;orig&#39;</span><span class="p">)</span>
        
    <span class="n">all_filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="k">if</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_filenames</span><span class="p">)</span><span class="si">}</span><span class="s1"> files&#39;</span><span class="p">)</span>
    <span class="n">images_by_set</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">all_filenames</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">plate</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;plateID&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;plateID&#39;</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="n">well</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wellID&#39;</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;fieldID&#39;</span><span class="p">)</span>
            <span class="n">set_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="n">images_by_set</span><span class="p">[</span><span class="n">set_identifier</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    
    <span class="c1"># Prepare for random selection</span>
    <span class="n">set_identifiers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images_by_set</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">random_test</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">set_identifiers</span><span class="p">)</span>  <span class="c1"># Randomize the order</span>
    
    <span class="c1"># Select a subset based on the test_images count</span>
    <span class="n">selected_sets</span> <span class="o">=</span> <span class="n">set_identifiers</span><span class="p">[:</span><span class="n">test_images</span><span class="p">]</span>

    <span class="c1"># Print information about the number of sets used</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_sets</span><span class="p">)</span><span class="si">}</span><span class="s1"> random image set(s) for test model&#39;</span><span class="p">)</span>

    <span class="c1"># Copy files for selected sets to the test folder</span>
    <span class="k">for</span> <span class="n">set_identifier</span> <span class="ow">in</span> <span class="n">selected_sets</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">images_by_set</span><span class="p">[</span><span class="n">set_identifier</span><span class="p">]:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">test_folder_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">test_folder_path</span>

<span class="k">def</span> <span class="nf">_choose_model</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">object_type</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">restore_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">object_settings</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects and initializes a model based on the provided parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    model_name : str</span>
<span class="sd">        The name of the model to use. Supported values include:</span>
<span class="sd">        - &#39;toxo_pv_lumen&#39; (specific to &#39;pathogen&#39; object_type)</span>
<span class="sd">        - &#39;sam&#39;, &#39;cyto&#39;, &#39;cyto2&#39;, &#39;cyto3&#39;, &#39;nuclei&#39; (for default models)</span>
<span class="sd">    device : torch.device</span>
<span class="sd">        The device on which the model will run (e.g., CPU or GPU).</span>
<span class="sd">    object_type : str, optional</span>
<span class="sd">        The type of object the model is intended for. Default is &#39;cell&#39;.</span>
<span class="sd">        Supported values:</span>
<span class="sd">        - &#39;pathogen&#39;: Uses a specific model for Toxoplasma PV lumen.</span>
<span class="sd">        - &#39;nucleus&#39;: Uses denoising or restoration models.</span>
<span class="sd">        - &#39;cell&#39;: Uses default Cellpose models.</span>
<span class="sd">    restore_type : str or None, optional</span>
<span class="sd">        The type of restoration to apply. Supported values:</span>
<span class="sd">        - &#39;denoise&#39;, &#39;deblur&#39;, &#39;upsample&#39;, or None (default).</span>
<span class="sd">        If None, standard models are used.</span>
<span class="sd">    object_settings : dict, optional</span>
<span class="sd">        Additional settings for specific object types. For example:</span>
<span class="sd">        - For &#39;pathogen&#39;, requires &#39;diameter&#39; key to specify object diameter.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    model : CellposeModel or CellposeDenoiseModel</span>
<span class="sd">        The initialized model based on the provided parameters.</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - For &#39;pathogen&#39; object_type with &#39;toxo_pv_lumen&#39; model_name, a custom</span>
<span class="sd">      pretrained model is loaded from the &#39;models/cp&#39; directory.</span>
<span class="sd">    - For &#39;nucleus&#39; object_type, restoration models are initialized with</span>
<span class="sd">      specific restore types.</span>
<span class="sd">    - If an invalid restore_type is provided, it defaults to None with a warning.</span>
<span class="sd">    - GPU usage is determined automatically based on availability.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">    KeyError:</span>
<span class="sd">        If &#39;diameter&#39; is not provided in `object_settings` when using the</span>
<span class="sd">        &#39;toxo_pv_lumen&#39; model for &#39;pathogen&#39; object_type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;toxo_pv_lumen&#39;</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span>
            <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span> <span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="s1">&#39;toxo_pv_lumen.CP_model&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cp_models</span><span class="o">.</span><span class="n">CellposeModel</span><span class="p">(</span>
                <span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span>
                <span class="n">model_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">pretrained_model</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span>
                <span class="n">diam_mean</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Using Toxoplasma PV lumen model to generate pathogen masks&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>

    <span class="n">restore_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;denoise&#39;</span><span class="p">,</span> <span class="s1">&#39;deblur&#39;</span><span class="p">,</span> <span class="s1">&#39;upsample&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">restore_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">restore_list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid restore type. Choose from </span><span class="si">{</span><span class="n">restore_list</span><span class="si">}</span><span class="s2">, defaulting to None&quot;</span><span class="p">)</span>
        <span class="n">restore_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">restore_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;sam&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cp_models</span><span class="o">.</span><span class="n">CellposeModel</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">pretrained_model</span><span class="o">=</span><span class="s1">&#39;cpsam&#39;</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">model</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">,</span> <span class="s1">&#39;cyto2&#39;</span><span class="p">,</span> <span class="s1">&#39;cyto3&#39;</span><span class="p">,</span> <span class="s1">&#39;nuclei&#39;</span><span class="p">]:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cp_models</span><span class="o">.</span><span class="n">CellposeModel</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">model_type</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
            <span class="n">restore</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">restore_type</span><span class="si">}</span><span class="s1">_nuclei&#39;</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">denoise</span><span class="o">.</span><span class="n">CellposeDenoiseModel</span><span class="p">(</span>
                <span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span>
                <span class="n">model_type</span><span class="o">=</span><span class="s2">&quot;nuclei&quot;</span><span class="p">,</span>
                <span class="n">restore_type</span><span class="o">=</span><span class="n">restore</span><span class="p">,</span>
                <span class="n">chan2_restore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">restore</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">restore_type</span><span class="si">}</span><span class="s1">_cyto3&#39;</span>
            <span class="n">chan2_restore</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;cyto2&#39;</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">denoise</span><span class="o">.</span><span class="n">CellposeDenoiseModel</span><span class="p">(</span>
                <span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span>
                <span class="n">model_type</span><span class="o">=</span><span class="s2">&quot;cyto3&quot;</span><span class="p">,</span>
                <span class="n">restore_type</span><span class="o">=</span><span class="n">restore</span><span class="p">,</span>
                <span class="n">chan2_restore</span><span class="o">=</span><span class="n">chan2_restore</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>

<div class="viewcode-block" id="SelectChannels">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels">[docs]</a>
<span class="k">class</span> <span class="nc">SelectChannels</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selectively retain specific color channels in an image tensor.</span>

<span class="sd">    This class zeroes out undesired color channels in a 3-channel image tensor,</span>
<span class="sd">    based on the specified list of channels to retain.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        channels (list of int): List of 1-based indices for channels to retain.</span>
<span class="sd">            - 1: Red channel</span>
<span class="sd">            - 2: Green channel</span>
<span class="sd">            - 3: Blue channel</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; select_channels = SelectChannels([1, 3])  # Retain red and blue channels</span>
<span class="sd">        &gt;&gt;&gt; modified_img = select_channels(img)      # Apply the transformation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the channel selector.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list of int): List of 1-based channel indices to retain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SelectChannels.channels">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels.channels">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span></div>

    
<div class="viewcode-block" id="SelectChannels.__call__">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SelectChannels.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply channel selection to the image.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (torch.Tensor): A 3-channel image tensor of shape (3, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Image tensor with non-selected channels zeroed out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the red channel</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the green channel</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the blue channel</span>
        <span class="k">return</span> <span class="n">img</span></div>
</div>

    
<div class="viewcode-block" id="preprocess_image_v1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_image_v1">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_image_v1</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocess an image for input into a machine learning model.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_path (str): The file path to the image to be processed.</span>
<span class="sd">        image_size (int, optional): The size to which the image will be center-cropped. Defaults to 224.</span>
<span class="sd">        channels (list, optional): A list of channel indices to select from the image. Defaults to [1, 2, 3].</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the image using mean and standard deviation. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - image (PIL.Image.Image): The original image loaded as a PIL Image object.</span>
<span class="sd">            - input_tensor (torch.Tensor): The preprocessed image as a PyTorch tensor with an added batch dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
            <span class="n">SelectChannels</span><span class="p">(</span><span class="n">channels</span><span class="p">),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">std</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
            <span class="n">SelectChannels</span><span class="p">(</span><span class="n">channels</span><span class="p">)])</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">input_tensor</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator">[docs]</a>
<span class="k">class</span> <span class="nc">SaliencyMapGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SaliencyMapGenerator is a utility class for generating saliency maps and visualizing model predictions</span>
<span class="sd">    for PyTorch models in binary classification tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the SaliencyMapGenerator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SaliencyMapGenerator.model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.model">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator.compute_saliency_maps">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.compute_saliency_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_saliency_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute saliency maps for the given inputs and target labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input tensor with requires_grad enabled.</span>
<span class="sd">            y (torch.Tensor): Ground truth labels for the input samples.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The computed saliency maps, same shape as input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># For binary classification, target scores can be the single output</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="n">saliency</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">saliency</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator.compute_saliency_and_predictions">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.compute_saliency_and_predictions">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_saliency_and_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute saliency maps and predictions for the given input batch.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input tensor with requires_grad enabled.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                - torch.Tensor: Saliency maps for the input.</span>
<span class="sd">                - torch.Tensor: Predicted class labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass to get predictions (logits)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Get predicted class (0 or 1 for binary classification)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Compute saliency maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">predictions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="n">saliency</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">saliency</span><span class="p">,</span> <span class="n">predictions</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator.plot_activation_grid">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.plot_activation_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_activation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">saliency</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">overlay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a grid of input images with overlaid saliency maps and predicted labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input tensor of images (N, C, H, W).</span>
<span class="sd">            saliency (torch.Tensor): Corresponding saliency maps (N, C, H, W).</span>
<span class="sd">            predictions (torch.Tensor): Predicted class labels (N,).</span>
<span class="sd">            overlay (bool): Whether to overlay saliency maps on input images. Default is True.</span>
<span class="sd">            normalize (bool): Whether to normalize input images by percentiles. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.figure.Figure: A matplotlib figure object showing the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> 
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">]</span>
            <span class="n">saliency_map</span> <span class="o">=</span> <span class="n">saliency</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Move to CPU and convert to numpy</span>

            <span class="k">if</span> <span class="n">saliency_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Channels first, reshape to (H, W, 3)</span>
                <span class="n">saliency_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">saliency_map</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Normalize image channels to 2nd and 98th percentiles</span>
            <span class="k">if</span> <span class="n">overlay</span><span class="p">:</span>
                <span class="n">img_np</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">img_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile_normalize</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">saliency_map</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># Add class label in the top-left corner</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span>
                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round,pad=0.2&#39;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    
<div class="viewcode-block" id="SaliencyMapGenerator.percentile_normalize">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.SaliencyMapGenerator.percentile_normalize">[docs]</a>
    <span class="k">def</span> <span class="nf">percentile_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">lower_percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize an image&#39;s intensity per channel using percentile clipping.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (np.ndarray): Image of shape (H, W, C) to be normalized.</span>
<span class="sd">            lower_percentile (int): Lower percentile for intensity clipping. Default is 2.</span>
<span class="sd">            upper_percentile (int): Upper percentile for intensity clipping. Default is 98.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Percentile-normalized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>  <span class="c1"># Iterate over each channel</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">lower_percentile</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">upper_percentile</span><span class="p">)</span>
            <span class="n">img_normalized</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_normalized</span></div>
</div>


<div class="viewcode-block" id="GradCAMGenerator">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator">[docs]</a>
<span class="k">class</span> <span class="nc">GradCAMGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GradCAMGenerator generates Grad-CAM (Gradient-weighted Class Activation Mapping) visualizations</span>
<span class="sd">    for CNN-based PyTorch models, supporting binary classification tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">cam_type</span><span class="o">=</span><span class="s1">&#39;gradcam&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GradCAMGenerator and register hooks.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (torch.nn.Module): A trained PyTorch model.</span>
<span class="sd">            target_layer (str): The name of the layer to compute Grad-CAM on.</span>
<span class="sd">            cam_type (str): Type of CAM method (default is &#39;gradcam&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GradCAMGenerator.model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.model">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span></div>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<div class="viewcode-block" id="GradCAMGenerator.target_layer">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.target_layer">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer</span> <span class="o">=</span> <span class="n">target_layer</span></div>

<div class="viewcode-block" id="GradCAMGenerator.cam_type">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.cam_type">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">cam_type</span> <span class="o">=</span> <span class="n">cam_type</span></div>

<div class="viewcode-block" id="GradCAMGenerator.gradients">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.gradients">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="GradCAMGenerator.activations">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.activations">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">activations</span> <span class="o">=</span> <span class="kc">None</span></div>


        <span class="c1"># Hook the target layer</span>
<div class="viewcode-block" id="GradCAMGenerator.target_layer_module">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.target_layer_module">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_layer</span><span class="p">)</span></div>

        <span class="bp">self</span><span class="o">.</span><span class="n">hook_layers</span><span class="p">()</span>

<div class="viewcode-block" id="GradCAMGenerator.hook_layers">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.hook_layers">[docs]</a>
    <span class="k">def</span> <span class="nf">hook_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register forward and backward hooks to capture activations and gradients</span>
<span class="sd">        from the specified target layer during inference and backpropagation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Forward hook to get activations</span>
        <span class="k">def</span> <span class="nf">forward_hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activations</span> <span class="o">=</span> <span class="n">output</span>

        <span class="c1"># Backward hook to get gradients</span>
        <span class="k">def</span> <span class="nf">backward_hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="n">grad_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">forward_hook</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span><span class="o">.</span><span class="n">register_backward_hook</span><span class="p">(</span><span class="n">backward_hook</span><span class="p">)</span></div>


<div class="viewcode-block" id="GradCAMGenerator.get_layer">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.get_layer">[docs]</a>
    <span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively retrieve a layer object from a nested model.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (torch.nn.Module): The model containing the layer.</span>
<span class="sd">            target_layer (str): Dot-separated string path to the desired layer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.nn.Module: The resolved layer module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Recursively find the layer specified in target_layer</span>
        <span class="n">modules</span> <span class="o">=</span> <span class="n">target_layer</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">layer</span></div>


<div class="viewcode-block" id="GradCAMGenerator.compute_gradcam_maps">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.compute_gradcam_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradcam_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Grad-CAM heatmaps for an input batch and target labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input tensor of shape (N, C, H, W).</span>
<span class="sd">            y (torch.Tensor): Target labels (0 or 1) for each sample.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Grad-CAM heatmaps normalized to [0, 1] for each input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Perform backward pass</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="c1"># Compute GradCAM</span>
        <span class="n">pooled_gradients</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradients</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">pooled_gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">gradcam</span><span class="p">)</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">gradcam</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="p">(</span><span class="n">gradcam</span> <span class="o">-</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">gradcam</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">gradcam</span></div>


<div class="viewcode-block" id="GradCAMGenerator.compute_gradcam_and_predictions">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.compute_gradcam_and_predictions">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradcam_and_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Grad-CAM heatmaps and class predictions for a batch.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input tensor of shape (N, C, H, W).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[torch.Tensor, torch.Tensor]:</span>
<span class="sd">                - Grad-CAM heatmaps for each sample.</span>
<span class="sd">                - Predicted class labels (0 or 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass to get predictions (logits)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Get predicted class (0 or 1 for binary classification)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Compute gradcam maps</span>
        <span class="n">gradcam_maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">gradcam_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_gradcam_maps</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">gradcam_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gradcam_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">gradcam_maps</span><span class="p">),</span> <span class="n">predictions</span></div>


<div class="viewcode-block" id="GradCAMGenerator.plot_activation_grid">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.plot_activation_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_activation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gradcam</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">overlay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a grid of input images overlaid with Grad-CAM heatmaps.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (torch.Tensor): Input image batch (N, C, H, W).</span>
<span class="sd">            gradcam (torch.Tensor): Grad-CAM heatmaps (N, H, W).</span>
<span class="sd">            predictions (torch.Tensor): Predicted class labels.</span>
<span class="sd">            overlay (bool): Whether to overlay Grad-CAM on input images.</span>
<span class="sd">            normalize (bool): Whether to normalize image intensities by percentiles.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.figure.Figure: The generated grid figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">]</span>
            <span class="n">gradcam_map</span> <span class="o">=</span> <span class="n">gradcam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

            <span class="c1"># Normalize image channels to 2nd and 98th percentiles</span>
            <span class="k">if</span> <span class="n">overlay</span><span class="p">:</span>
                <span class="n">img_np</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">img_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile_normalize</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gradcam_map</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="c1">#ax.imshow(X[i].permute(1, 2, 0).detach().cpu().numpy())  # Original image</span>
            <span class="c1">#ax.imshow(gradcam_map, cmap=&#39;jet&#39;, alpha=0.5)  # Overlay the gradcam map</span>

            <span class="c1"># Add class label in the top-left corner</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span>
                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round,pad=0.2&#39;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    
<div class="viewcode-block" id="GradCAMGenerator.percentile_normalize">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAMGenerator.percentile_normalize">[docs]</a>
    <span class="k">def</span> <span class="nf">percentile_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">lower_percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize each channel of the input image to the specified percentiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (np.ndarray): Image array (H, W, C).</span>
<span class="sd">            lower_percentile (int): Lower clipping percentile.</span>
<span class="sd">            upper_percentile (int): Upper clipping percentile.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Percentile-normalized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>  <span class="c1"># Iterate over each channel</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">lower_percentile</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">upper_percentile</span><span class="p">)</span>
            <span class="n">img_normalized</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_normalized</span></div>
</div>


<div class="viewcode-block" id="preprocess_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_image">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses an image for input into a machine learning model.</span>
<span class="sd">    Args:</span>
<span class="sd">        image_path (str): The file path to the image to be processed.</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the image using </span>
<span class="sd">            standard ImageNet mean and standard deviation. Defaults to True.</span>
<span class="sd">        image_size (int, optional): The size to which the image will be resized </span>
<span class="sd">            (both width and height). Defaults to 224.</span>
<span class="sd">        channels (list, optional): A list of channel indices to process. </span>
<span class="sd">            Defaults to [1, 2, 3].</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - image (PIL.Image.Image): The original image loaded as a PIL Image.</span>
<span class="sd">            - input_tensor (torch.Tensor): The preprocessed image as a tensor, </span>
<span class="sd">              ready for input into a model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">preprocess</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
    <span class="p">])</span>
    
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span> <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">])(</span><span class="n">input_tensor</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">input_tensor</span></div>


<div class="viewcode-block" id="class_visualization">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.class_visualization">[docs]</a>
<span class="k">def</span> <span class="nf">class_visualization</span><span class="p">(</span><span class="n">target_y</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">img_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">l2_reg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blur_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_jitter</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">show_every</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="s1">&#39;pc&#39;</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">class_visualization</span><span class="p">(</span><span class="n">target_y</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">img_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">l2_reg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blur_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_jitter</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">show_every</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">class_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="s1">&#39;pc&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a class visualization for a given target class using gradient ascent.</span>
<span class="sd">        Args:</span>
<span class="sd">            target_y (int): The target class index for which the visualization is generated.</span>
<span class="sd">            model_path (str): Path to the pre-trained model file.</span>
<span class="sd">            dtype (torch.dtype): Data type for the tensors (e.g., torch.FloatTensor or torch.cuda.FloatTensor).</span>
<span class="sd">            img_size (int, optional): Size of the square input image. Default is 224.</span>
<span class="sd">            channels (list, optional): List of channel indices to use in the input image. Default is [0, 1, 2].</span>
<span class="sd">            l2_reg (float, optional): L2 regularization strength to prevent overfitting. Default is 1e-3.</span>
<span class="sd">            learning_rate (float, optional): Learning rate for gradient ascent. Default is 25.</span>
<span class="sd">            num_iterations (int, optional): Number of iterations for gradient ascent. Default is 100.</span>
<span class="sd">            blur_every (int, optional): Frequency (in iterations) to apply Gaussian blur as a regularizer. Default is 10.</span>
<span class="sd">            max_jitter (int, optional): Maximum pixel jitter for random image translation. Default is 16.</span>
<span class="sd">            show_every (int, optional): Frequency (in iterations) to display the intermediate visualization. Default is 25.</span>
<span class="sd">            class_names (list, optional): List of class names corresponding to the target indices. Default is [&#39;nc&#39;, &#39;pc&#39;].</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The final deprocessed image as a NumPy array.</span>
<span class="sd">        Notes:</span>
<span class="sd">            - The function performs gradient ascent on the input image to maximize the score of the target class.</span>
<span class="sd">            - Regularization techniques such as L2 regularization, clamping, and Gaussian blur are applied to improve visualization quality.</span>
<span class="sd">            - The function assumes the model is compatible with the input image size and channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">jitter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">):</span>
        <span class="c1"># Randomly jitter the image</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">oy</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blur_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Apply Gaussian blur to the image</span>
        <span class="n">img_np</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">img_np</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">img_np</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">img</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">deprocess</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">):</span>
        <span class="c1"># Convert the tensor image to a numpy array for visualization</span>
        <span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">img_tensor</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    
    <span class="c1"># Assuming these are defined somewhere in your codebase</span>
    <span class="n">SQUEEZENET_MEAN</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
    <span class="n">SQUEEZENET_STD</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
    
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">FloatTensor</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span>
    <span class="n">len_chans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Randomly initialize the image as a PyTorch Tensor, and make it requires gradient.</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_chans</span><span class="p">,</span> <span class="n">img_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
        <span class="c1"># Randomly jitter the image a bit; this gives slightly nicer results</span>
        <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_jitter</span><span class="p">),</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_jitter</span><span class="p">)</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">jitter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">))</span>

        <span class="c1"># Forward pass</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">target_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target_score</span> <span class="o">=</span> <span class="o">-</span><span class="n">score</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_score</span> <span class="o">=</span> <span class="n">score</span>

        <span class="c1"># Add regularization</span>
        <span class="n">target_score</span> <span class="o">=</span> <span class="n">target_score</span> <span class="o">-</span> <span class="n">l2_reg</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="c1"># Backward pass</span>
        <span class="n">target_score</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># Gradient ascent step</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">img</span> <span class="o">+=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">grad</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

        <span class="c1"># Undo the random jitter</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">jitter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="n">ox</span><span class="p">,</span> <span class="o">-</span><span class="n">oy</span><span class="p">))</span>

        <span class="c1"># As regularizer, clamp and periodically blur the image</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">/</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">lo</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">hi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">%</span> <span class="n">blur_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blur_image</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        
        <span class="c1"># Periodically show the image</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">show_every</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">==</span> <span class="n">num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">deprocess</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()))</span>
            <span class="n">class_name</span> <span class="o">=</span> <span class="n">class_names</span><span class="p">[</span><span class="n">target_y</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">Iteration </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">deprocess</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span></div>


<div class="viewcode-block" id="get_submodules">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_submodules">[docs]</a>
<span class="k">def</span> <span class="nf">get_submodules</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively retrieves the names of all submodules in a given model.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The model whose submodules are to be retrieved.</span>
<span class="sd">        prefix (str, optional): A prefix to prepend to the names of the submodules. </span>
<span class="sd">            Defaults to an empty string.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of str: A list of strings representing the full names of all submodules </span>
<span class="sd">        in the model, including nested submodules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">submodules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
        <span class="n">full_name</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">submodules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_name</span><span class="p">)</span>
        <span class="n">submodules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_submodules</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">full_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">submodules</span></div>


<div class="viewcode-block" id="GradCAM">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM">[docs]</a>
<span class="k">class</span> <span class="nc">GradCAM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Grad-CAM (Gradient-weighted Class Activation Mapping) for a given model and target layer(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GradCAM object.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (nn.Module): The model for which Grad-CAM will be computed.</span>
<span class="sd">            target_layers (list of str): Names of layers to register hooks on.</span>
<span class="sd">            use_cuda (bool): Whether to use CUDA (GPU) for computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GradCAM.model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.model">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span></div>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<div class="viewcode-block" id="GradCAM.target_layers">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.target_layers">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layers</span> <span class="o">=</span> <span class="n">target_layers</span></div>

<div class="viewcode-block" id="GradCAM.cuda">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.cuda">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span> <span class="o">=</span> <span class="n">use_cuda</span></div>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<div class="viewcode-block" id="GradCAM.forward">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run a forward pass through the model.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (torch.Tensor): Input tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Model output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span></div>


<div class="viewcode-block" id="GradCAM.__call__">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.GradCAM.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Grad-CAM heatmap for an input image.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (1, C, H, W).</span>
<span class="sd">            index (int or None): Class index to compute gradients for. If None, uses the predicted class.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Normalized Grad-CAM heatmap of shape (H, W).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_layers</span><span class="p">:</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">hook</span><span class="p">))</span>

        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">one_hot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">one_hot</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="n">one_hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">one_hot</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">one_hot</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">grads_val</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grads_val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">cam</span> <span class="o">+=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">cam</span></div>
</div>


<div class="viewcode-block" id="show_cam_on_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.show_cam_on_image">[docs]</a>
<span class="k">def</span> <span class="nf">show_cam_on_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overlay a heatmap generated from a mask onto an image.</span>

<span class="sd">    This function applies a color map to the mask, combines it with the input</span>
<span class="sd">    image, and normalizes the result to create a visually interpretable</span>
<span class="sd">    representation of the mask overlaid on the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (numpy.ndarray): The input image as a NumPy array with pixel values</span>
<span class="sd">            normalized between 0 and 1.</span>
<span class="sd">        mask (numpy.ndarray): The mask to overlay on the image, with values</span>
<span class="sd">            normalized between 0 and 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The resulting image with the heatmap overlay, as a</span>
<span class="sd">        NumPy array with pixel values in the range [0, 255].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">heatmap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">applyColorMap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">mask</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLORMAP_JET</span><span class="p">)</span>
    <span class="n">heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">cam</span> <span class="o">=</span> <span class="n">heatmap</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">cam</span><span class="p">)</span></div>


<div class="viewcode-block" id="recommend_target_layers">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.recommend_target_layers">[docs]</a>
<span class="k">def</span> <span class="nf">recommend_target_layers</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies and recommends target layers in a given model for further processing.</span>

<span class="sd">    This function iterates through all the modules in the provided model and collects</span>
<span class="sd">    the names of all 2D convolutional layers (`torch.nn.Conv2d`). It then recommends</span>
<span class="sd">    the last convolutional layer as the primary target layer.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The neural network model to analyze.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - list: A list containing the name of the recommended target layer (last Conv2d layer).</span>
<span class="sd">            - list: A list of all Conv2d layer names found in the model.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no convolutional layers (`torch.nn.Conv2d`) are found in the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
            <span class="n">target_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># Choose the last conv layer as the recommended target layer</span>
    <span class="k">if</span> <span class="n">target_layers</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">target_layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">target_layers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No convolutional layers found in the model.&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="IntegratedGradients">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients">[docs]</a>
<span class="k">class</span> <span class="nc">IntegratedGradients</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Integrated Gradients for model interpretability.</span>

<span class="sd">    This class implements the Integrated Gradients method to attribute the prediction</span>
<span class="sd">    of a neural network to its input features. It approximates the integral of gradients</span>
<span class="sd">    along a straight path from a baseline to the input.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to interpret.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the IntegratedGradients instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (torch.nn.Module): A trained PyTorch model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<div class="viewcode-block" id="IntegratedGradients.model">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients.model">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span></div>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<div class="viewcode-block" id="IntegratedGradients.generate_integrated_gradients">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.IntegratedGradients.generate_integrated_gradients">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_integrated_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target_label_idx</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the integrated gradients for a given input and target class.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_tensor (torch.Tensor): The input tensor of shape (1, C, H, W) or similar.</span>
<span class="sd">            target_label_idx (int): Index of the target class for which gradients are computed.</span>
<span class="sd">            baseline (torch.Tensor, optional): Baseline tensor with the same shape as input. Defaults to zeros.</span>
<span class="sd">            num_steps (int, optional): Number of steps in the Riemann approximation of the integral. Defaults to 50.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Integrated gradients as a NumPy array with the same shape as `input_tensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Scale input and compute gradients</span>
        <span class="n">scaled_inputs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">baseline</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_steps</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_tensor</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">))</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scaled_input</span> <span class="ow">in</span> <span class="n">scaled_inputs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">scaled_input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_label_idx</span><span class="p">]</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">grads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_input</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="n">avg_grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grads</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">integrated_grads</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_tensor</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">baseline</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span> <span class="o">*</span> <span class="n">avg_grads</span>
        <span class="k">return</span> <span class="n">integrated_grads</span></div>
</div>


<div class="viewcode-block" id="get_db_paths">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_db_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_db_paths</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a list of database file paths based on the given source(s).</span>

<span class="sd">    This function takes a single source path or a list of source paths and </span>
<span class="sd">    constructs the corresponding paths to the &#39;measurements.db&#39; file located </span>
<span class="sd">    in the &#39;measurements&#39; subdirectory of each source.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str or list of str): A single source path as a string or a list </span>
<span class="sd">            of source paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of str: A list of file paths pointing to &#39;measurements/measurements.db&#39; </span>
<span class="sd">        for each source in the input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span>
    <span class="n">db_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;measurements/measurements.db&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">db_paths</span></div>


<div class="viewcode-block" id="get_sequencing_paths">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_sequencing_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_sequencing_paths</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a list of file paths pointing to sequencing data CSV files.</span>

<span class="sd">    This function takes a single source path or a list of source paths and </span>
<span class="sd">    constructs the full file paths to the &#39;sequencing/sequencing_data.csv&#39; </span>
<span class="sd">    file located within each source directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str or list of str): A single source directory path as a string </span>
<span class="sd">            or a list of source directory paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of str: A list of full file paths to the &#39;sequencing_data.csv&#39; </span>
<span class="sd">        files for each source directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span>
    <span class="n">seq_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;sequencing/sequencing_data.csv&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">seq_paths</span></div>


<div class="viewcode-block" id="load_image_paths">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.load_image_paths">[docs]</a>
<span class="k">def</span> <span class="nf">load_image_paths</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">visualize</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads image paths from a database table and optionally filters them based on a visualization keyword.</span>

<span class="sd">    Args:</span>
<span class="sd">        c (sqlite3.Cursor): A database cursor object used to execute SQL queries.</span>
<span class="sd">        visualize (str): A keyword to filter image paths. If provided, only rows where the &#39;png_path&#39; column</span>
<span class="sd">                         contains the keyword followed by &#39;_png&#39; will be included. If None or empty, no filtering</span>
<span class="sd">                         is applied.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame containing the image paths and other associated data from the &#39;png_list&#39; table.</span>
<span class="sd">                          The DataFrame is indexed by the &#39;prcfo&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SELECT * FROM png_list&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">columns_info</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PRAGMA table_info(png_list)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_info</span> <span class="ow">in</span> <span class="n">columns_info</span><span class="p">]</span>
    <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
        <span class="n">object_visualize</span> <span class="o">=</span> <span class="n">visualize</span> <span class="o">+</span> <span class="s1">&#39;_png&#39;</span>
        <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="p">[</span><span class="n">image_paths_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">object_visualize</span><span class="p">)]</span>
    <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;prcfo&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image_paths_df</span></div>


<div class="viewcode-block" id="merge_dataframes">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.merge_dataframes">[docs]</a>
<span class="k">def</span> <span class="nf">merge_dataframes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">image_paths_df</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges two pandas DataFrames on their indices and optionally displays the result.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pandas.DataFrame): The main DataFrame to be merged. It must have a column named &#39;prcfo&#39;,</span>
<span class="sd">                               which will be set as the index before merging.</span>
<span class="sd">        image_paths_df (pandas.DataFrame): The DataFrame containing image paths to be merged with `df`.</span>
<span class="sd">        verbose (bool): If True, the resulting merged DataFrame will be displayed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The merged DataFrame with the indices aligned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="remove_highly_correlated_columns_v1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_highly_correlated_columns_v1">[docs]</a>
<span class="k">def</span> <span class="nf">remove_highly_correlated_columns_v1</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes columns from a DataFrame that are highly correlated with other columns.</span>

<span class="sd">    This function calculates the correlation matrix of the given DataFrame, identifies</span>
<span class="sd">    columns with a correlation higher than the specified threshold, and removes them</span>
<span class="sd">    to reduce multicollinearity.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame containing the data.</span>
<span class="sd">        threshold (float): The correlation threshold above which columns are considered</span>
<span class="sd">            highly correlated and will be removed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame with highly correlated columns removed.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; data = {&#39;A&#39;: [1, 2, 3], &#39;B&#39;: [2, 4, 6], &#39;C&#39;: [7, 8, 9]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; remove_highly_correlated_columns_v1(df, threshold=0.9)</span>
<span class="sd">           A  C</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    <span class="n">upper_tri</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">upper_tri</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">upper_tri</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_columns">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.filter_columns">[docs]</a>
<span class="k">def</span> <span class="nf">filter_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">filter_by</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters the columns of a DataFrame based on a specified criterion.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame whose columns are to be filtered.</span>
<span class="sd">        filter_by (str): The criterion for filtering columns. If &#39;morphology&#39;, </span>
<span class="sd">                         columns containing &#39;channel&#39; in their names are excluded. </span>
<span class="sd">                         Otherwise, only columns containing the specified string </span>
<span class="sd">                         are included.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame containing only the filtered columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filter_by</span> <span class="o">!=</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
        <span class="n">cols_to_include</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">filter_by</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cols_to_include</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;channel&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cols_to_include</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="reduction_and_clustering">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.reduction_and_clustering">[docs]</a>
<span class="k">def</span> <span class="nf">reduction_and_clustering</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">reduction_method</span><span class="o">=</span><span class="s1">&#39;umap&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform dimensionality reduction and clustering on the given data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    numeric_data (np.ndarray): Numeric data for embedding and clustering.</span>
<span class="sd">    n_neighbors (int or float): Number of neighbors for UMAP or perplexity for t-SNE.</span>
<span class="sd">    min_dist (float): Minimum distance for UMAP.</span>
<span class="sd">    metric (str): Metric for UMAP and DBSCAN.</span>
<span class="sd">    eps (float): Epsilon for DBSCAN.</span>
<span class="sd">    min_samples (int): Minimum samples for DBSCAN or number of clusters for KMeans.</span>
<span class="sd">    clustering (str): Clustering method (&#39;DBSCAN&#39; or &#39;KMeans&#39;).</span>
<span class="sd">    reduction_method (str): Dimensionality reduction method (&#39;UMAP&#39; or &#39;tSNE&#39;).</span>
<span class="sd">    verbose (bool): Whether to print verbose output.</span>
<span class="sd">    embedding (np.ndarray, optional): Precomputed embedding. Default is None.</span>
<span class="sd">    return_model (bool): Whether to return the reducer model. Default is False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    tuple: embedding, labels (and optionally the reducer model)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fit&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;umap&#39;</span><span class="p">:</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span>
                                <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                <span class="n">n_epochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">init</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">,</span>
                                <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                                <span class="n">spread</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">set_op_mix_ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">local_connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">repulsion_strength</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">negative_sample_rate</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">transform_queue_size</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                                <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                <span class="n">metric_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">angular_rp_forest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">target_n_neighbors</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">target_metric</span><span class="o">=</span><span class="s1">&#39;categorical&#39;</span><span class="p">,</span>
                                <span class="n">target_metric_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">target_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                <span class="n">transform_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;tsne&#39;</span><span class="p">:</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">perplexity</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span>
                        <span class="n">early_exaggeration</span><span class="o">=</span><span class="mf">12.0</span><span class="p">,</span>
                        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
                        <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">n_iter_without_progress</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                        <span class="n">min_grad_norm</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
                        <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                        <span class="n">init</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;barnes_hut&#39;</span><span class="p">,</span>
                        <span class="n">angle</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported reduction method: </span><span class="si">{</span><span class="n">reduction_method</span><span class="si">}</span><span class="s2">. Supported methods are &#39;umap&#39; and &#39;tsne&#39;&quot;</span><span class="p">)</span>
        
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Trained and fit reducer&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">embedding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">model</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Fit data to reducer&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model is None. Please provide a model for transform.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="n">clustering_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">labels_</span> <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span> <span class="k">else</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Embedding shape: </span><span class="si">{</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">reducer</span></div>


<div class="viewcode-block" id="remove_noise">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_noise">[docs]</a>
<span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes noise from the given embedding and labels by filtering out elements</span>
<span class="sd">    where the corresponding label is -1.</span>

<span class="sd">    Args:</span>
<span class="sd">        embedding (numpy.ndarray): The embedding array, where each row corresponds</span>
<span class="sd">            to a data point.</span>
<span class="sd">        labels (numpy.ndarray): The array of labels corresponding to the embedding,</span>
<span class="sd">            where a label of -1 indicates noise.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - numpy.ndarray: The filtered embedding array with noise removed.</span>
<span class="sd">            - numpy.ndarray: The filtered labels array with noise removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_noise_indices</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">non_noise_indices</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">non_noise_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="plot_embedding">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_embedding">[docs]</a>
<span class="k">def</span> <span class="nf">plot_embedding</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">plot_images</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">dot_size</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a 2D embedding with optional images, clusters, and customization options.</span>

<span class="sd">    Args:</span>
<span class="sd">        embedding (np.ndarray): A 2D array of shape (n_samples, 2) representing the embedding coordinates.</span>
<span class="sd">        image_paths (list or None): A list of file paths to images corresponding to the data points, or None if no images are used.</span>
<span class="sd">        labels (np.ndarray): An array of cluster labels for each data point.</span>
<span class="sd">        image_nr (int): The number of images to display on the plot.</span>
<span class="sd">        img_zoom (float): The zoom factor for the displayed images.</span>
<span class="sd">        colors (list or None): A list of colors to use for clusters, or None to use default colors.</span>
<span class="sd">        plot_by_cluster (bool): Whether to plot images grouped by cluster.</span>
<span class="sd">        plot_outlines (bool): Whether to draw outlines around clusters.</span>
<span class="sd">        plot_points (bool): Whether to plot individual data points.</span>
<span class="sd">        plot_images (bool): Whether to overlay images on the embedding.</span>
<span class="sd">        smooth_lines (bool): Whether to draw smooth lines between cluster centers.</span>
<span class="sd">        black_background (bool): Whether to use a black background for the plot.</span>
<span class="sd">        figuresize (tuple): The size of the figure in inches (width, height).</span>
<span class="sd">        dot_size (float): The size of the dots representing data points.</span>
<span class="sd">        remove_image_canvas (bool): Whether to remove the canvas around the images.</span>
<span class="sd">        verbose (bool): Whether to print verbose output during the plotting process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure: The generated plot as a Matplotlib figure object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="c1">#num_clusters = len(unique_labels[unique_labels != 0])</span>
    <span class="n">colors</span><span class="p">,</span> <span class="n">label_to_color_index</span> <span class="o">=</span> <span class="n">assign_colors</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
    <span class="n">cluster_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_plot</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">)</span>
    <span class="n">plot_clusters</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">dot_size</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">image_paths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_images</span><span class="p">:</span>
        <span class="n">plot_umap_images</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="generate_colors">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.generate_colors">[docs]</a>
<span class="k">def</span> <span class="nf">generate_colors</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">,</span> <span class="n">black_background</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a set of RGBA colors for visualization purposes.</span>

<span class="sd">    This function generates a list of random RGBA colors, appends specific predefined colors,</span>
<span class="sd">    and optionally includes a black background color.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_clusters (int): The number of clusters for which colors need to be generated.</span>
<span class="sd">                            Additional random colors will be generated beyond the predefined ones.</span>
<span class="sd">        black_background (bool): If True, a black background color ([0, 0, 0, 1]) will be included</span>
<span class="sd">                                 at the beginning of the color list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A 2D array of shape (num_colors, 4), where each row represents an RGBA color.</span>
<span class="sd">                       The first dimension corresponds to the total number of colors generated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">random_colors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">specific_colors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">255</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">specific_colors</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">specific_colors</span><span class="p">):]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">black_background</span><span class="p">:</span>
        <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">random_colors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">random_colors</span></div>


<div class="viewcode-block" id="assign_colors">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.assign_colors">[docs]</a>
<span class="k">def</span> <span class="nf">assign_colors</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns colors to unique labels and creates a mapping from labels to color indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        unique_labels (list or iterable): A collection of unique labels for which colors need to be assigned.</span>
<span class="sd">        random_colors (numpy.ndarray or list): An array or list of RGB color values, where each color is represented </span>
<span class="sd">            as a triplet of integers in the range [0, 255].</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - colors (list of tuple): A list of RGB color tuples in the original [0, 255] range.</span>
<span class="sd">            - label_to_color_index (dict): A dictionary mapping each unique label to its corresponding color index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normalized_colors</span> <span class="o">=</span> <span class="n">random_colors</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">colors_img</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">normalized_colors</span><span class="p">]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">random_colors</span><span class="p">]</span>
    <span class="n">label_to_color_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">colors</span><span class="p">,</span> <span class="n">label_to_color_index</span></div>


<div class="viewcode-block" id="setup_plot">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.setup_plot">[docs]</a>
<span class="k">def</span> <span class="nf">setup_plot</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets up a matplotlib plot with specified figure size and background color.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        figuresize (float): The size of the figure in inches (used for both width and height).</span>
<span class="sd">        black_background (bool): If True, sets the plot to have a black background with white text and labels.</span>
<span class="sd">                                 If False, sets the plot to have a white background with black text and labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the figure (`matplotlib.figure.Figure`) and axes (`matplotlib.axes._axes.Axes`) objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">black_background</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;figure.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;text.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;xtick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;ytick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.labelcolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;figure.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;text.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;xtick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;ytick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.labelcolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">})</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="plot_clusters">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_clusters">[docs]</a>
<span class="k">def</span> <span class="nf">plot_clusters</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dot_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots clusters on a 2D embedding using matplotlib.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): The matplotlib Axes object to plot on.</span>
<span class="sd">        embedding (numpy.ndarray): A 2D array of shape (n_samples, 2) representing the embedding coordinates.</span>
<span class="sd">        labels (numpy.ndarray): An array of cluster labels for each point in the embedding.</span>
<span class="sd">        colors (list): A list of colors corresponding to each cluster.</span>
<span class="sd">        cluster_centers (numpy.ndarray): A 2D array of shape (n_clusters, 2) representing the coordinates of cluster centers.</span>
<span class="sd">        plot_outlines (bool): Whether to plot the outlines of clusters using convex hulls or smoothed lines.</span>
<span class="sd">        plot_points (bool): Whether to plot individual points in the clusters.</span>
<span class="sd">        smooth_lines (bool): Whether to use smoothed lines for cluster outlines instead of convex hulls.</span>
<span class="sd">        figuresize (int, optional): The size of the figure. Defaults to 10.</span>
<span class="sd">        dot_size (int, optional): The size of the points in the scatter plot. Defaults to 50.</span>
<span class="sd">        verbose (bool, optional): Whether to print additional information for debugging. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>

<span class="sd">    Notes:</span>
<span class="sd">        - This function assumes that the embedding is 2D.</span>
<span class="sd">        - Cluster labels should be integers, with -1 typically representing noise.</span>
<span class="sd">        - The function uses matplotlib for plotting and assumes that the required libraries (e.g., numpy, matplotlib) are imported.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">):</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">smooth_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">x_smooth</span><span class="p">,</span> <span class="n">y_smooth</span> <span class="o">=</span> <span class="n">smooth_hull_lines</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plot_outlines</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_smooth</span><span class="p">,</span> <span class="n">y_smooth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">plot_outlines</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_points</span><span class="p">:</span>
            <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">dot_size</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cluster_label</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;Noise&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">dot_size</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cluster_label</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;Noise&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;UMAP Dimension 1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;UMAP Dimension 2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span></div>


<div class="viewcode-block" id="plot_umap_images">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_umap_images">[docs]</a>
<span class="k">def</span> <span class="nf">plot_umap_images</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots UMAP embeddings with associated images on a given matplotlib axis.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ax (matplotlib.axes.Axes): The matplotlib axis on which to plot the images.</span>
<span class="sd">        image_paths (list of str): List of file paths to the images to be plotted.</span>
<span class="sd">        embedding (numpy.ndarray): 2D array of UMAP embeddings with shape (n_samples, 2).</span>
<span class="sd">        labels (numpy.ndarray): Array of cluster labels for each embedding point.</span>
<span class="sd">        image_nr (int): Number of images to plot.</span>
<span class="sd">        img_zoom (float): Zoom factor for the images.</span>
<span class="sd">        colors (list): List of colors for each cluster.</span>
<span class="sd">        plot_by_cluster (bool): If True, plot images grouped by cluster; otherwise, plot randomly sampled images.</span>
<span class="sd">        remove_image_canvas (bool): If True, remove the image canvas (background) when plotting.</span>
<span class="sd">        verbose (bool): If True, print additional information during execution.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_by_cluster</span><span class="p">:</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">plot_images_by_cluster</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_indices</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">embedding</span><span class="p">)),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_images_by_cluster">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_images_by_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">plot_images_by_cluster</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_indices</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots images on a given axis based on their cluster assignments and embeddings.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): The matplotlib axis on which to plot the images.</span>
<span class="sd">        image_paths (list of str): List of file paths to the images to be plotted.</span>
<span class="sd">        embedding (array-like): 2D array of shape (n_samples, 2) containing the x and y coordinates for each image.</span>
<span class="sd">        labels (array-like): Array of cluster labels for each image. -1 indicates noise or unclustered points.</span>
<span class="sd">        image_nr (int): Maximum number of images to display per cluster.</span>
<span class="sd">        img_zoom (float): Zoom factor for the displayed images.</span>
<span class="sd">        colors (list of str): List of colors corresponding to each cluster.</span>
<span class="sd">        cluster_indices (dict): Dictionary mapping cluster labels to lists of indices of images in each cluster.</span>
<span class="sd">        remove_image_canvas (bool): If True, removes the canvas (border) around the plotted images.</span>
<span class="sd">        verbose (bool): If True, prints additional information during execution.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">colors</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">image_nr</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_image">[docs]</a>
<span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots an image on a given matplotlib axis at specified coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): The axis on which to plot the image.</span>
<span class="sd">        x (float): The x-coordinate where the image will be placed.</span>
<span class="sd">        y (float): The y-coordinate where the image will be placed.</span>
<span class="sd">        img (numpy.ndarray or array-like): The image data to be plotted.</span>
<span class="sd">        img_zoom (float): The zoom factor for the image.</span>
<span class="sd">        remove_image_canvas (bool, optional): If True, removes the canvas </span>
<span class="sd">            (e.g., padding or borders) from the image before plotting. </span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">remove_image_canvas</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">remove_canvas</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">imagebox</span> <span class="o">=</span> <span class="n">OffsetImage</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">img_zoom</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">AnnotationBbox</span><span class="p">(</span><span class="n">imagebox</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_canvas">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_canvas">[docs]</a>
<span class="k">def</span> <span class="nf">remove_canvas</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts an image to a normalized RGBA format by adding an alpha channel.</span>

<span class="sd">    This function processes images in either grayscale (&#39;L&#39;, &#39;I&#39;) or RGB (&#39;RGB&#39;) mode.</span>
<span class="sd">    For grayscale images, the pixel values are normalized, and an alpha channel is</span>
<span class="sd">    created based on non-zero pixel values. For RGB images, the pixel values are</span>
<span class="sd">    normalized to the range [0, 1], and an alpha channel is created based on the</span>
<span class="sd">    presence of non-zero pixel values across all channels.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (PIL.Image.Image): The input image to process. Must be in &#39;L&#39;, &#39;I&#39;, or &#39;RGB&#39; mode.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A 4-channel RGBA image as a NumPy array, where the first three</span>
<span class="sd">        channels represent the normalized RGB values, and the fourth channel represents</span>
<span class="sd">        the alpha channel.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input image mode is not &#39;L&#39;, &#39;I&#39;, or &#39;RGB&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">]:</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">img_data</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img_data</span><span class="p">)</span>
        <span class="n">alpha_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">img_data_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">img_data</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">img_data_with_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_data_rgb</span><span class="p">,</span> <span class="n">alpha_channel</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RGB&#39;</span><span class="p">:</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">img_data</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="n">alpha_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">img_data_with_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_data</span><span class="p">,</span> <span class="n">alpha_channel</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported image mode: </span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_data_with_alpha</span></div>


<div class="viewcode-block" id="plot_clusters_grid">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_clusters_grid">[docs]</a>
<span class="k">def</span> <span class="nf">plot_clusters_grid</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a grid of images for each cluster based on the provided labels and embeddings.</span>

<span class="sd">    Args:</span>
<span class="sd">        embedding (np.ndarray): The embedding of the data points, typically used for visualization.</span>
<span class="sd">        labels (np.ndarray): Array of cluster labels for each data point. A label of -1 indicates noise or outliers.</span>
<span class="sd">        image_nr (int): The maximum number of images to display per cluster.</span>
<span class="sd">        image_paths (list of str): List of file paths to the images corresponding to the data points.</span>
<span class="sd">        colors (list of str): List of colors to use for each cluster in the grid.</span>
<span class="sd">        figuresize (tuple): Size of the figure to create (width, height).</span>
<span class="sd">        black_background (bool): Whether to use a black background for the grid.</span>
<span class="sd">        verbose (bool): If True, prints additional information during execution.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure: The generated figure containing the grid of cluster images.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If no clusters are found (i.e., all labels are -1), the function prints a message and returns None.</span>
<span class="sd">        - Random sampling is used if the number of images in a cluster exceeds `image_nr`.</span>
<span class="sd">        - The function relies on an external `plot_grid` function to create the grid visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">num_clusters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No clusters found.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">cluster_images</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">image_nr</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">img_path</span> <span class="o">=</span> <span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img_array</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
            <span class="n">cluster_images</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_grid</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="plot_grid">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.plot_grid">[docs]</a>
<span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a grid of images grouped by clusters with customizable figure size, background, and labels.</span>
<span class="sd">    Args:</span>
<span class="sd">        cluster_images (dict): A dictionary where keys are cluster labels and values are lists of images </span>
<span class="sd">                               belonging to each cluster.</span>
<span class="sd">        colors (list): A list of RGB tuples representing the colors for each cluster.</span>
<span class="sd">        figuresize (float): The base size of the figure. The actual size is adjusted based on the number of clusters.</span>
<span class="sd">        black_background (bool): If True, the background of the plot will be black; otherwise, it will be white.</span>
<span class="sd">        verbose (bool): If True, prints additional information about cluster labels and indices.</span>
<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure: The generated figure containing the grid of images.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function dynamically adjusts the grid size for each cluster based on the number of images.</span>
<span class="sd">        - Cluster labels are displayed beside the grid with corresponding colors.</span>
<span class="sd">        - A maximum figure size is enforced to prevent excessively large plots.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">)</span>
    <span class="n">max_figsize</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># Set a maximum figure size</span>
    <span class="k">if</span> <span class="n">figuresize</span> <span class="o">*</span> <span class="n">num_clusters</span> <span class="o">&gt;</span> <span class="n">max_figsize</span><span class="p">:</span>
        <span class="n">figuresize</span> <span class="o">=</span> <span class="n">max_figsize</span> <span class="o">/</span> <span class="n">num_clusters</span>

    <span class="n">grid_fig</span><span class="p">,</span> <span class="n">grid_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">),</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;wspace&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;hspace&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">num_clusters</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">grid_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_axes</span><span class="p">]</span>  <span class="c1"># Ensure grid_axes is always iterable</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">axes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">grid_axes</span><span class="p">):</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">cluster_images</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span>
        <span class="n">num_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">grid_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_images</span><span class="p">)))</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">/</span> <span class="n">grid_size</span>
        <span class="n">whitespace</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">grid_size</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lable: </span><span class="si">{</span><span class="n">cluster_label</span><span class="si">}</span><span class="s1"> index: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span>

        <span class="n">axes</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="n">grid_size</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">grid_size</span>
            <span class="n">x_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="n">col</span> <span class="o">*</span> <span class="n">image_size</span>
            <span class="n">y_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span>
            <span class="n">ax_img</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">inset_axes</span><span class="p">([</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    
    <span class="c1"># Add cluster labels beside the UMAP plot</span>
    <span class="n">spacing_factor</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Adjust this value to control the spacing between labels</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">colors</span><span class="p">)):</span>
        <span class="n">label_y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spacing_factor</span> <span class="o">/</span> <span class="n">num_clusters</span><span class="p">)</span>  <span class="c1"># Adjust y position for each label</span>
        <span class="n">grid_fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">black_background</span> <span class="k">else</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">grid_fig</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_y</span> <span class="o">-</span> <span class="mf">0.02</span><span class="p">),</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">grid_fig</span><span class="o">.</span><span class="n">transFigure</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">grid_fig</span></div>


<div class="viewcode-block" id="generate_path_list_from_db">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.generate_path_list_from_db">[docs]</a>
<span class="k">def</span> <span class="nf">generate_path_list_from_db</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">file_metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list of file paths from a database based on the provided metadata.</span>
<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The file path to the SQLite database.</span>
<span class="sd">        file_metadata (str | list[str] | None): Metadata to filter the file paths. </span>
<span class="sd">            - If a string is provided, it filters paths containing the string.</span>
<span class="sd">            - If a list of strings is provided, it filters paths containing any of the strings.</span>
<span class="sd">            - If None or empty, retrieves all file paths.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list[str]: A list of file paths retrieved from the database. </span>
<span class="sd">                   Returns an empty list if no paths match the criteria.</span>
<span class="sd">                   Returns None if a database error or other exception occurs.</span>
<span class="sd">    Raises:</span>
<span class="sd">        sqlite3.Error: If an error occurs while interacting with the SQLite database.</span>
<span class="sd">        Exception: For any other unexpected errors.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function retrieves paths from the `png_list` table in the database.</span>
<span class="sd">        - The `png_path` column is used to filter and retrieve the file paths.</span>
<span class="sd">        - Results are fetched in batches of 1000 rows for efficiency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_paths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Connect to the database and retrieve the image paths</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading DataBase: </span><span class="si">{</span><span class="n">db_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">file_metadata</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_metadata</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="c1"># If file_metadata is a single string</span>
                    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT png_path FROM png_list WHERE png_path LIKE ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">file_metadata</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_metadata</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># If file_metadata is a list of strings</span>
                    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;SELECT png_path FROM png_list WHERE &quot;</span> <span class="o">+</span> <span class="s2">&quot; OR &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="s2">&quot;png_path LIKE ?&quot;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">file_metadata</span><span class="p">])</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">meta</span><span class="si">}</span><span class="s2">%&quot;</span> <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">file_metadata</span><span class="p">]</span>
                    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If file_metadata is None or empty</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT png_path FROM png_list&quot;</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchmany</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">all_paths</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">])</span>

    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Database error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">return</span> <span class="n">all_paths</span></div>


<div class="viewcode-block" id="correct_paths">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.correct_paths">[docs]</a>
<span class="k">def</span> <span class="nf">correct_paths</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">base_path</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts file paths in a DataFrame or a list to ensure they are correctly </span>
<span class="sd">    prefixed with the specified base path and folder.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    df : pandas.DataFrame or list</span>
<span class="sd">        The input data containing file paths. If a DataFrame is provided, it </span>
<span class="sd">        must contain a column named &#39;png_path&#39; with the file paths. If a list </span>
<span class="sd">        is provided, it should directly contain the file paths.</span>
<span class="sd">    base_path : str</span>
<span class="sd">        The base directory path to prepend to the file paths if they do not </span>
<span class="sd">        already contain it.</span>
<span class="sd">    folder : str, optional</span>
<span class="sd">        The folder name to include in the adjusted paths (default is &#39;data&#39;).</span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    tuple or list</span>
<span class="sd">        If `df` is a DataFrame, returns a tuple containing the updated </span>
<span class="sd">        DataFrame and a list of adjusted file paths. If `df` is a list, </span>
<span class="sd">        returns only the list of adjusted file paths.</span>
<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    - If the input is a DataFrame and the &#39;png_path&#39; column is missing, the </span>
<span class="sd">      function prints a message and returns the original DataFrame and None.</span>
<span class="sd">    - Paths that already contain the base path are left unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>

        <span class="k">if</span> <span class="s1">&#39;png_path&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No &#39;png_path&#39; column found in the dataframe.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_paths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">image_paths</span> <span class="o">=</span> <span class="n">df</span>
    
    <span class="n">adjusted_image_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">base_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;/</span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s1">/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_image_paths</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">adjusted_image_paths</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adjusted_image_paths</span></div>


<div class="viewcode-block" id="delete_folder">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.delete_folder">[docs]</a>
<span class="k">def</span> <span class="nf">delete_folder</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deletes a folder and all of its contents, including subdirectories and files.</span>

<span class="sd">    Args:</span>
<span class="sd">        folder_path (str): The path to the folder to be deleted.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - If the specified folder exists and is a directory, it recursively deletes all files </span>
<span class="sd">          and subdirectories within it, and then removes the folder itself.</span>
<span class="sd">        - If the folder does not exist or is not a directory, a message is printed indicating this.</span>

<span class="sd">    Prints:</span>
<span class="sd">        - A confirmation message if the folder is successfully deleted.</span>
<span class="sd">        - An error message if the folder does not exist or is not a directory.</span>

<span class="sd">    Example:</span>
<span class="sd">        delete_folder(&#39;/path/to/folder&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39; has been deleted.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39; does not exist or is not a directory.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="measure_test_mode">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.measure_test_mode">[docs]</a>
<span class="k">def</span> <span class="nf">measure_test_mode</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts the source folder in the settings dictionary for test mode.</span>

<span class="sd">    If `test_mode` is enabled in the `settings` dictionary, this function:</span>
<span class="sd">    - Checks if the current source folder (`settings[&#39;src&#39;]`) is not already set to &#39;test&#39;.</span>
<span class="sd">    - Selects a random subset of files from the source folder based on `settings[&#39;test_nr&#39;]`.</span>
<span class="sd">    - Copies the selected files into a new &#39;test/merged&#39; directory.</span>
<span class="sd">    - Updates the `settings[&#39;src&#39;]` to point to the new &#39;test/merged&#39; directory.</span>
<span class="sd">    - Prints a message indicating the change in the source folder.</span>

<span class="sd">    If the source folder is already set to &#39;test&#39;, it simply prints a message confirming the test mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): A dictionary containing configuration settings. </span>
<span class="sd">                        Expected keys:</span>
<span class="sd">                        - &#39;test_mode&#39; (bool): Whether test mode is enabled.</span>
<span class="sd">                        - &#39;src&#39; (str): Path to the source folder.</span>
<span class="sd">                        - &#39;test_nr&#39; (int): Number of files to select for test mode.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated settings dictionary with the modified source folder if test mode is enabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;test_mode&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;test&#39;</span><span class="p">:</span>
            <span class="n">all_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">])</span>
            <span class="n">random_files</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_files</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;test_nr&#39;</span><span class="p">])</span>

            <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]),</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;merged&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                <span class="n">delete_folder</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">random_files</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="n">file</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">file</span><span class="p">))</span>

            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Changed source folder to </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s1"> for test mode&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Test mode enabled, using source folder </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;src&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">settings</span></div>


<div class="viewcode-block" id="preprocess_data">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.preprocess_data">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">filter_by</span><span class="p">,</span> <span class="n">remove_highly_correlated</span><span class="p">,</span> <span class="n">log_data</span><span class="p">,</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">column_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses the given dataframe by applying filtering, removing highly correlated columns,</span>
<span class="sd">    applying log transformation, filling NaN values, and scaling the numeric data.</span>

<span class="sd">    Args:</span>
<span class="sd">    df (pandas.DataFrame): The input dataframe.</span>
<span class="sd">    filter_by (str or None): The channel of interest to filter the dataframe by.</span>
<span class="sd">    remove_highly_correlated (bool or float): Whether to remove highly correlated columns.</span>
<span class="sd">    If a float is provided, it represents the correlation threshold.</span>
<span class="sd">    log_data (bool): Whether to apply log transformation to the numeric data.</span>
<span class="sd">    exclude (list or None): List of features to exclude from the filtering process.</span>
<span class="sd">    verbose (bool): Whether to print verbose output during preprocessing.</span>

<span class="sd">    Returns:</span>
<span class="sd">    numpy.ndarray: The preprocessed numeric data.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If no numeric columns are available after filtering.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Apply filtering based on the `filter_by` parameter</span>
    <span class="k">if</span> <span class="n">filter_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">filter_dataframe_features</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">column_list</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_list</span><span class="p">]</span>
    
    <span class="c1"># Select numerical features</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">])</span>
    
    <span class="c1"># Check if numeric_data is empty</span>
    <span class="k">if</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No numeric columns available after filtering. Please check the filter_by and exclude parameters.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Remove highly correlated columns</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_highly_correlated</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remove_highly_correlated</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">remove_highly_correlated</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
    
    <span class="c1"># Apply log transformation</span>
    <span class="k">if</span> <span class="n">log_data</span><span class="p">:</span>
        <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numeric_data</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="c1"># Fill NaN values with the column mean</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">numeric_data</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    
    <span class="c1"># Scale the numeric data</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">numeric_data</span></div>


<div class="viewcode-block" id="remove_low_variance_columns">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_low_variance_columns">[docs]</a>
<span class="k">def</span> <span class="nf">remove_low_variance_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes columns from the dataframe that have low variance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The DataFrame containing the data.</span>
<span class="sd">    threshold (float): The variance threshold below which columns will be removed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame: The DataFrame with low variance columns removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">numerical_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">low_variance_cols</span> <span class="o">=</span> <span class="n">numerical_cols</span><span class="o">.</span><span class="n">var</span><span class="p">()[</span><span class="n">numerical_cols</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns due to low variance: </span><span class="si">{</span><span class="n">low_variance_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">low_variance_cols</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="remove_highly_correlated_columns">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_highly_correlated_columns">[docs]</a>
<span class="k">def</span> <span class="nf">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes columns from the dataframe that are highly correlated with one another.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The DataFrame containing the data.</span>
<span class="sd">    threshold (float): The correlation threshold above which columns will be removed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame: The DataFrame with highly correlated columns removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numerical_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">numerical_cols</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    
    <span class="c1"># Upper triangle of the correlation matrix</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    
    <span class="c1"># Find columns with correlation greater than the threshold</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">upper</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns due to high correlation: </span><span class="si">{</span><span class="n">to_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">to_drop</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="filter_dataframe_features">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.filter_dataframe_features">[docs]</a>
<span class="k">def</span> <span class="nf">filter_dataframe_features</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_low_variance_features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_highly_correlated_features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the dataframe `df` based on the specified `channel_of_interest` and `exclude` parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - df (pandas.DataFrame): The input dataframe to be filtered.</span>
<span class="sd">    - channel_of_interest (str, int, list, None): The channel(s) of interest to filter the dataframe. If None, no filtering is applied. If &#39;morphology&#39;, only morphology features are included.If an integer, only the specified channel is included. If a list, only the specified channels are included.If a string, only the specified channel is included.</span>
<span class="sd">    - exclude (str, list, None): The feature(s) to exclude from the filtered dataframe. If None, no features are excluded. If a string, the specified feature is excluded.If a list, the specified features are excluded.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - filtered_df (pandas.DataFrame): The filtered dataframe based on the specified parameters.</span>
<span class="sd">    - features (list): The list of selected features after filtering.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">count_and_id_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;_id&#39;</span> <span class="ow">in</span> <span class="n">col</span> <span class="ow">or</span> <span class="s1">&#39;count&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;pathogen_pathogen&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pathogen_pathogen&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cell_cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cell_cell&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;nucleus_nucleus&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;nucleus_nucleus&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cytoplasm_cytoplasm&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cytoplasm_cytoplasm&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Columns to remove:&quot;</span><span class="p">,</span> <span class="n">count_and_id_columns</span><span class="p">)</span>
        
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">count_and_id_columns</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_of_interest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">drop_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;channel_1&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_2&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_3&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_4&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_of_interest</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_of_interest</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">feature_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature_string</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="o">==</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
            <span class="n">morphological_features</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;area_bbox&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;eccentricity&#39;</span><span class="p">,</span> <span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;euler_number&#39;</span><span class="p">,</span> <span class="s1">&#39;solidity&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_0&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_1&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_2&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_3&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_4&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_5&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_6&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_7&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_8&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_9&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_10&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_11&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_12&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_13&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_14&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_15&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_16&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_17&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_18&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_19&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_20&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_21&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_22&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_23&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_24&#39;</span><span class="p">,</span> <span class="s1">&#39;area_filled&#39;</span><span class="p">,</span> <span class="s1">&#39;convex_area&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent_diameter_area&#39;</span><span class="p">,</span> <span class="s1">&#39;feret_diameter_max&#39;</span><span class="p">]</span>
            <span class="n">morphological_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">base</span> <span class="ow">in</span> <span class="n">item</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">morphological_features</span><span class="p">)]</span>
            <span class="n">columns_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">morphological_columns</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">channel_of_interest</span> <span class="o">!=</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
            <span class="c1"># Remove entries from drop_columns that are also in feature_strings</span>
            <span class="n">drop_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">drop_columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_strings</span><span class="p">]</span>

            <span class="c1"># Remove columns from the DataFrame that contain any entry from drop_columns in the column name</span>
            <span class="n">columns_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">drop_col</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">for</span> <span class="n">drop_col</span> <span class="ow">in</span> <span class="n">drop_columns</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">fs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">feature_strings</span><span class="p">)]</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_to_drop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns: </span><span class="si">{</span><span class="n">columns_to_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  
    <span class="k">if</span> <span class="n">remove_low_variance_features</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">remove_low_variance_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">remove_highly_correlated_features</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        
    <span class="c1"># Remove columns with NaN values</span>
    <span class="n">before_drop_NaN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">after_drop_NaN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dropped </span><span class="si">{</span><span class="n">before_drop_NaN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">after_drop_NaN</span><span class="si">}</span><span class="s2"> columns with NaN values&quot;</span><span class="p">)</span>

    <span class="c1"># Select numerical features</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">features</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">filtered_df</span><span class="p">,</span> <span class="n">features</span></div>


<span class="c1"># Create a function to check if images overlap</span>
<div class="viewcode-block" id="check_overlap">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.check_overlap">[docs]</a>
<span class="k">def</span> <span class="nf">check_overlap</span><span class="p">(</span><span class="n">current_position</span><span class="p">,</span> <span class="n">other_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the current position overlaps with any of the other positions </span>
<span class="sd">    within a specified threshold distance.</span>

<span class="sd">    Args:</span>
<span class="sd">        current_position (iterable): The current position as a list, tuple, or array of coordinates.</span>
<span class="sd">        other_positions (iterable): A collection of positions to compare against, </span>
<span class="sd">                                    where each position is a list, tuple, or array of coordinates.</span>
<span class="sd">        threshold (float): The distance threshold below which two positions are considered overlapping.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the current position overlaps with any of the other positions, </span>
<span class="sd">              False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">other_position</span> <span class="ow">in</span> <span class="n">other_positions</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">current_position</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other_position</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># Define a function to try random positions around a given point</span>
<div class="viewcode-block" id="find_non_overlapping_position">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.find_non_overlapping_position">[docs]</a>
<span class="k">def</span> <span class="nf">find_non_overlapping_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds a new position near the given coordinates (x, y) that does not overlap</span>
<span class="sd">    with any of the positions in the provided image_positions list, based on a</span>
<span class="sd">    specified threshold.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (float): The x-coordinate of the initial position.</span>
<span class="sd">        y (float): The y-coordinate of the initial position.</span>
<span class="sd">        image_positions (list of tuples): A list of (x, y) tuples representing</span>
<span class="sd">            existing positions to avoid overlapping with.</span>
<span class="sd">        threshold (float): The minimum distance required to avoid overlap.</span>
<span class="sd">        max_attempts (int, optional): The maximum number of attempts to find a</span>
<span class="sd">            non-overlapping position. Defaults to 100.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple (new_x, new_y) representing the new non-overlapping</span>
<span class="sd">        position. If no suitable position is found within the maximum attempts,</span>
<span class="sd">        the original position (x, y) is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offset_range</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Adjust the range for random offsets</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">attempts</span> <span class="o">&lt;</span> <span class="n">max_attempts</span><span class="p">:</span>
        <span class="n">random_offset_x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">)</span>
        <span class="n">random_offset_y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">)</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">random_offset_x</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">random_offset_y</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check_overlap</span><span class="p">((</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">),</span> <span class="n">image_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span>
        <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>  <span class="c1"># Return the original position if no suitable position found</span></div>


<div class="viewcode-block" id="search_reduction_and_clustering">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.search_reduction_and_clustering">[docs]</a>
<span class="k">def</span> <span class="nf">search_reduction_and_clustering</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">reduction_method</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">reduction_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform dimensionality reduction and clustering on the given data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    numeric_data (np.array): Numeric data to process.</span>
<span class="sd">    n_neighbors (int): Number of neighbors for UMAP or perplexity for tSNE.</span>
<span class="sd">    min_dist (float): Minimum distance for UMAP.</span>
<span class="sd">    metric (str): Metric for UMAP, tSNE, and DBSCAN.</span>
<span class="sd">    eps (float): Epsilon for DBSCAN clustering.</span>
<span class="sd">    min_samples (int): Minimum samples for DBSCAN or number of clusters for KMeans.</span>
<span class="sd">    clustering (str): Clustering method (&#39;DBSCAN&#39; or &#39;KMeans&#39;).</span>
<span class="sd">    reduction_method (str): Dimensionality reduction method (&#39;UMAP&#39; or &#39;tSNE&#39;).</span>
<span class="sd">    verbose (bool): Whether to print verbose output.</span>
<span class="sd">    reduction_param (dict): Additional parameters for the reduction method.</span>
<span class="sd">    embedding (np.array): Precomputed embedding (optional).</span>
<span class="sd">    n_jobs (int): Number of parallel jobs to run.</span>

<span class="sd">    Returns:</span>
<span class="sd">    embedding (np.array): Embedding of the data.</span>
<span class="sd">    labels (np.array): Cluster labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;n_neighbors cannota be less than 2. Setting n_neighbors to </span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">reduction_param</span> <span class="o">=</span> <span class="n">reduction_param</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">reduction_param</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">reduction_param</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;perplexity&#39;</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="s1">&#39;min_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;metric&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">]}</span>
    
    <span class="k">if</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;umap&#39;</span><span class="p">:</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">reduction_param</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;tsne&#39;</span><span class="p">:</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">reduction_param</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported reduction method: </span><span class="si">{</span><span class="n">reduction_method</span><span class="si">}</span><span class="s2">. Supported methods are &#39;umap&#39; and &#39;tsne&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported clustering method: </span><span class="si">{</span><span class="n">clustering</span><span class="si">}</span><span class="s2">. Supported methods are &#39;dbscan&#39; and &#39;kmeans&#39;&quot;</span><span class="p">)</span>
    <span class="n">clustering_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">labels_</span> <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span> <span class="k">else</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Embedding shape: </span><span class="si">{</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="load_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.load_image">[docs]</a>
<span class="k">def</span> <span class="nf">load_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads an image from the specified file path, applies a series of transformations,</span>
<span class="sd">    and returns the transformed image as a tensor.</span>

<span class="sd">    The transformations applied are:</span>
<span class="sd">    - Resizing the image to 224x224 pixels.</span>
<span class="sd">    - Converting the image to a tensor.</span>
<span class="sd">    - Normalizing the image tensor using the mean [0.485, 0.456, 0.406] and</span>
<span class="sd">      standard deviation [0.229, 0.224, 0.225].</span>

<span class="sd">    Args:</span>
<span class="sd">        image_path (str): The file path to the image to be loaded.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A 4D tensor representing the transformed image, with shape</span>
<span class="sd">        (1, 3, 224, 224), where 1 is the batch size, 3 is the number of color</span>
<span class="sd">        channels (RGB), and 224x224 is the spatial resolution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span> <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]),</span>
    <span class="p">])</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="extract_features">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.extract_features">[docs]</a>
<span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="n">image_paths</span><span class="p">,</span> <span class="n">resnet</span><span class="o">=</span><span class="n">resnet50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts features from a list of image paths using a pre-trained ResNet model.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_paths (list of str): A list of file paths to the images from which features are to be extracted.</span>
<span class="sd">        resnet (torchvision.models, optional): A ResNet model class to use for feature extraction. </span>
<span class="sd">            Defaults to torchvision.models.resnet50.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A 2D array where each row corresponds to the extracted features of an image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">resnet</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">children</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove the last classification layer</span>

    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">features</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_normality">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.check_normality">[docs]</a>
<span class="k">def</span> <span class="nf">check_normality</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether a given data series follows a normal distribution.</span>

<span class="sd">    This function uses the D&#39;Agostino and Pearson&#39;s test to check the null </span>
<span class="sd">    hypothesis that the data comes from a normal distribution. If the p-value </span>
<span class="sd">    is less than the significance level (alpha), the null hypothesis is rejected.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        series (array-like): The data series to test for normality.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the data follows a normal distribution (p &gt;= alpha), </span>
<span class="sd">              False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">normaltest</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>  <span class="c1"># null hypothesis: x comes from a normal distribution</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="random_forest_feature_importance">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.random_forest_feature_importance">[docs]</a>
<span class="k">def</span> <span class="nf">random_forest_feature_importance</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes feature importance using a Random Forest Classifier.</span>

<span class="sd">    This function takes a DataFrame, selects numeric features, and computes</span>
<span class="sd">    the importance of each feature in predicting the specified cluster column</span>
<span class="sd">    using a Random Forest Classifier. The results are returned as a sorted</span>
<span class="sd">    DataFrame of feature importances.</span>

<span class="sd">    Args:</span>
<span class="sd">        all_df (pd.DataFrame): The input DataFrame containing the data.</span>
<span class="sd">        cluster_col (str, optional): The name of the column representing the </span>
<span class="sd">            target variable (cluster). Defaults to &#39;cluster&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame containing the features and their corresponding</span>
<span class="sd">        importance scores, sorted in descending order of importance.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes that the target column (`cluster_col`) is numeric.</span>
<span class="sd">        - Standard scaling is applied to the numeric features before fitting the model.</span>
<span class="sd">        - The Random Forest Classifier is initialized with 100 estimators and a </span>
<span class="sd">          random state of 42 for reproducibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numeric_features</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cluster_col</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">numeric_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">all_df</span><span class="p">[</span><span class="n">numeric_features</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span>

    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">feature_importances</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">feature_importances_</span>

    <span class="n">importance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Feature&#39;</span><span class="p">:</span> <span class="n">numeric_features</span><span class="p">,</span>
        <span class="s1">&#39;Importance&#39;</span><span class="p">:</span> <span class="n">feature_importances</span>
    <span class="p">})</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;Importance&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">importance_df</span></div>


<div class="viewcode-block" id="perform_statistical_tests">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.perform_statistical_tests">[docs]</a>
<span class="k">def</span> <span class="nf">perform_statistical_tests</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform statistical tests (ANOVA and Kruskal-Wallis) on numeric features grouped by a cluster column.</span>
<span class="sd">    This function evaluates whether there are statistically significant differences </span>
<span class="sd">    in the distributions of numeric features across groups defined by the `cluster_col`.</span>
<span class="sd">    Args:</span>
<span class="sd">        all_df (pd.DataFrame): The input DataFrame containing the data to analyze.</span>
<span class="sd">        cluster_col (str, optional): The column name representing the cluster or group labels. </span>
<span class="sd">                                     Defaults to &#39;cluster&#39;.</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - anova_df (pd.DataFrame): A DataFrame containing the results of the ANOVA test </span>
<span class="sd">              with columns [&#39;Feature&#39;, &#39;ANOVA_Statistic&#39;, &#39;ANOVA_pValue&#39;].</span>
<span class="sd">            - kruskal_df (pd.DataFrame): A DataFrame containing the results of the Kruskal-Wallis test </span>
<span class="sd">              with columns [&#39;Feature&#39;, &#39;Kruskal_Statistic&#39;, &#39;Kruskal_pValue&#39;].</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function first checks the normality of each numeric feature using the `check_normality` function.</span>
<span class="sd">        - If the feature is normally distributed, an ANOVA test is performed.</span>
<span class="sd">        - If the feature is not normally distributed, a Kruskal-Wallis test is performed.</span>
<span class="sd">        - The `check_normality` function and statistical test functions (`f_oneway` and `kruskal`) </span>
<span class="sd">          are assumed to be imported from appropriate libraries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numeric_features</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cluster_col</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">numeric_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">)</span>
    
    <span class="n">anova_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kruskal_results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_df</span><span class="p">[</span><span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">][</span><span class="n">feature</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">])]</span>
        
        <span class="k">if</span> <span class="n">check_normality</span><span class="p">(</span><span class="n">all_df</span><span class="p">[</span><span class="n">feature</span><span class="p">]):</span>
            <span class="n">stat</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f_oneway</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">)</span>
            <span class="n">anova_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">feature</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">)</span>
            <span class="n">kruskal_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">feature</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    
    <span class="n">anova_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">anova_results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;ANOVA_Statistic&#39;</span><span class="p">,</span> <span class="s1">&#39;ANOVA_pValue&#39;</span><span class="p">])</span>
    <span class="n">kruskal_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kruskal_results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;Kruskal_Statistic&#39;</span><span class="p">,</span> <span class="s1">&#39;Kruskal_pValue&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span></div>


<div class="viewcode-block" id="combine_results">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.combine_results">[docs]</a>
<span class="k">def</span> <span class="nf">combine_results</span><span class="p">(</span><span class="n">rf_df</span><span class="p">,</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines results from multiple DataFrames into a single DataFrame.</span>

<span class="sd">    This function merges three DataFrames (`rf_df`, `anova_df`, and `kruskal_df`) </span>
<span class="sd">    on the &#39;Feature&#39; column using a left join. The resulting DataFrame contains </span>
<span class="sd">    all features from `rf_df` and their corresponding data from `anova_df` and </span>
<span class="sd">    `kruskal_df` where available.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        rf_df (pd.DataFrame): A DataFrame containing features and their associated </span>
<span class="sd">                              data from a random forest analysis.</span>
<span class="sd">        anova_df (pd.DataFrame): A DataFrame containing features and their associated </span>
<span class="sd">                                 data from an ANOVA analysis.</span>
<span class="sd">        kruskal_df (pd.DataFrame): A DataFrame containing features and their associated </span>
<span class="sd">                                   data from a Kruskal-Wallis analysis.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A combined DataFrame with features and their associated data </span>
<span class="sd">                      from all three input DataFrames.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">rf_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">anova_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">kruskal_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combined_df</span></div>


<div class="viewcode-block" id="cluster_feature_analysis">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.cluster_feature_analysis">[docs]</a>
<span class="k">def</span> <span class="nf">cluster_feature_analysis</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform feature analysis for clustering by combining results from </span>
<span class="sd">    random forest feature importance and statistical tests.</span>

<span class="sd">    This function calculates feature importance using a random forest model, </span>
<span class="sd">    performs statistical tests (ANOVA and Kruskal-Wallis) to assess the </span>
<span class="sd">    significance of features, and combines the results into a single DataFrame.</span>

<span class="sd">    Args:</span>
<span class="sd">        all_df (pd.DataFrame): The input DataFrame containing features and cluster labels.</span>
<span class="sd">        cluster_col (str, optional): The name of the column representing cluster labels. </span>
<span class="sd">                                     Defaults to &#39;cluster&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame combining the results of random forest feature </span>
<span class="sd">                      importance and statistical tests for feature analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rf_df</span> <span class="o">=</span> <span class="n">random_forest_feature_importance</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">)</span>
    <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span> <span class="o">=</span> <span class="n">perform_statistical_tests</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">)</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">combine_results</span><span class="p">(</span><span class="n">rf_df</span><span class="p">,</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combined_df</span></div>


<span class="k">def</span> <span class="nf">_merge_cells_based_on_parasite_overlap</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge cells in cell_mask if a parasite in parasite_mask overlaps with more than one cell,</span>
<span class="sd">    and if cells share more than a specified perimeter percentage.</span>

<span class="sd">    Args:</span>
<span class="sd">        parasite_mask (ndarray): Mask of parasites.</span>
<span class="sd">        cell_mask (ndarray): Mask of cells.</span>
<span class="sd">        nuclei_mask (ndarray): Mask of nuclei.</span>
<span class="sd">        overlap_threshold (float): The percentage threshold for merging cells based on parasite overlap.</span>
<span class="sd">        perimeter_threshold (float): The percentage threshold for merging cells based on shared perimeter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The modified cell mask (cell_mask) with unique labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labeled_cells</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>
    <span class="n">labeled_parasites</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">)</span>
    <span class="n">labeled_nuclei</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">nuclei_mask</span><span class="p">)</span>
    <span class="n">num_parasites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_parasites</span><span class="p">)</span>
    <span class="n">num_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">)</span>
    <span class="n">num_nuclei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_nuclei</span><span class="p">)</span>

    <span class="c1"># Merge cells based on parasite overlap</span>
    <span class="k">for</span> <span class="n">parasite_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_parasites</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_parasite_mask</span> <span class="o">=</span> <span class="n">labeled_parasites</span> <span class="o">==</span> <span class="n">parasite_id</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">current_parasite_mask</span><span class="p">])</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="n">overlapping_cell_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Calculate the overlap percentages</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_parasite_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_parasite_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span>
            <span class="p">]</span>
            <span class="c1"># Merge cells if overlap percentage is above the threshold</span>
            <span class="k">for</span> <span class="n">cell_label</span><span class="p">,</span> <span class="n">overlap_percentage</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">,</span> <span class="n">overlap_percentages</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">overlap_percentage</span> <span class="o">&gt;</span> <span class="n">overlap_threshold</span><span class="p">:</span>
                    <span class="n">first_label</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="n">other_label</span> <span class="o">!=</span> <span class="n">first_label</span><span class="p">:</span>
                            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">==</span> <span class="n">other_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_label</span>

    <span class="c1"># Merge cells based on nucleus overlap</span>
    <span class="k">for</span> <span class="n">nucleus_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nuclei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_nucleus_mask</span> <span class="o">=</span> <span class="n">labeled_nuclei</span> <span class="o">==</span> <span class="n">nucleus_id</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">current_nucleus_mask</span><span class="p">])</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="n">overlapping_cell_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Calculate the overlap percentages</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_nucleus_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_nucleus_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span>
            <span class="p">]</span>
            <span class="c1"># Merge cells if overlap percentage is above the threshold for each cell</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">overlap_percentage</span> <span class="o">&gt;</span> <span class="n">overlap_threshold</span> <span class="k">for</span> <span class="n">overlap_percentage</span> <span class="ow">in</span> <span class="n">overlap_percentages</span><span class="p">):</span>
                <span class="n">first_label</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">other_label</span> <span class="o">!=</span> <span class="n">first_label</span><span class="p">:</span>
                        <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">==</span> <span class="n">other_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_label</span>

    <span class="c1"># Check for cells without nuclei and merge based on shared perimeter</span>
    <span class="n">labeled_cells</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>  <span class="c1"># Re-label after merging based on overlap</span>
    <span class="n">cell_regions</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">cell_regions</span><span class="p">:</span>
        <span class="n">cell_label</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span>
        <span class="n">cell_mask_binary</span> <span class="o">=</span> <span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">overlapping_nuclei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nuclei_mask</span><span class="p">[</span><span class="n">cell_mask_binary</span><span class="p">])</span>
        <span class="n">overlapping_nuclei</span> <span class="o">=</span> <span class="n">overlapping_nuclei</span><span class="p">[</span><span class="n">overlapping_nuclei</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_nuclei</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># Cell does not overlap with any nucleus</span>
            <span class="n">perimeter</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">perimeter</span>
            
            <span class="c1"># Dilate the cell to find neighbors</span>
            <span class="n">dilated_cell</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">cell_mask_binary</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">neighbor_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">dilated_cell</span><span class="p">])</span>
            <span class="n">neighbor_cells</span> <span class="o">=</span> <span class="n">neighbor_cells</span><span class="p">[(</span><span class="n">neighbor_cells</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">neighbor_cells</span> <span class="o">!=</span> <span class="n">cell_label</span><span class="p">)]</span>
            
            <span class="c1"># Calculate shared border length with neighboring cells</span>
            <span class="n">shared_borders</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">neighbor_label</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dilated_cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbor_label</span> <span class="ow">in</span> <span class="n">neighbor_cells</span>
            <span class="p">]</span>
            <span class="n">shared_border_percentages</span> <span class="o">=</span> <span class="p">[</span><span class="n">shared_border</span> <span class="o">/</span> <span class="n">perimeter</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">shared_border</span> <span class="ow">in</span> <span class="n">shared_borders</span><span class="p">]</span>
            
            <span class="c1"># Merge with the neighbor cell with the largest shared border percentage above the threshold</span>
            <span class="k">if</span> <span class="n">shared_borders</span><span class="p">:</span>
                <span class="n">max_shared_border_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">shared_border_percentages</span><span class="p">)</span>
                <span class="n">max_shared_border_percentage</span> <span class="o">=</span> <span class="n">shared_border_percentages</span><span class="p">[</span><span class="n">max_shared_border_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">max_shared_border_percentage</span> <span class="o">&gt;</span> <span class="n">perimeter_threshold</span><span class="p">:</span>
                    <span class="n">cell_mask</span><span class="p">[</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_cells</span><span class="p">[</span><span class="n">max_shared_border_index</span><span class="p">]</span>
    
    <span class="c1"># Relabel the merged cell mask</span>
    <span class="n">relabeled_cell_mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">return_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">relabeled_cell_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_merge_cells_without_nucleus</span><span class="p">(</span><span class="n">adj_cell_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relabel any cell that lacks a nucleus to the ID of an adjacent</span>
<span class="sd">    cell that *does* contain a nucleus.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj_cell_mask : np.ndarray</span>
<span class="sd">        Labelled (0 = background) cell mask after all other merging steps.</span>
<span class="sd">    nuclei_mask : np.ndarray</span>
<span class="sd">        Labelled (0 = background) nuclei mask.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Updated cell mask with nucleus-free cells merged into</span>
<span class="sd">        neighbouring nucleus-bearing cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">adj_cell_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------- #</span>
    <span class="c1"># 1 — Identify which cell IDs contain a nucleus</span>
    <span class="n">nuc_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nuclei_mask</span><span class="p">[</span><span class="n">nuclei_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">cells_with_nuc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">nuc_id</span> <span class="ow">in</span> <span class="n">nuc_labels</span><span class="p">:</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">adj_cell_mask</span><span class="p">[</span><span class="n">nuclei_mask</span> <span class="o">==</span> <span class="n">nuc_id</span><span class="p">],</span>
                                   <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># drop background (label 0) from *both* arrays</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>                     <span class="c1"># at least one non-zero overlap</span>
            <span class="n">cells_with_nuc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)])</span>

    <span class="c1"># ----------------------------------------------------------------- #</span>
    <span class="c1"># 2 — Build an adjacency map between neighbouring cell IDs</span>
    <span class="c1"># ----------------------------------------------------------------- #</span>
    <span class="n">boundaries</span> <span class="o">=</span> <span class="n">find_boundaries</span><span class="p">(</span><span class="n">adj_cell_mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;thick&quot;</span><span class="p">)</span>
    <span class="n">adj_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

    <span class="n">ys</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">adj_cell_mask</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">xs</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">adj_cell_mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">src</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">dst</span> <span class="o">=</span> <span class="n">adj_cell_mask</span><span class="p">[</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">dst</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dst</span> <span class="o">!=</span> <span class="n">src</span><span class="p">:</span>
                        <span class="n">adj_map</span><span class="p">[</span><span class="n">src</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------- #</span>
    <span class="c1"># 3 — Relabel nucleus-free cells that touch nucleus-bearing neighbours</span>
    <span class="c1"># ----------------------------------------------------------------- #</span>
    <span class="n">cells_no_nuc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">adj_cell_mask</span><span class="p">))</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="o">-</span> <span class="n">cells_with_nuc</span>
    <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cells_no_nuc</span><span class="p">:</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">adj_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">cells_with_nuc</span>
        <span class="k">if</span> <span class="n">neighbours</span><span class="p">:</span>
            <span class="c1"># Choose the first nucleus-bearing neighbour deterministically</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">out</span> <span class="o">==</span> <span class="n">cell_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>

    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

<div class="viewcode-block" id="process_mask_file_adjust_cell">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.process_mask_file_adjust_cell">[docs]</a>
<span class="k">def</span> <span class="nf">process_mask_file_adjust_cell</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">parasite_folder</span><span class="p">,</span> <span class="n">cell_folder</span><span class="p">,</span> <span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes and adjusts a cell mask file based on parasite overlap and perimeter thresholds.</span>

<span class="sd">    This function loads parasite, cell, and nuclei mask files, merges cells based on parasite overlap</span>
<span class="sd">    and perimeter thresholds, and saves the updated cell mask back to the file system.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the mask file to process.</span>
<span class="sd">        parasite_folder (str): The directory containing parasite mask files.</span>
<span class="sd">        cell_folder (str): The directory containing cell mask files.</span>
<span class="sd">        nuclei_folder (str): The directory containing nuclei mask files.</span>
<span class="sd">        overlap_threshold (float): The threshold for parasite overlap to merge cells.</span>
<span class="sd">        perimeter_threshold (float): The threshold for cell perimeter to merge cells.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The time taken to process the mask file, in seconds.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the corresponding cell or nuclei mask file for the given file_name is not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="n">parasite_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
    <span class="n">cell_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
    <span class="n">nuclei_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corresponding cell or nuclei mask file for </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>

    <span class="n">parasite_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">parasite_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nuclei_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">merged_cell_mask</span> <span class="o">=</span> <span class="n">_merge_cells_based_on_parasite_overlap</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="p">)</span>
    <span class="c1">#merged_cell_mask = _merge_cells_without_nucleus(merged_cell_mask, nuclei_mask)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">merged_cell_mask</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span></div>


<div class="viewcode-block" id="adjust_cell_masks">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.adjust_cell_masks">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_cell_masks</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">cell_folder</span><span class="p">,</span> <span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts cell masks based on parasite, cell, and nuclei data files.</span>
<span class="sd">    This function processes `.npy` files from the specified folders to adjust cell masks</span>
<span class="sd">    by considering overlap and perimeter thresholds. It uses multiprocessing to parallelize</span>
<span class="sd">    the processing of files.</span>
<span class="sd">    Args:</span>
<span class="sd">        parasite_folder (str): Path to the folder containing parasite `.npy` files.</span>
<span class="sd">        cell_folder (str): Path to the folder containing cell `.npy` files.</span>
<span class="sd">        nuclei_folder (str): Path to the folder containing nuclei `.npy` files.</span>
<span class="sd">        overlap_threshold (int, optional): Threshold for overlap adjustment. Defaults to 5.</span>
<span class="sd">        perimeter_threshold (int, optional): Threshold for perimeter adjustment. Defaults to 30.</span>
<span class="sd">        n_jobs (int, optional): Number of parallel jobs to run. Defaults to the number of CPU cores minus 2.</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of files in the parasite, cell, and nuclei folders do not match.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes that the files in the folders are named in a way that allows</span>
<span class="sd">          them to be sorted and matched correctly.</span>
<span class="sd">        - Progress is printed to the console during processing.</span>
<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">parasite_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">cell_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">nuclei_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_files</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of files in the folders do not match.&quot;</span><span class="p">)</span>

    <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">time_ls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">)</span>
    <span class="n">process_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">process_mask_file_adjust_cell</span><span class="p">,</span>
                         <span class="n">parasite_folder</span><span class="o">=</span><span class="n">parasite_folder</span><span class="p">,</span>
                         <span class="n">cell_folder</span><span class="o">=</span><span class="n">cell_folder</span><span class="p">,</span>
                         <span class="n">nuclei_folder</span><span class="o">=</span><span class="n">nuclei_folder</span><span class="p">,</span>
                         <span class="n">overlap_threshold</span><span class="o">=</span><span class="n">overlap_threshold</span><span class="p">,</span>
                         <span class="n">perimeter_threshold</span><span class="o">=</span><span class="n">perimeter_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">duration</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">process_fn</span><span class="p">,</span> <span class="n">parasite_files</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">time_ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
            <span class="n">print_progress</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">files_to_process</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="n">time_ls</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="s1">&#39;adjust_cell_masks&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="adjust_cell_masks_v1">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.adjust_cell_masks_v1">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_cell_masks_v1</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">cell_folder</span><span class="p">,</span> <span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process all npy files in the given folders. Merge and relabel cells in cell masks</span>
<span class="sd">    based on parasite overlap and cell perimeter sharing conditions.</span>

<span class="sd">    Args:</span>
<span class="sd">        parasite_folder (str): Path to the folder containing parasite masks.</span>
<span class="sd">        cell_folder (str): Path to the folder containing cell masks.</span>
<span class="sd">        nuclei_folder (str): Path to the folder containing nuclei masks.</span>
<span class="sd">        overlap_threshold (float): The percentage threshold for merging cells based on parasite overlap.</span>
<span class="sd">        perimeter_threshold (float): The percentage threshold for merging cells based on shared perimeter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parasite_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">cell_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">nuclei_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    
    <span class="c1"># Ensure there are matching files in all folders</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_files</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of files in the folders do not match.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Match files by name</span>
    <span class="n">time_ls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">files_processed</span><span class="p">,</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">parasite_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="n">cell_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="n">nuclei_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="c1"># Check if the corresponding cell and nuclei mask files exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corresponding cell or nuclei mask file for </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>
        <span class="c1"># Load the masks</span>
        <span class="n">parasite_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">parasite_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nuclei_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Merge and relabel cells</span>
        <span class="n">merged_cell_mask</span> <span class="o">=</span> <span class="n">_merge_cells_based_on_parasite_overlap</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="p">)</span>
        
        <span class="c1">#merged_cell_mask = _merge_cells_without_nucleus(merged_cell_mask, nuclei_mask)</span>
    
        <span class="c1"># Overwrite the original cell mask file with the merged result</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">merged_cell_mask</span><span class="p">)</span>
        
        <span class="n">stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">time_ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        <span class="n">files_processed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">print_progress</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="n">files_to_process</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="n">time_ls</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;adjust_cell_masks&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_masks">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.process_masks">[docs]</a>
<span class="k">def</span> <span class="nf">process_masks</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">image_folder</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes mask files by measuring object properties, clustering objects, and removing objects </span>
<span class="sd">    not belonging to the largest cluster.</span>
<span class="sd">    Args:</span>
<span class="sd">        mask_folder (str): Path to the folder containing mask files (.npy format).</span>
<span class="sd">        image_folder (str): Path to the folder containing corresponding image files (.npy format).</span>
<span class="sd">        channel (int): The channel index to extract from the image files.</span>
<span class="sd">        batch_size (int, optional): Number of files to process in each batch. Defaults to 50.</span>
<span class="sd">        n_clusters (int, optional): Number of clusters for KMeans clustering. Defaults to 2.</span>
<span class="sd">        plot (bool, optional): Whether to plot the clustering results using PCA. Defaults to False.</span>
<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the mask files in place by removing objects not in the largest cluster.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The mask files are expected to be in .npy format and contain labeled regions.</span>
<span class="sd">        - The image files are expected to be in .npy format and have the same names as the mask files.</span>
<span class="sd">        - The function assumes that the mask and image files are sorted in the same order.</span>
<span class="sd">        - The clustering is performed on accumulated object properties across all files.</span>
<span class="sd">        - The largest cluster is determined based on the number of objects in each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">read_files_in_batches</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)]</span>
        <span class="n">files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># Sort to ensure matching order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
        <span class="n">properties_list</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">mean_intensity</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">perimeter</span><span class="p">,</span> <span class="s1">&#39;eccentricity&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">properties_list</span>

    <span class="k">def</span> <span class="nf">cluster_objects</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;perimeter&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;eccentricity&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">])</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kmeans</span>

    <span class="k">def</span> <span class="nf">remove_objects_not_in_largest_cluster</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">largest_cluster_label</span><span class="p">):</span>
        <span class="n">cleaned_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">largest_cluster_label</span><span class="p">:</span>
                <span class="n">cleaned_mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span>
        <span class="k">return</span> <span class="n">cleaned_mask</span>

    <span class="k">def</span> <span class="nf">plot_clusters</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;perimeter&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;eccentricity&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">])</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">data_2d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data_2d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;PCA Component 1&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;PCA Component 2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Object Clustering&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">all_properties</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Step 1: Accumulate properties over all files</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">read_files_in_batches</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">]</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">]</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Measure morphology and intensity</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
            <span class="n">all_properties</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>

    <span class="c1"># Step 2: Perform clustering on accumulated properties</span>
    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">cluster_objects</span><span class="p">(</span><span class="n">all_properties</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="c1"># Step 3: Plot clusters using PCA</span>
        <span class="n">plot_clusters</span><span class="p">(</span><span class="n">all_properties</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Step 4: Remove objects not in the largest cluster and overwrite files in batches</span>
    <span class="n">label_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">read_files_in_batches</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
            <span class="n">batch_properties</span> <span class="o">=</span> <span class="n">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">batch_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">label_index</span><span class="p">:</span><span class="n">label_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_properties</span><span class="p">)]</span>
            <span class="n">largest_cluster_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">batch_labels</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">cleaned_mask</span> <span class="o">=</span> <span class="n">remove_objects_not_in_largest_cluster</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">batch_labels</span><span class="p">,</span> <span class="n">largest_cluster_label</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cleaned_mask</span><span class="p">)</span>
            <span class="n">label_index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_properties</span><span class="p">)</span></div>


<div class="viewcode-block" id="merge_regression_res_with_metadata">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.merge_regression_res_with_metadata">[docs]</a>
<span class="k">def</span> <span class="nf">merge_regression_res_with_metadata</span><span class="p">(</span><span class="n">results_file</span><span class="p">,</span> <span class="n">metadata_file</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_metadata&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges regression results with metadata based on a common gene identifier.</span>
<span class="sd">    This function reads two CSV files: one containing regression results and the other containing metadata.</span>
<span class="sd">    It extracts and cleans gene identifiers from both files, merges them on the gene column, and saves the</span>
<span class="sd">    merged dataframe to a new CSV file.</span>
<span class="sd">    Args:</span>
<span class="sd">        results_file (str): Path to the CSV file containing regression results. This file must have a </span>
<span class="sd">                            &#39;feature&#39; column from which gene identifiers can be extracted.</span>
<span class="sd">        metadata_file (str): Path to the CSV file containing metadata. This file must have a &#39;Gene ID&#39; </span>
<span class="sd">                             column from which gene identifiers can be extracted.</span>
<span class="sd">        name (str, optional): Suffix to append to the base name of the results file for the output file. </span>
<span class="sd">                              Defaults to &#39;_metadata&#39;.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The merged dataframe containing data from both the regression results and metadata files.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The &#39;feature&#39; column in the results file is expected to contain gene information in the format </span>
<span class="sd">          &#39;[gene_name]&#39;, which will be extracted and cleaned.</span>
<span class="sd">        - The &#39;Gene ID&#39; column in the metadata file is expected to contain gene information in the format </span>
<span class="sd">          &#39;prefix_gene_name&#39;, from which the gene name will be extracted.</span>
<span class="sd">        - Rows where gene extraction fails will not be dropped but will result in NaN values in the merged dataframe.</span>
<span class="sd">        - The merged file is saved in the same directory as the results file, with the specified suffix added </span>
<span class="sd">          to its name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the CSV files into dataframes</span>
    <span class="n">df_results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">results_file</span><span class="p">)</span>
    <span class="n">df_metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">extract_and_clean_gene</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
        <span class="c1"># Extract the part between &#39;[&#39; and &#39;]&#39;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[(.*?)\]&#39;</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Remove &#39;T.&#39; if present</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^T\.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gene</span><span class="p">)</span>
            <span class="c1"># Remove everything after and including &#39;_&#39;</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">gene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gene</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Apply the function to the feature column</span>
    <span class="n">df_results</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_results</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">extract_and_clean_gene</span><span class="p">)</span>
    
    <span class="n">df_metadata</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_metadata</span><span class="p">[</span><span class="s1">&#39;Gene ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># Drop rows where gene extraction failed</span>
    <span class="c1">#df_results = df_results.dropna(subset=[&#39;gene&#39;])</span>
    
    <span class="c1"># Merge the two dataframes on the gene column</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_results</span><span class="p">,</span> <span class="n">df_metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    
    <span class="c1"># Generate the new file name</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">results_file</span><span class="p">)</span>
    <span class="n">new_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base</span><span class="si">}{</span><span class="n">name</span><span class="si">}{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="c1"># Save the merged dataframe to the new file</span>
    <span class="n">merged_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">new_file</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">merged_df</span></div>


<div class="viewcode-block" id="process_vision_results">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.process_vision_results">[docs]</a>
<span class="k">def</span> <span class="nf">process_vision_results</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes vision results by extracting metadata from the &#39;path&#39; column, </span>
<span class="sd">    applying a threshold to predictions, and adding new columns to the DataFrame.</span>
<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): A pandas DataFrame containing vision results. </span>
<span class="sd">            Must include a &#39;path&#39; column with metadata and a &#39;pred&#39; column with prediction scores.</span>
<span class="sd">        threshold (float, optional): The threshold value to classify predictions. </span>
<span class="sd">            Defaults to 0.5.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The modified DataFrame with additional columns:</span>
<span class="sd">            - &#39;plateID&#39;: Extracted plate identifier from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;rowID&#39;: Extracted row identifier from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;columnID&#39;: Extracted column identifier from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;fieldID&#39;: Extracted field identifier from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;object&#39;: Extracted object identifier from the &#39;path&#39; column.</span>
<span class="sd">            - &#39;prc&#39;: Concatenated string of &#39;plateID&#39;, &#39;rowID&#39;, and &#39;columnID&#39;.</span>
<span class="sd">            - &#39;cv_predictions&#39;: Binary classification results based on the threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Split the &#39;path&#39; column using _map_wells function</span>
    <span class="n">mapped_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;rowID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;columnID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fieldID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;rowID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;columnID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cv_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_ml_results_paths">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_ml_results_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_ml_results_paths</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;xgboost&#39;</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate file paths for machine learning results based on the specified parameters.</span>
<span class="sd">    This function creates a directory structure for storing machine learning results</span>
<span class="sd">    and returns the paths to various result files.</span>
<span class="sd">    Args:</span>
<span class="sd">        src (str): The base directory where the results folder will be created.</span>
<span class="sd">        model_type (str, optional): The type of machine learning model. Defaults to &#39;xgboost&#39;.</span>
<span class="sd">        channel_of_interest (int, list, str, or None, optional): Specifies the feature set used.</span>
<span class="sd">            - If int: A single channel (e.g., 1).</span>
<span class="sd">            - If list: Multiple channels (e.g., [1, 2, 3]).</span>
<span class="sd">            - If &#39;morphology&#39;: Use morphology features.</span>
<span class="sd">            - If None: Use all features.</span>
<span class="sd">            Defaults to 1.</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the following file paths:</span>
<span class="sd">            - data_path (str): Path to the results CSV file.</span>
<span class="sd">            - permutation_path (str): Path to the permutation CSV file.</span>
<span class="sd">            - feature_importance_path (str): Path to the feature importance CSV file.</span>
<span class="sd">            - model_metricks_path (str): Path to the model metrics CSV file.</span>
<span class="sd">            - permutation_fig_path (str): Path to the permutation figure (PDF).</span>
<span class="sd">            - feature_importance_fig_path (str): Path to the feature importance figure (PDF).</span>
<span class="sd">            - shap_fig_path (str): Path to the SHAP figure (PDF).</span>
<span class="sd">            - plate_heatmap_path (str): Path to the plate heatmap figure (PDF).</span>
<span class="sd">            - settings_csv (str): Path to the machine learning settings CSV file.</span>
<span class="sd">            - ml_features (str): Path to the machine learning features CSV file.</span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `channel_of_interest` is not of type int, list, None, or &#39;morphology&#39;.</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; get_ml_results_paths(&#39;/home/user/data&#39;, model_type=&#39;random_forest&#39;, channel_of_interest=[1, 2])</span>
<span class="sd">        (&#39;/home/user/data/results/random_forest/channels_1_2/results.csv&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/permutation.csv&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/feature_importance.csv&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/random_forest_model.csv&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/permutation.pdf&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/feature_importance.pdf&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/shap.pdf&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/plate_heatmap.pdf&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/ml_settings.csv&#39;, </span>
<span class="sd">         &#39;/home/user/data/results/random_forest/channels_1_2/ml_features.csv&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s2">&quot;channels_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="o">==</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s1">&#39;morphology&#39;</span>

    <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s1">&#39;all_features&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported channel_of_interest: </span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">. Supported values are &#39;int&#39;, &#39;list&#39;, &#39;None&#39;, or &#39;morphology&#39;.&quot;</span><span class="p">)</span>

    <span class="n">res_fldr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">feature_string</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saving results to </span><span class="si">{</span><span class="n">res_fldr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;results.csv&#39;</span><span class="p">)</span>
    <span class="n">permutation_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;permutation.csv&#39;</span><span class="p">)</span>
    <span class="n">feature_importance_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;feature_importance.csv&#39;</span><span class="p">)</span>
    <span class="n">model_metricks_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1">_model.csv&#39;</span><span class="p">)</span>
    <span class="n">permutation_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;permutation.pdf&#39;</span><span class="p">)</span>
    <span class="n">feature_importance_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;feature_importance.pdf&#39;</span><span class="p">)</span>
    <span class="n">shap_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;shap.pdf&#39;</span><span class="p">)</span>
    <span class="n">plate_heatmap_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;plate_heatmap.pdf&#39;</span><span class="p">)</span>
    <span class="n">settings_csv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;ml_settings.csv&#39;</span><span class="p">)</span>
    <span class="n">ml_features</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;ml_features.csv&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_path</span><span class="p">,</span> <span class="n">permutation_path</span><span class="p">,</span> <span class="n">feature_importance_path</span><span class="p">,</span> <span class="n">model_metricks_path</span><span class="p">,</span> <span class="n">permutation_fig_path</span><span class="p">,</span> <span class="n">feature_importance_fig_path</span><span class="p">,</span> <span class="n">shap_fig_path</span><span class="p">,</span> <span class="n">plate_heatmap_path</span><span class="p">,</span> <span class="n">settings_csv</span><span class="p">,</span> <span class="n">ml_features</span></div>


<div class="viewcode-block" id="augment_image">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.augment_image">[docs]</a>
<span class="k">def</span> <span class="nf">augment_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform data augmentation by rotating and reflecting the image.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - image (PIL Image or numpy array): The input image.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - augmented_images (list): A list of augmented images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Convert PIL image to numpy array if necessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    
    <span class="c1"># Handle grayscale images</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_GRAY2BGR</span><span class="p">)</span>

    <span class="c1"># Rotations and reflections</span>
    <span class="n">transformations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Original</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_CLOCKWISE</span><span class="p">,</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_180</span><span class="p">,</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_COUNTERCLOCKWISE</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">transformations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>

        <span class="c1"># Reflections</span>
        <span class="n">flipped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">rotated</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flipped</span><span class="p">)</span>

    <span class="c1"># Convert numpy arrays back to PIL images</span>
    <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">augmented_images</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">augmented_images</span></div>


<div class="viewcode-block" id="augment_dataset">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.augment_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">augment_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">is_grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform data augmentation on the entire dataset by rotating and reflecting the images.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - dataset (list of tuples): The input dataset, each entry is a tuple (image, label, filename).</span>
<span class="sd">    - is_grayscale (bool): Flag indicating if the images are grayscale.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - augmented_dataset (list of tuples): A dataset with augmented (image, label, filename) tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">augmented_dataset</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">img</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Ensure the image is a tensor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected torch.Tensor, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Rotations and reflections</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
            <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>

            <span class="c1"># Reflections</span>
            <span class="n">flipped</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">hflip</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>
            <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flipped</span><span class="p">)</span>

        <span class="c1"># Add augmented images to the dataset</span>
        <span class="k">for</span> <span class="n">aug_img</span> <span class="ow">in</span> <span class="n">augmented_images</span><span class="p">:</span>
            <span class="n">augmented_dataset</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aug_img</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">augmented_dataset</span></div>



<div class="viewcode-block" id="convert_and_relabel_masks">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.convert_and_relabel_masks">[docs]</a>
<span class="k">def</span> <span class="nf">convert_and_relabel_masks</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts all int64 npy masks in a folder to uint16 with relabeling to ensure all labels are retained.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - folder_path (str): The path to the folder containing int64 npy mask files.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="c1"># Load the mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="c1">#print(mask.shape)</span>
        <span class="c1">#print(mask.dtype)</span>
        <span class="c1"># Check the current dtype</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> as it is not int64.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="c1"># Relabel the mask to ensure unique labels within uint16 range</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: The mask in </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> contains values that exceed the uint16 range and will be relabeled.&quot;</span><span class="p">)</span>

        <span class="n">relabeled_mask</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Check that relabeling worked correctly</span>
        <span class="n">unique_relabeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">relabeled_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_relabeled</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Relabeling failed for </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> as it still contains values that exceed the uint16 range.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="c1"># Convert to uint16</span>
        <span class="n">relabeled_mask</span> <span class="o">=</span> <span class="n">relabeled_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        
        <span class="c1"># Save the converted mask</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">relabeled_mask</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> and saved as uint16_</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="correct_masks">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.correct_masks">[docs]</a>
<span class="k">def</span> <span class="nf">correct_masks</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrects and processes mask files located in the specified source directory.</span>

<span class="sd">    This function performs the following steps:</span>
<span class="sd">    1. Constructs the file path for the cell mask stack within the &#39;masks&#39; subdirectory of the source.</span>
<span class="sd">    2. Converts and relabels the masks using the `convert_and_relabel_masks` function.</span>
<span class="sd">    3. Loads and concatenates arrays from the source directory using the `_load_and_concatenate_arrays` function.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str): The path to the source directory containing the mask files.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_load_and_concatenate_arrays</span>

    <span class="n">cell_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">convert_and_relabel_masks</span><span class="p">(</span><span class="n">cell_path</span><span class="p">)</span>
    <span class="n">_load_and_concatenate_arrays</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_reads_in_fastq">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.count_reads_in_fastq">[docs]</a>
<span class="k">def</span> <span class="nf">count_reads_in_fastq</span><span class="p">(</span><span class="n">fastq_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of reads in a FASTQ file.</span>

<span class="sd">    A FASTQ file contains sequencing reads, where each read is represented</span>
<span class="sd">    by four lines: a header, the sequence, a separator, and the quality scores.</span>
<span class="sd">    This function calculates the total number of reads by dividing the total</span>
<span class="sd">    number of lines in the file by 4.</span>

<span class="sd">    Args:</span>
<span class="sd">        fastq_file (str): Path to the FASTQ file, which can be gzip-compressed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The number of reads in the FASTQ file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fastq_file</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">//</span> <span class="mi">4</span></div>


<span class="c1"># Function to determine the CUDA version</span>
<div class="viewcode-block" id="get_cuda_version">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.get_cuda_version">[docs]</a>
<span class="k">def</span> <span class="nf">get_cuda_version</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves the installed CUDA version by invoking the `nvcc --version` command.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The CUDA version as a string with dots removed (e.g., &#39;110&#39; for version 11.0),</span>
<span class="sd">             or None if the `nvcc` command is not found or an error occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;nvcc&#39;</span><span class="p">,</span> <span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;release&#39;</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;release &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="all_elements_match">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.all_elements_match">[docs]</a>
<span class="k">def</span> <span class="nf">all_elements_match</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if all elements in the first list are present in the second list.</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list): The first list containing elements to check.</span>
<span class="sd">        list2 (list): The second list to check against.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if all elements in list1 are found in list2, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if all elements in list1 are in list2</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="n">list2</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">)</span></div>


<div class="viewcode-block" id="prepare_batch_for_segmentation">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.prepare_batch_for_segmentation">[docs]</a>
<span class="k">def</span> <span class="nf">prepare_batch_for_segmentation</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepares a batch of images for segmentation by ensuring the correct data type </span>
<span class="sd">    and normalizing pixel values.</span>
<span class="sd">    Args:</span>
<span class="sd">        batch (numpy.ndarray): A batch of images represented as a NumPy array. </span>
<span class="sd">            The array is expected to have a shape of (N, H, W, C), where:</span>
<span class="sd">            - N is the number of images in the batch,</span>
<span class="sd">            - H and W are the height and width of each image,</span>
<span class="sd">            - C is the number of channels (e.g., 1 for grayscale, 3 for RGB).</span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The processed batch of images with dtype `float32` and </span>
<span class="sd">        pixel values normalized to the range [0, 1] if they were not already.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - If the input batch is not of dtype `float32`, it will be converted.</span>
<span class="sd">        - Each image in the batch is normalized individually by dividing its </span>
<span class="sd">          pixel values by the maximum pixel value in that image, if the maximum </span>
<span class="sd">          value is greater than 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the batch is of dtype float32</span>
    <span class="k">if</span> <span class="n">batch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># Normalize each image in the batch</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">batch</span></div>


<div class="viewcode-block" id="check_index">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.check_index">[docs]</a>
<span class="k">def</span> <span class="nf">check_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">split_char</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks the indices of a DataFrame to ensure they can be split into a specified number of parts.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The DataFrame whose indices are to be checked.</span>
<span class="sd">        elements (int, optional): The expected number of parts after splitting an index. Defaults to 5.</span>
<span class="sd">        split_char (str, optional): The character used to split the index. Defaults to &#39;_&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any index cannot be split into the specified number of parts, </span>
<span class="sd">                    a ValueError is raised listing the problematic indices.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; data = {&#39;col1&#39;: [1, 2, 3]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data, index=[&#39;a_b_c_d_e&#39;, &#39;f_g_h_i&#39;, &#39;j_k_l_m_n&#39;])</span>
<span class="sd">        &gt;&gt;&gt; check_index(df)</span>
<span class="sd">        ValueError: Found 1 problematic indices that do not split into 5 parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">problematic_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_char</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">!=</span> <span class="n">elements</span><span class="p">:</span>
            <span class="n">problematic_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">problematic_indices</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Indices that cannot be separated into 5 parts:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">problematic_indices</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">problematic_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> problematic indices that do not split into </span><span class="si">{</span><span class="n">elements</span><span class="si">}</span><span class="s2"> parts.&quot;</span><span class="p">)</span></div>

    
<span class="c1"># Define the mapping function</span>
<div class="viewcode-block" id="map_condition">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.map_condition">[docs]</a>
<span class="k">def</span> <span class="nf">map_condition</span><span class="p">(</span><span class="n">col_value</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;c1&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;c2&#39;</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="s1">&#39;c3&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps a given column value to a specific condition label.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        col_value (str): The value to be mapped.</span>
<span class="sd">        neg (str, optional): The value representing the &#39;neg&#39; condition. Defaults to &#39;c1&#39;.</span>
<span class="sd">        pos (str, optional): The value representing the &#39;pos&#39; condition. Defaults to &#39;c2&#39;.</span>
<span class="sd">        mix (str, optional): The value representing the &#39;mix&#39; condition. Defaults to &#39;c3&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A string representing the mapped condition:</span>
<span class="sd">             - &#39;neg&#39; if col_value matches the neg parameter.</span>
<span class="sd">             - &#39;pos&#39; if col_value matches the pos parameter.</span>
<span class="sd">             - &#39;mix&#39; if col_value matches the mix parameter.</span>
<span class="sd">             - &#39;screen&#39; if col_value does not match any of the above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">neg</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;neg&#39;</span>
    <span class="k">elif</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;pos&#39;</span>
    <span class="k">elif</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">mix</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;mix&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;screen&#39;</span></div>

    
<div class="viewcode-block" id="download_models">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.download_models">[docs]</a>
<span class="k">def</span> <span class="nf">download_models</span><span class="p">(</span><span class="n">repo_id</span><span class="o">=</span><span class="s2">&quot;einarolafsson/models&quot;</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downloads all model files from Hugging Face and stores them in the `resources/models` directory </span>
<span class="sd">    within the installed `spacr` package.</span>

<span class="sd">    Args:</span>
<span class="sd">        repo_id (str): The repository ID on Hugging Face (default is &#39;einarolafsson/models&#39;).</span>
<span class="sd">        retries (int): Number of retry attempts in case of failure.</span>
<span class="sd">        delay (int): Delay in seconds between retries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The local path to the downloaded models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Construct the path to the `resources/models` directory in the installed `spacr` package</span>
    <span class="n">package_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">spacr_path</span><span class="p">)</span>
    <span class="n">local_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_dir</span><span class="p">,</span> <span class="s1">&#39;resources&#39;</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">)</span>

    <span class="c1"># Create the local directory if it doesn&#39;t exist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">local_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">local_dir</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">local_dir</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(f&quot;Models already downloaded to: {local_dir}&quot;)</span>
        <span class="k">return</span> <span class="n">local_dir</span>

    <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">attempt</span> <span class="o">&lt;</span> <span class="n">retries</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># List all files in the repo</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">list_repo_files</span><span class="p">(</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">repo_type</span><span class="o">=</span><span class="s2">&quot;dataset&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Files in repository: </span><span class="si">{</span><span class="n">files</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging print to check file list</span>

            <span class="c1"># Download each file</span>
            <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">download_attempt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retries</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;https://huggingface.co/datasets/</span><span class="si">{</span><span class="n">repo_id</span><span class="si">}</span><span class="s2">/resolve/main/</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">?download=true&quot;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downloading file from: </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging</span>

                        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HTTP response status: </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging</span>
                        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>

                        <span class="c1"># Save the file locally</span>
                        <span class="n">local_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">local_dir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">iter_content</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">8192</span><span class="p">):</span>
                                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downloaded model file: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">local_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">break</span>  <span class="c1"># Exit the retry loop if successful</span>
                    <span class="k">except</span> <span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">HTTPError</span><span class="p">,</span> <span class="n">requests</span><span class="o">.</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Retrying in </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s2"> seconds...&quot;</span><span class="p">)</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to download </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> after multiple attempts.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">local_dir</span>  <span class="c1"># Return the directory where models are saved</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">HTTPError</span><span class="p">,</span> <span class="n">requests</span><span class="o">.</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading files: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Retrying in </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s2"> seconds...&quot;</span><span class="p">)</span>
            <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Failed to download model files after multiple attempts.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_cytoplasm_mask">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.generate_cytoplasm_mask">[docs]</a>
<span class="k">def</span> <span class="nf">generate_cytoplasm_mask</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a cytoplasm mask from nucleus and cell masks.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - nucleus_mask (np.array): Binary or segmented mask of the nucleus (non-zero values represent nucleus).</span>
<span class="sd">    - cell_mask (np.array): Binary or segmented mask of the whole cell (non-zero values represent cell).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - cytoplasm_mask (np.array): Mask for the cytoplasm (1 for cytoplasm, 0 for nucleus and pathogens).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Make sure the nucleus and cell masks are numpy arrays</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">)</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>
    
    <span class="c1"># Generate cytoplasm mask</span>
    <span class="n">cytoplasm_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">nucleus_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cytoplasm_mask</span></div>


<div class="viewcode-block" id="add_column_to_database">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.add_column_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">add_column_to_database</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a new column to the database table by matching on a common column from the DataFrame.</span>
<span class="sd">    If the column already exists in the database, it adds the column with a suffix.</span>
<span class="sd">    NaN values will remain as NULL in the database.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        settings (dict): A dictionary containing the following keys:</span>
<span class="sd">            csv_path (str): Path to the CSV file with the data to be added.</span>
<span class="sd">            db_path (str): Path to the SQLite database (or connection string for other databases).</span>
<span class="sd">            table_name (str): The name of the table in the database.</span>
<span class="sd">            update_column (str): The name of the new column in the DataFrame to add to the database.</span>
<span class="sd">            match_column (str): The common column used to match rows.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Read the DataFrame from the provided CSV path</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;csv_path&#39;</span><span class="p">])</span>

    <span class="c1"># Replace 0 values with 2 in the update column</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Replacing all 0 values with 2 in the update column.&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Connect to the SQLite database</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;db_path&#39;</span><span class="p">])</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="c1"># Get the existing columns in the database table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PRAGMA table_info(</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">columns_in_db</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>

    <span class="c1"># Add a suffix if the update column already exists in the database</span>
    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">columns_in_db</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">while</span> <span class="n">new_column_name</span> <span class="ow">in</span> <span class="n">columns_in_db</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; already exists. Using new column name: &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_column_name</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span>

    <span class="c1"># Add the new column with INTEGER type to the database table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALTER TABLE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> ADD COLUMN </span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2"> INTEGER&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added new column &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; to the table &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Iterate over the DataFrame and update the new column in the database</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">value_to_update</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span>
        <span class="n">match_value</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]]</span>

        <span class="c1"># Handle NaN values by converting them to None (SQLite equivalent of NULL)</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">value_to_update</span><span class="p">):</span>
            <span class="n">value_to_update</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Prepare and execute the SQL update query</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            UPDATE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span>
<span class="s2">            SET </span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2"> = ?</span>
<span class="s2">            WHERE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> = ?</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="p">(</span><span class="n">value_to_update</span><span class="p">,</span> <span class="n">match_value</span><span class="p">))</span>

    <span class="c1"># Commit the transaction and close the connection</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updated &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; in &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; using &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fill_holes_in_mask">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.fill_holes_in_mask">[docs]</a>
<span class="k">def</span> <span class="nf">fill_holes_in_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill holes in each object in the mask while keeping objects separated.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        mask (np.ndarray): A labeled mask where each object has a unique integer value.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A mask with holes filled and original labels preserved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the mask is integer-labeled</span>
    <span class="n">labeled_mask</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Create an empty mask to store the result</span>
    <span class="n">filled_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labeled_mask</span><span class="p">)</span>

    <span class="c1"># Fill holes for each labeled object independently</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Create a binary mask for the current object</span>
        <span class="n">object_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labeled_mask</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Fill holes within this object</span>
        <span class="n">filled_object</span> <span class="o">=</span> <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">object_mask</span><span class="p">)</span>

        <span class="c1"># Assign the original label back to the filled object</span>
        <span class="n">filled_mask</span><span class="p">[</span><span class="n">filled_object</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">filled_mask</span></div>


<div class="viewcode-block" id="correct_metadata_column_names">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.correct_metadata_column_names">[docs]</a>
<span class="k">def</span> <span class="nf">correct_metadata_column_names</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrects the column names of a given DataFrame to standardize metadata naming conventions.</span>

<span class="sd">    The function performs the following transformations:</span>
<span class="sd">    - Renames &#39;plate_name&#39; to &#39;plateID&#39;.</span>
<span class="sd">    - Renames &#39;column_name&#39; to &#39;columnID&#39;.</span>
<span class="sd">    - Renames &#39;col&#39; to &#39;columnID&#39;.</span>
<span class="sd">    - Renames &#39;row_name&#39; to &#39;rowID&#39;.</span>
<span class="sd">    - Renames &#39;grna_name&#39; to &#39;grna&#39;.</span>
<span class="sd">    - If &#39;plate_row&#39; exists, splits it into two new columns: &#39;plateID&#39; and &#39;rowID&#39;, </span>
<span class="sd">      using an underscore (&#39;_&#39;) as the delimiter.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame containing metadata columns.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame with corrected column names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;plate_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;plate_name&#39;</span><span class="p">:</span> <span class="s1">&#39;plateID&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;column_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="s1">&#39;columnID&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;col&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="s1">&#39;columnID&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;row_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;row_name&#39;</span><span class="p">:</span> <span class="s1">&#39;rowID&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;grna_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;grna_name&#39;</span><span class="p">:</span> <span class="s1">&#39;grna&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;plate_row&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;plateID&#39;</span><span class="p">,</span> <span class="s1">&#39;rowID&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate_row&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="control_filelist">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.control_filelist">[docs]</a>
<span class="k">def</span> <span class="nf">control_filelist</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;02&#39;</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">control_filelist</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;columnID&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;02&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters a list of files in a given folder based on a specified mode and values.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder (str): The path to the folder containing the files to be filtered.</span>
<span class="sd">            mode (str, optional): The filtering mode. Can be &#39;columnID&#39; or &#39;rowID&#39;.</span>
<span class="sd">                - &#39;columnID&#39;: Filters files where the second part of the filename (split by &#39;_&#39;) </span>
<span class="sd">                  has a substring starting from the second character that matches one of the values.</span>
<span class="sd">                - &#39;rowID&#39;: Filters files where the second part of the filename (split by &#39;_&#39;) </span>
<span class="sd">                  has a substring starting from the first character that matches one of the values.</span>
<span class="sd">                Defaults to &#39;columnID&#39;.</span>
<span class="sd">            values (list of str, optional): A list of string values to filter the files by. Defaults to [&#39;01&#39;, &#39;02&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of str: A list of filenames that match the filtering criteria.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If the filenames in the folder do not conform to the expected format </span>
<span class="sd">                        (e.g., missing the second part after splitting by &#39;_&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;columnID&#39;</span><span class="p">:</span>
        <span class="n">filtered_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;rowID&#39;</span><span class="p">:</span>
        <span class="n">filtered_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">filtered_files</span></div>

    
<div class="viewcode-block" id="rename_columns_in_db">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.rename_columns_in_db">[docs]</a>
<span class="k">def</span> <span class="nf">rename_columns_in_db</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Renames specific columns in all user tables of a SQLite database based on a predefined mapping.</span>

<span class="sd">    This function connects to the SQLite database at the given path, retrieves all user-defined tables,</span>
<span class="sd">    and renames columns in those tables according to the `rename_map` dictionary. If a column with the</span>
<span class="sd">    old name exists and the new name does not already exist in the same table, the column is renamed.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The file path to the SQLite database.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - Retrieves all user-defined tables in the database.</span>
<span class="sd">        - For each table, checks the column names against the `rename_map`.</span>
<span class="sd">        - Renames columns as specified in the `rename_map` if conditions are met.</span>
<span class="sd">        - Commits the changes to the database.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The `rename_map` dictionary defines the mapping of old column names to new column names.</span>
<span class="sd">        - If a column with the new name already exists in a table, the old column will not be renamed.</span>
<span class="sd">        - The function uses SQLite&#39;s `ALTER TABLE ... RENAME COLUMN` syntax, which requires SQLite version 3.25.0 or higher.</span>

<span class="sd">    Example:</span>
<span class="sd">        rename_columns_in_db(&quot;/path/to/database.db&quot;)</span>

<span class="sd">    Raises:</span>
<span class="sd">        sqlite3.OperationalError: If there are issues executing SQL commands, such as unsupported SQLite versions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># map old column names → new names</span>
    <span class="n">rename_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;row&#39;</span><span class="p">:</span>      <span class="s1">&#39;rowID&#39;</span><span class="p">,</span>
        <span class="s1">&#39;column&#39;</span><span class="p">:</span>   <span class="s1">&#39;columnID&#39;</span><span class="p">,</span>
        <span class="s1">&#39;col&#39;</span><span class="p">:</span>      <span class="s1">&#39;columnID&#39;</span><span class="p">,</span>
        <span class="s1">&#39;plate&#39;</span><span class="p">:</span>    <span class="s1">&#39;plateID&#39;</span><span class="p">,</span>
        <span class="s1">&#39;field&#39;</span><span class="p">:</span>    <span class="s1">&#39;fieldID&#39;</span><span class="p">,</span>
        <span class="s1">&#39;channel&#39;</span><span class="p">:</span>  <span class="s1">&#39;chanID&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="c1"># 1) get all user tables</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;</span><span class="p">)</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>

    <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">:</span>
        <span class="c1"># 2) get column names only</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PRAGMA table_info(`</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">`);&quot;</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>

        <span class="c1"># 3) for each old→new, if the old exists and new does not, rename it</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">old</span> <span class="ow">in</span> <span class="n">cols</span> <span class="ow">and</span> <span class="n">new</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">sql</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ALTER TABLE `</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">` RENAME COLUMN `</span><span class="si">{</span><span class="n">old</span><span class="si">}</span><span class="s2">` TO `</span><span class="si">{</span><span class="n">new</span><span class="si">}</span><span class="s2">`;&quot;</span>
                <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Renamed `</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">`.`</span><span class="si">{</span><span class="n">old</span><span class="si">}</span><span class="s2">` → `</span><span class="si">{</span><span class="n">new</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>

    <span class="n">con</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>    </div>

        
<div class="viewcode-block" id="group_feature_class">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.group_feature_class">[docs]</a>
<span class="k">def</span> <span class="nf">group_feature_class</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">feature_groups</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;compartment&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Groups features in a DataFrame into specified categories and calculates the summed importance for each group.</span>
<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The input DataFrame containing at least the columns &#39;feature&#39; and &#39;importance&#39;.</span>
<span class="sd">        feature_groups (list of str, optional): A list of strings representing the feature groups to classify.</span>
<span class="sd">            Defaults to [&#39;cell&#39;, &#39;cytoplasm&#39;, &#39;nucleus&#39;, &#39;pathogen&#39;].</span>
<span class="sd">        name (str, optional): The name of the new column to store the feature group classification.</span>
<span class="sd">            Defaults to &#39;compartment&#39;.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The modified DataFrame with a new column for the feature group classification and</span>
<span class="sd">            summed importance for each group.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function uses regex matching to classify features into the specified groups.</span>
<span class="sd">        - If a feature matches multiple groups, the groups are concatenated with a hyphen.</span>
<span class="sd">        - If the `name` parameter is set to &#39;channel&#39;, missing values in the &#39;channel&#39; column are filled with &#39;morphology&#39;.</span>
<span class="sd">        - A summary DataFrame is created with the summed importance for each group, including a row for the total importance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Function to determine compartment based on multiple matches</span>
    <span class="k">def</span> <span class="nf">find_feature_class</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">compartments</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartment</span> <span class="k">for</span> <span class="n">compartment</span> <span class="ow">in</span> <span class="n">compartments</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">compartment</span><span class="p">,</span> <span class="n">feature</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">spacrGraph</span>

    <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">find_feature_class</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">feature_groups</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;channel&#39;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;morphology&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Create new DataFrame with summed importance for each compartment and channel</span>
    <span class="n">importance_sum</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="s1">&#39;importance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_importance_sum&#39;</span><span class="p">)</span>
    <span class="n">total_compartment_importance</span> <span class="o">=</span> <span class="n">importance_sum</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_importance_sum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">importance_sum</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">importance_sum</span><span class="p">,</span>
         <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
             <span class="p">[{</span><span class="n">name</span><span class="p">:</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_importance_sum&#39;</span><span class="p">:</span> <span class="n">total_compartment_importance</span><span class="p">}])]</span>
        <span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="delete_intermedeate_files">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.delete_intermedeate_files">[docs]</a>
<span class="k">def</span> <span class="nf">delete_intermedeate_files</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deletes intermediate files and directories specified in the settings dictionary.</span>
<span class="sd">    This function removes a set of predefined directories under the source path (`src`) </span>
<span class="sd">    provided in the `settings` dictionary. It ensures that the directories exist before </span>
<span class="sd">    attempting to delete them. If any directory cannot be deleted, an error message is </span>
<span class="sd">    printed, and the user is advised to delete it manually.</span>
<span class="sd">    Args:</span>
<span class="sd">        settings (dict): A dictionary containing configuration settings. It must include </span>
<span class="sd">                         the key &#39;src&#39;, which specifies the base directory containing </span>
<span class="sd">                         the intermediate files and directories to be deleted.</span>
<span class="sd">    Behavior:</span>
<span class="sd">        - Checks if the &#39;src&#39; key exists in the `settings` dictionary.</span>
<span class="sd">        - Verifies that the `src` directory and the `orig` subdirectory exist.</span>
<span class="sd">        - Deletes the following subdirectories under `src` if they exist:</span>
<span class="sd">          - &#39;stack&#39;</span>
<span class="sd">          - &#39;masks&#39;</span>
<span class="sd">          - &#39;1&#39;, &#39;2&#39;, ..., &#39;10&#39;</span>
<span class="sd">        - Prints a success message for each deleted directory.</span>
<span class="sd">        - Prints an error message if a directory cannot be deleted or does not exist.</span>
<span class="sd">    Notes:</span>
<span class="sd">        - The function compares the lengths of the `merged_stack` and `path_stack` </span>
<span class="sd">          directories to determine whether to proceed with deletion.</span>
<span class="sd">        - If the `src` directory or the `orig` subdirectory does not exist, the function </span>
<span class="sd">          exits with an appropriate message.</span>
<span class="sd">    Raises:</span>
<span class="sd">        None: Any exceptions during directory deletion are caught and logged as error </span>
<span class="sd">              messages.</span>
<span class="sd">    Example:</span>
<span class="sd">        settings = {&#39;src&#39;: &#39;/path/to/source&#39;}</span>
<span class="sd">        delete_intermedeate_files(settings)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">path_orig</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;orig&#39;</span><span class="p">)</span>
    <span class="n">path_stack</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;stack&#39;</span><span class="p">)</span>
    <span class="n">merged_stack</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;merged&#39;</span><span class="p">)</span>
    <span class="n">path_norm_chan_stack</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span>
    <span class="n">path_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
    <span class="n">path_2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">)</span>
    <span class="n">path_3</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
    <span class="n">path_4</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;4&#39;</span><span class="p">)</span>
    <span class="n">path_5</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;5&#39;</span><span class="p">)</span>
    <span class="n">path_6</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;6&#39;</span><span class="p">)</span>
    <span class="n">path_7</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;7&#39;</span><span class="p">)</span>
    <span class="n">path_8</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;8&#39;</span><span class="p">)</span>
    <span class="n">path_9</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;9&#39;</span><span class="p">)</span>
    <span class="n">path_10</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="s1">&#39;10&#39;</span><span class="p">)</span>
    
    <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">path_norm_chan_stack</span><span class="p">,</span> <span class="n">path_1</span><span class="p">,</span> <span class="n">path_2</span><span class="p">,</span> <span class="n">path_3</span><span class="p">,</span> <span class="n">path_4</span><span class="p">,</span> <span class="n">path_5</span><span class="p">,</span> <span class="n">path_6</span><span class="p">,</span> <span class="n">path_7</span><span class="p">,</span> <span class="n">path_8</span><span class="p">,</span> <span class="n">path_9</span><span class="p">,</span> <span class="n">path_10</span><span class="p">]</span>
    
    <span class="n">merged_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_stack</span><span class="p">)</span>
    <span class="n">stack_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">merged_len</span> <span class="o">==</span> <span class="n">stack_len</span> <span class="ow">and</span> <span class="n">stack_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;src&#39;</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_orig</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleted </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> could not be deleted: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Delete manually.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_orig</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No &#39;src&#39; key in settings dictionary.&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="filter_and_save_csv">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.filter_and_save_csv">[docs]</a>
<span class="k">def</span> <span class="nf">filter_and_save_csv</span><span class="p">(</span><span class="n">input_csv</span><span class="p">,</span> <span class="n">output_csv</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">upper_threshold</span><span class="p">,</span> <span class="n">lower_threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a CSV into a DataFrame, filters rows based on a column for values &gt; upper_threshold and &lt; lower_threshold,</span>
<span class="sd">    and saves the filtered DataFrame to a new CSV file.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        input_csv (str): Path to the input CSV file.</span>
<span class="sd">        output_csv (str): Path to save the filtered CSV file.</span>
<span class="sd">        column_name (str): Column name to apply the filters on.</span>
<span class="sd">        upper_threshold (float): Upper threshold for filtering (values greater than this are retained).</span>
<span class="sd">        lower_threshold (float): Lower threshold for filtering (values less than this are retained).</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the input CSV file into a DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_csv</span><span class="p">)</span>

    <span class="c1"># Filter rows based on the thresholds</span>
    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">upper_threshold</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower_threshold</span><span class="p">)]</span>

    <span class="c1"># Save the filtered DataFrame to a new CSV file</span>
    <span class="n">filtered_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">filtered_df</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtered DataFrame saved to </span><span class="si">{</span><span class="n">output_csv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="extract_tar_bz2_files">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.extract_tar_bz2_files">[docs]</a>
<span class="k">def</span> <span class="nf">extract_tar_bz2_files</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts all .tar.bz2 files in the given folder into subfolders with the same name as the tar file.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        folder_path (str): Path to the folder containing .tar.bz2 files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The provided path &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39; is not a valid folder.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Iterate over files in the folder</span>
    <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.tar.bz2&#39;</span><span class="p">):</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="n">extract_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1"># Create the subfolder for extraction if it doesn&#39;t exist</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">extract_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Extract the tar.bz2 file</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r:bz2&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
                    <span class="n">tar</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">extract_folder</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">extract_folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to extract </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

            
            
<div class="viewcode-block" id="calculate_shortest_distance">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.calculate_shortest_distance">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_shortest_distance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">object1</span><span class="p">,</span> <span class="n">object2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the shortest edge-to-edge distance between two objects (e.g., pathogen and nucleus).</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - df: Pandas DataFrame containing measurements</span>
<span class="sd">    - object1: String, name of the first object (e.g., &quot;pathogen&quot;)</span>
<span class="sd">    - object2: String, name of the second object (e.g., &quot;nucleus&quot;)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - df: Pandas DataFrame with a new column for shortest edge-to-edge distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute centroid-to-centroid Euclidean distance</span>
    <span class="n">centroid_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object1</span><span class="si">}</span><span class="s1">_channel_0_centroid_weighted-0&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object2</span><span class="si">}</span><span class="s1">_channel_0_centroid_weighted-0&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object1</span><span class="si">}</span><span class="s1">_channel_0_centroid_weighted-1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object2</span><span class="si">}</span><span class="s1">_channel_0_centroid_weighted-1&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
    <span class="p">)</span>

    <span class="c1"># Estimate object radii using Feret diameters</span>
    <span class="n">object1_radius</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object1</span><span class="si">}</span><span class="s1">_feret_diameter_max&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">object2_radius</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object2</span><span class="si">}</span><span class="s1">_feret_diameter_max&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Compute shortest edge-to-edge distance</span>
    <span class="n">shortest_distance</span> <span class="o">=</span> <span class="n">centroid_distance</span> <span class="o">-</span> <span class="p">(</span><span class="n">object1_radius</span> <span class="o">+</span> <span class="n">object2_radius</span><span class="p">)</span>

    <span class="c1"># Ensure distances are non-negative (overlapping objects should have distance 0)</span>
    <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object1</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">object2</span><span class="si">}</span><span class="s1">_shortest_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">shortest_distance</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="format_path_for_system">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.format_path_for_system">[docs]</a>
<span class="k">def</span> <span class="nf">format_path_for_system</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a file path and reformats it to be compatible with the current operating system.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        path (str): The file path to be formatted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The formatted path for the current operating system.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
    
    <span class="c1"># Convert Windows-style paths to Unix-style (Linux/macOS)</span>
    <span class="k">if</span> <span class="n">system</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Linux&quot;</span><span class="p">,</span> <span class="s2">&quot;Darwin&quot;</span><span class="p">]:</span>  <span class="c1"># Darwin is macOS</span>
        <span class="n">formatted_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
    
    <span class="c1"># Convert Unix-style paths to Windows-style</span>
    <span class="k">elif</span> <span class="n">system</span> <span class="o">==</span> <span class="s2">&quot;Windows&quot;</span><span class="p">:</span>
        <span class="n">formatted_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported OS: </span><span class="si">{</span><span class="n">system</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Normalize path to ensure consistency</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">formatted_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">new_path</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found path: </span><span class="si">{</span><span class="n">new_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path not found: </span><span class="si">{</span><span class="n">new_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_path</span></div>



<div class="viewcode-block" id="normalize_src_path">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.normalize_src_path">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_src_path</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensures that the &#39;src&#39; value is properly formatted as either a list of strings or a single string.</span>

<span class="sd">    Args:</span>
<span class="sd">        src (str or list): The input source path(s).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list or str: A correctly formatted list if the input was a list (or string representation of a list),</span>
<span class="sd">                     otherwise a single string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">src</span>  <span class="c1"># Already a list, return as-is</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if it is a string representation of a list</span>
            <span class="n">evaluated_src</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">evaluated_src</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">evaluated_src</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evaluated_src</span>  <span class="c1"># Convert to real list</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">SyntaxError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">pass</span>  <span class="c1"># Not a valid list, treat as a string</span>

        <span class="k">return</span> <span class="n">src</span>  <span class="c1"># Return as a string if not a list</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type for &#39;src&#39;: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, expected str or list&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_image_path_map">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.generate_image_path_map">[docs]</a>
<span class="k">def</span> <span class="nf">generate_image_path_map</span><span class="p">(</span><span class="n">root_folder</span><span class="p">,</span> <span class="n">valid_extensions</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;tif&quot;</span><span class="p">,</span> <span class="s2">&quot;tiff&quot;</span><span class="p">,</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="s2">&quot;jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;jpeg&quot;</span><span class="p">,</span> <span class="s2">&quot;bmp&quot;</span><span class="p">,</span> <span class="s2">&quot;czi&quot;</span><span class="p">,</span> <span class="s2">&quot;nd2&quot;</span><span class="p">,</span> <span class="s2">&quot;lif&quot;</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively scans a folder and its subfolders for images, then creates a mapping of:</span>
<span class="sd">    {original_image_path: new_image_path}, where the new path includes all subfolder names.</span>

<span class="sd">    Args:</span>
<span class="sd">        root_folder (str): The root directory to scan for images.</span>
<span class="sd">        valid_extensions (tuple): Tuple of valid image file extensions.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary mapping original image paths to their new paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image_path_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">root_folder</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">valid_extensions</span><span class="p">:</span>
                <span class="c1"># Get relative path of the image from root_folder</span>
                <span class="n">relative_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">root_folder</span><span class="p">)</span>
                
                <span class="c1"># Construct new filename: Embed folder hierarchy into the name</span>
                <span class="n">folder_parts</span> <span class="o">=</span> <span class="n">relative_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>  <span class="c1"># Get all folder names</span>
                <span class="n">folder_info</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_parts</span><span class="p">)</span> <span class="k">if</span> <span class="n">folder_parts</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># Join with underscores</span>
                
                <span class="c1"># Generate new filename</span>
                <span class="n">new_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">folder_info</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">folder_info</span> <span class="k">else</span> <span class="n">file</span>

                <span class="c1"># Store in dictionary (original path -&gt; new path)</span>
                <span class="n">original_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_folder</span><span class="p">,</span> <span class="n">new_filename</span><span class="p">)</span>
                <span class="n">image_path_map</span><span class="p">[</span><span class="n">original_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_path</span>

    <span class="k">return</span> <span class="n">image_path_map</span></div>


<div class="viewcode-block" id="copy_images_to_consolidated">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.copy_images_to_consolidated">[docs]</a>
<span class="k">def</span> <span class="nf">copy_images_to_consolidated</span><span class="p">(</span><span class="n">image_path_map</span><span class="p">,</span> <span class="n">root_folder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies images from their original locations to a &#39;consolidated&#39; folder,</span>
<span class="sd">    renaming them according to the generated dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_path_map (dict): Dictionary mapping {original_path: new_path}.</span>
<span class="sd">        root_folder (str): The root directory where the &#39;consolidated&#39; folder will be created.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">consolidated_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_folder</span><span class="p">,</span> <span class="s2">&quot;consolidated&quot;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">consolidated_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Ensure &#39;consolidated&#39; folder exists</span>
    <span class="n">files_processed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_path_map</span><span class="p">)</span>
    <span class="n">time_ls</span><span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">original_path</span><span class="p">,</span> <span class="n">new_path</span> <span class="ow">in</span> <span class="n">image_path_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">new_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>  <span class="c1"># Extract only the new filename</span>
        <span class="n">new_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">consolidated_folder</span><span class="p">,</span> <span class="n">new_filename</span><span class="p">)</span>  <span class="c1"># Place in &#39;consolidated&#39; folder</span>
        
        <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">original_path</span><span class="p">,</span> <span class="n">new_file_path</span><span class="p">)</span>  <span class="c1"># Copy file with metadata preserved</span>
        
        <span class="n">files_processed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">time_ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        
        <span class="n">print_progress</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="n">files_to_process</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="n">time_ls</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Consolidating images&#39;</span><span class="p">)</span></div>

        <span class="c1">#print(f&quot;Copied: {original_path} -&gt; {new_file_path}&quot;)</span>
        
<div class="viewcode-block" id="correct_metadata">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.correct_metadata">[docs]</a>
<span class="k">def</span> <span class="nf">correct_metadata</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrects and standardizes the metadata column names in a DataFrame.</span>
<span class="sd">    This function checks for specific column names in the input DataFrame and </span>
<span class="sd">    renames or maps them to standardized names for consistency. The following </span>
<span class="sd">    transformations are applied:</span>
<span class="sd">    - If &#39;object_name&#39; exists, it is mapped to &#39;objectID&#39;.</span>
<span class="sd">    - If &#39;field_name&#39; exists, it is mapped to &#39;fieldID&#39;.</span>
<span class="sd">    - If &#39;plate&#39; or &#39;plate_name&#39; exists, they are mapped to &#39;plateID&#39;.</span>
<span class="sd">    - If &#39;row&#39; or &#39;row_name&#39; exists, they are renamed to &#39;rowID&#39;.</span>
<span class="sd">    - If &#39;col&#39;, &#39;column&#39;, or &#39;column_name&#39; exists, they are renamed to &#39;columnID&#39;.</span>
<span class="sd">    - If &#39;field&#39; or &#39;field_name&#39; exists, they are renamed to &#39;fieldID&#39;.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame containing metadata columns.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The DataFrame with standardized metadata column names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#if &#39;object&#39; in df.columns:</span>
    <span class="c1">#    df[&#39;objectID&#39;] = df[&#39;object&#39;]</span>
        
    <span class="k">if</span> <span class="s1">&#39;object_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;objectID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object_name&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;field_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fieldID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field_name&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;plate&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;plate_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plateID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate_name&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;row&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;row&#39;</span><span class="p">:</span> <span class="s1">&#39;rowID&#39;</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="s1">&#39;row_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;row_name&#39;</span><span class="p">:</span> <span class="s1">&#39;rowID&#39;</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="s1">&#39;col&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="s1">&#39;columnID&#39;</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="s1">&#39;column&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;column&#39;</span><span class="p">:</span> <span class="s1">&#39;columnID&#39;</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="s1">&#39;column_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="s1">&#39;columnID&#39;</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="s1">&#39;field&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;field&#39;</span><span class="p">:</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">})</span>

    <span class="k">if</span> <span class="s1">&#39;field_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;field_name&#39;</span><span class="p">:</span> <span class="s1">&#39;fieldID&#39;</span><span class="p">})</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="remove_outliers_by_group">
<a class="viewcode-back" href="../../api/spacr/utils/index.html#spacr.utils.remove_outliers_by_group">[docs]</a>
<span class="k">def</span> <span class="nf">remove_outliers_by_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_col</span><span class="p">,</span> <span class="n">value_col</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;iqr&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes outliers from `value_col` within each group defined by `group_col`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): The input DataFrame.</span>
<span class="sd">        group_col (str): Column name to group by.</span>
<span class="sd">        value_col (str): Column containing values to check for outliers.</span>
<span class="sd">        method (str): &#39;iqr&#39; or &#39;zscore&#39;.</span>
<span class="sd">        threshold (float): Threshold multiplier for IQR (default 1.5) or z-score.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with outliers removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">iqr_filter</span><span class="p">(</span><span class="n">subdf</span><span class="p">):</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">q3</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span>
        <span class="n">iqr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">-</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">iqr</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">+</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">iqr</span>
        <span class="k">return</span> <span class="n">subdf</span><span class="p">[(</span><span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">zscore_filter</span><span class="p">(</span><span class="n">subdf</span><span class="p">):</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">subdf</span><span class="p">[(</span><span class="n">subdf</span><span class="p">[</span><span class="n">value_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">std</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;iqr&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_col</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">iqr_filter</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;zscore&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_col</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">zscore_filter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;iqr&#39; or &#39;zscore&#39;&quot;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>