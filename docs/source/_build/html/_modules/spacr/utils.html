

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spacr.utils &mdash; spacr Models already downloaded to: /home/carruthers/anaconda3/envs/spacr/lib/python3.9/site-packages/spacr/resources/models
0.3.81 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=2eab0ada"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            spacr
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">spacr</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">spacr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spacr.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spacr.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">sqlite3</span><span class="o">,</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">torchvision</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">string</span><span class="o">,</span> <span class="nn">shutil</span><span class="o">,</span> <span class="nn">cv2</span><span class="o">,</span> <span class="nn">tarfile</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">psutil</span><span class="o">,</span> <span class="nn">platform</span><span class="o">,</span> <span class="nn">gzip</span><span class="o">,</span> <span class="nn">subprocess</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">requests</span><span class="o">,</span> <span class="nn">ast</span><span class="o">,</span> <span class="nn">traceback</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">cellpose</span> <span class="kn">import</span> <span class="n">models</span> <span class="k">as</span> <span class="n">cp_models</span>
<span class="kn">from</span> <span class="nn">cellpose</span> <span class="kn">import</span> <span class="n">denoise</span>

<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops_table</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">measure</span>
<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span> <span class="k">as</span> <span class="n">resizescikit</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">square</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">find_contours</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.outliers_influence</span> <span class="kn">import</span> <span class="n">variance_inflation_factor</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="kn">import</span> <span class="n">durbin_watson</span>
<span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.multitest</span> <span class="kn">import</span> <span class="n">multipletests</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">,</span> <span class="n">set_start_method</span><span class="p">,</span> <span class="n">get_start_method</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">torch.utils.checkpoint</span> <span class="kn">import</span> <span class="n">checkpoint</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Subset</span>
<span class="kn">from</span> <span class="nn">torch.autograd</span> <span class="kn">import</span> <span class="n">grad</span>

<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">torchvision.models.resnet</span> <span class="kn">import</span> <span class="n">ResNet18_Weights</span><span class="p">,</span> <span class="n">ResNet34_Weights</span><span class="p">,</span> <span class="n">ResNet50_Weights</span><span class="p">,</span> <span class="n">ResNet101_Weights</span><span class="p">,</span> <span class="n">ResNet152_Weights</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.models</span> <span class="kn">import</span> <span class="n">resnet50</span>
<span class="kn">from</span> <span class="nn">torchvision.utils</span> <span class="kn">import</span> <span class="n">make_grid</span>

<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.offsetbox</span> <span class="kn">import</span> <span class="n">OffsetImage</span><span class="p">,</span> <span class="n">AnnotationBbox</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndi</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">fisher_exact</span><span class="p">,</span> <span class="n">f_oneway</span><span class="p">,</span> <span class="n">kruskal</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">splprep</span><span class="p">,</span> <span class="n">splev</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">binary_dilation</span><span class="p">,</span> <span class="n">binary_fill_holes</span>

<span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">auc</span><span class="p">,</span> <span class="n">precision_recall_curve</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span><span class="p">,</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span><span class="p">,</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>

<span class="kn">from</span> <span class="nn">huggingface_hub</span> <span class="kn">import</span> <span class="n">list_repo_files</span>
<span class="kn">from</span> <span class="nn">spacr</span> <span class="kn">import</span> <span class="vm">__file__</span> <span class="k">as</span> <span class="n">spacr_path</span>

<span class="kn">import</span> <span class="nn">umap.umap_</span> <span class="k">as</span> <span class="nn">umap</span>
<span class="c1">#import umap</span>

<div class="viewcode-block" id="filepaths_to_database">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.filepaths_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">filepaths_to_database</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">crop_mode</span><span class="p">):</span>

    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>

    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;timelapse&#39;</span><span class="p">])))</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;timelapse&#39;</span><span class="p">]:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;time_id&#39;</span><span class="p">]</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;nucleus_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pathogen_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cytoplasm_id&#39;</span><span class="p">]</span>

    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s1">/measurements/measurements.db&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">png_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="activation_maps_to_database">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.activation_maps_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">activation_maps_to_database</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_create_database</span>

    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>
    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">database_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/measurements/</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">.db&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">database_name</span><span class="p">):</span>
        <span class="n">_create_database</span><span class="p">(</span><span class="n">database_name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">database_name</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">png_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cam_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_list&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="activation_correlations_to_database">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.activation_correlations_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">activation_correlations_to_database</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">img_paths</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_create_database</span>

    <span class="n">png_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">img_paths</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">])</span>
    <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells_png</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
    <span class="n">png_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span>

    <span class="c1"># Align both DataFrames by file_name</span>
    <span class="n">png_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">png_df</span><span class="p">,</span> <span class="n">df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">merged_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">database_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/measurements/</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">.db&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">database_name</span><span class="p">):</span>
        <span class="n">_create_database</span><span class="p">(</span><span class="n">database_name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">database_name</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cam_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_correlations&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SQLite error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span></div>


<div class="viewcode-block" id="calculate_activation_correlations">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.calculate_activation_correlations">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_activation_correlations</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">activation_maps</span><span class="p">,</span> <span class="n">file_names</span><span class="p">,</span> <span class="n">manders_thresholds</span><span class="o">=</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates Pearson and Manders correlations between input image channels and activation map channels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        inputs: A batch of input images, Tensor of shape (batch_size, channels, height, width)</span>
<span class="sd">        activation_maps: A batch of activation maps, Tensor of shape (batch_size, channels, height, width)</span>
<span class="sd">        file_names: List of file names corresponding to each image in the batch.</span>
<span class="sd">        manders_thresholds: List of intensity percentiles to calculate Manders correlation.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        df_correlations: A DataFrame with columns for pairwise correlations (Pearson and Manders) </span>
<span class="sd">                         between input channels and activation map channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Ensure tensors are detached and moved to CPU before converting to numpy</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

    <span class="n">batch_size</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="k">if</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># If activation maps have no channels, add a dummy channel dimension</span>
        <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Now shape is (batch_size, 1, height, width)</span>
    
    <span class="n">_</span><span class="p">,</span> <span class="n">act_channels</span><span class="p">,</span> <span class="n">act_height</span><span class="p">,</span> <span class="n">act_width</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Ensure that the inputs and activation maps are the same size</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">height</span> <span class="o">!=</span> <span class="n">act_height</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">width</span> <span class="o">!=</span> <span class="n">act_width</span><span class="p">):</span>
        <span class="n">activation_maps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">activation_maps</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>

    <span class="c1"># Dictionary to collect correlation results</span>
    <span class="n">correlations_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;file_name&#39;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="c1"># Initialize correlation columns based on input channels and activation map channels</span>
    <span class="k">for</span> <span class="n">in_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_channels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">act_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">act_channels</span><span class="p">):</span>
            <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_pearsons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">manders_thresholds</span><span class="p">:</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Loop over the batch</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
        <span class="n">input_img</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>  <span class="c1"># Input image channels (C, H, W)</span>
        <span class="n">activation_map</span> <span class="o">=</span> <span class="n">activation_maps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>  <span class="c1"># Activation map channels (C, H, W)</span>

        <span class="c1"># Add the file name to the current row</span>
        <span class="n">correlations_dict</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_names</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

        <span class="c1"># Calculate correlations for each channel pair</span>
        <span class="k">for</span> <span class="n">in_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_channels</span><span class="p">):</span>
            <span class="n">input_channel</span> <span class="o">=</span> <span class="n">input_img</span><span class="p">[</span><span class="n">in_c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Flatten the input image channel</span>
            <span class="n">input_channel</span> <span class="o">=</span> <span class="n">input_channel</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">input_channel</span><span class="p">)]</span>  <span class="c1"># Remove NaN or inf values</span>

            <span class="k">for</span> <span class="n">act_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">act_channels</span><span class="p">):</span>
                <span class="n">activation_channel</span> <span class="o">=</span> <span class="n">activation_map</span><span class="p">[</span><span class="n">act_c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Flatten the activation map channel</span>
                <span class="n">activation_channel</span> <span class="o">=</span> <span class="n">activation_channel</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">)]</span>  <span class="c1"># Remove NaN or inf values</span>

                <span class="c1"># Check if there are valid (non-empty) arrays left to calculate the Pearson correlation</span>
                <span class="k">if</span> <span class="n">input_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">activation_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pearson_corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">input_channel</span><span class="p">,</span> <span class="n">activation_channel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pearson_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Assign NaN if there are no valid data points</span>
                <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_pearsons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pearson_corr</span><span class="p">)</span>

                <span class="c1"># Compute Manders correlations for each threshold</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">manders_thresholds</span><span class="p">:</span>
                    <span class="c1"># Get the top percentile pixels based on intensity in both channels</span>
                    <span class="k">if</span> <span class="n">input_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">activation_channel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">input_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">input_channel</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
                        <span class="n">activation_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

                        <span class="c1"># Mask the pixels above the threshold</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_channel</span> <span class="o">&gt;=</span> <span class="n">input_threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">activation_channel</span> <span class="o">&gt;=</span> <span class="n">activation_threshold</span><span class="p">)</span>

                        <span class="c1"># If we have enough pixels, calculate Manders correlation</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">activation_channel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                            <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">manders_corr_M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">manders_corr_M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                    <span class="c1"># Store the Manders correlation for this threshold</span>
                    <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">manders_corr_M1</span><span class="p">)</span>
                    <span class="n">correlations_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">in_c</span><span class="si">}</span><span class="s1">_activation_</span><span class="si">{</span><span class="n">act_c</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">_M2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">manders_corr_M2</span><span class="p">)</span>

    <span class="c1"># Convert the dictionary to a DataFrame</span>
    <span class="n">df_correlations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">correlations_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_correlations</span></div>


<div class="viewcode-block" id="load_settings">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.load_settings">[docs]</a>
<span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setting_key</span><span class="o">=</span><span class="s1">&#39;setting_key&#39;</span><span class="p">,</span> <span class="n">setting_value</span><span class="o">=</span><span class="s1">&#39;setting_value&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a CSV file with &#39;settings_key&#39; and &#39;settings_value&#39; columns into a dictionary.</span>
<span class="sd">    Handles special cases where values are lists, tuples, booleans, None, integers, floats, and nested dictionaries.</span>

<span class="sd">    Args:</span>
<span class="sd">        csv_file_path (str): The path to the CSV file.</span>
<span class="sd">        show (bool): Whether to display the dataframe (for debugging).</span>
<span class="sd">        setting_key (str): The name of the column that contains the setting keys.</span>
<span class="sd">        setting_value (str): The name of the column that contains the setting values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where &#39;settings_key&#39; are the keys and &#39;settings_value&#39; are the values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the CSV file into a DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Ensure the columns &#39;setting_key&#39; and &#39;setting_value&#39; exist</span>
    <span class="k">if</span> <span class="n">setting_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">setting_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CSV file must contain </span><span class="si">{</span><span class="n">setting_key</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">setting_value</span><span class="si">}</span><span class="s2"> columns.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the string value into the appropriate Python data type.&quot;&quot;&quot;</span>
        <span class="c1"># Handle empty values</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Handle boolean values</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Handle lists, tuples, dictionaries, and other literals</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;{&#39;</span><span class="p">)):</span>  <span class="c1"># If it starts with (, [ or {, use ast.literal_eval</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parsed_value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="c1"># If parsed_value is a dict, recursively parse its values</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsed_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">parsed_value</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">parsed_value</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">return</span> <span class="n">parsed_value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">SyntaxError</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># If there&#39;s an error, return the value as-is</span>
        
        <span class="c1"># Handle numeric values (integers and floats)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># If it contains a dot, convert to float</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># Otherwise, convert to integer</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># If it&#39;s not a valid number, return the value as-is</span>

        <span class="c1"># Return the original value if no other type matched</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Convert the DataFrame to a dictionary, with parsing of each value</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">setting_key</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">setting_value</span><span class="p">])}</span>

    <span class="k">return</span> <span class="n">result_dict</span></div>



<div class="viewcode-block" id="save_settings">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.save_settings">[docs]</a>
<span class="k">def</span> <span class="nf">save_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;settings&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">settings_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Key&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">settings_df</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#if os.path.exists(src):</span>

        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_list&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span>

    <span class="n">settings_csv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;settings&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;settings&#39;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">settings_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">settings_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_progress">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.print_progress">[docs]</a>
<span class="k">def</span> <span class="nf">print_progress</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="n">files_to_process</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">files_processed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">files_processed</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_processed</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">files_processed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">files_processed</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">files_processed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">files_to_process</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">files_to_process</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">files_to_process</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">time_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_ls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">average_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">time_ls</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_ls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">time_left</span> <span class="o">=</span> <span class="p">(((</span><span class="n">files_to_process</span> <span class="o">-</span> <span class="n">files_processed</span><span class="p">)</span> <span class="o">*</span> <span class="n">average_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_jobs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Time/image: </span><span class="si">{</span><span class="n">average_time</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time_left: </span><span class="si">{</span><span class="n">time_left</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> min.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">average_time_img</span> <span class="o">=</span> <span class="n">average_time</span> <span class="o">/</span> <span class="n">batch_size</span>
            <span class="n">time_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Time/batch: </span><span class="si">{</span><span class="n">average_time</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time/image: </span><span class="si">{</span><span class="n">average_time_img</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">sec, Time_left: </span><span class="si">{</span><span class="n">time_left</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> min.&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_info</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Progress: </span><span class="si">{</span><span class="n">files_processed</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">files_to_process</span><span class="si">}</span><span class="s1">, operation_type: </span><span class="si">{</span><span class="n">operation_type</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">time_info</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="reset_mp">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.reset_mp">[docs]</a>
<span class="k">def</span> <span class="nf">reset_mp</span><span class="p">():</span>
    <span class="n">current_method</span> <span class="o">=</span> <span class="n">get_start_method</span><span class="p">()</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">system</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">current_method</span> <span class="o">!=</span> <span class="s1">&#39;spawn&#39;</span><span class="p">:</span>
            <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">system</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Linux&#39;</span><span class="p">,</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">):</span>  <span class="c1"># Darwin is macOS</span>
        <span class="k">if</span> <span class="n">current_method</span> <span class="o">!=</span> <span class="s1">&#39;fork&#39;</span><span class="p">:</span>
            <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;fork&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_multiprocessing_process">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.is_multiprocessing_process">[docs]</a>
<span class="k">def</span> <span class="nf">is_multiprocessing_process</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Check if the process is a multiprocessing process. &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">process</span><span class="o">.</span><span class="n">cmdline</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;multiprocessing&#39;</span> <span class="ow">in</span> <span class="n">cmd</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">psutil</span><span class="o">.</span><span class="n">NoSuchProcess</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">AccessDenied</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">ZombieProcess</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="close_file_descriptors">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.close_file_descriptors">[docs]</a>
<span class="k">def</span> <span class="nf">close_file_descriptors</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Close file descriptors and shared memory objects. &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">resource</span>

    <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_NOFILE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">soft</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="close_multiprocessing_processes">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.close_multiprocessing_processes">[docs]</a>
<span class="k">def</span> <span class="nf">close_multiprocessing_processes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Close all multiprocessing processes. &quot;&quot;&quot;</span>
    <span class="n">current_pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">psutil</span><span class="o">.</span><span class="n">process_iter</span><span class="p">([</span><span class="s1">&#39;pid&#39;</span><span class="p">,</span> <span class="s1">&#39;cmdline&#39;</span><span class="p">]):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Skip the current process</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_pid</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Check if the process is a multiprocessing process</span>
            <span class="k">if</span> <span class="n">is_multiprocessing_process</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Wait up to 5 seconds for the process to terminate</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Terminated process </span><span class="si">{</span><span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">except</span> <span class="p">(</span><span class="n">psutil</span><span class="o">.</span><span class="n">NoSuchProcess</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">AccessDenied</span><span class="p">,</span> <span class="n">psutil</span><span class="o">.</span><span class="n">ZombieProcess</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to terminate process </span><span class="si">{</span><span class="n">proc</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Close file descriptors</span>
    <span class="n">close_file_descriptors</span><span class="p">()</span></div>


<div class="viewcode-block" id="check_mask_folder">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.check_mask_folder">[docs]</a>
<span class="k">def</span> <span class="nf">check_mask_folder</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">mask_fldr</span><span class="p">):</span>
    
    <span class="n">mask_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;norm_channel_stack&#39;</span><span class="p">,</span><span class="n">mask_fldr</span><span class="p">)</span>
    <span class="n">stack_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;stack&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="n">mask_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">))</span>
    <span class="n">stack_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">stack_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">mask_count</span> <span class="o">==</span> <span class="n">stack_count</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All masks have been generated for </span><span class="si">{</span><span class="n">mask_fldr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="smooth_hull_lines">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.smooth_hull_lines">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_hull_lines</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">):</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
    <span class="c1"># Extract vertices of the hull</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
    <span class="c1"># Close the loop</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]])</span>
    <span class="c1"># Parameterize the vertices</span>
    <span class="n">tck</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">splprep</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># Evaluate spline at new parameter values</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">tck</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_gen_rgb_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate an RGB image from the specified channels of the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (ndarray): The input image.</span>
<span class="sd">        channels (list): List of channel indices to use for RGB.</span>

<span class="sd">    Returns:</span>
<span class="sd">        rgb_image (ndarray): The generated RGB image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">rgb_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">chan</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rgb_image</span>

<span class="k">def</span> <span class="nf">_outline_and_overlay</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rgb_image</span><span class="p">,</span> <span class="n">mask_dims</span><span class="p">,</span> <span class="n">outline_colors</span><span class="p">,</span> <span class="n">outline_thickness</span><span class="p">):</span>
    <span class="n">outlines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">overlayed_image</span> <span class="o">=</span> <span class="n">rgb_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process_dim</span><span class="p">(</span><span class="n">mask_dim</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask_dim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Use uint8 for contour detection efficiency</span>

        <span class="c1"># Find and draw contours</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip background</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="n">find_contours</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># Convert contours for OpenCV format and draw directly to optimize</span>
            <span class="n">cv_contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">contour</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">]</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span> <span class="n">cv_contours</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="n">outline_thickness</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">dilation</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="n">outline_thickness</span><span class="p">))</span>

    <span class="c1"># Parallel processing</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">outlines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process_dim</span><span class="p">,</span> <span class="n">mask_dims</span><span class="p">))</span>

    <span class="c1"># Overlay outlines onto the RGB image</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outlines</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outline_colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">outline_colors</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">outline</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip background</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">outline</span> <span class="o">==</span> <span class="n">j</span>
            <span class="n">overlayed_image</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>  <span class="c1"># Direct assignment with broadcasting</span>

    <span class="k">return</span> <span class="n">overlayed_image</span><span class="p">,</span> <span class="n">outlines</span><span class="p">,</span> <span class="n">image</span>

<span class="k">def</span> <span class="nf">_convert_cq1_well_id</span><span class="p">(</span><span class="n">well_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a well ID to the CQ1 well format.</span>

<span class="sd">    Args:</span>
<span class="sd">        well_id (int): The well ID to be converted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The well ID in CQ1 well format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">well_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">well_id</span><span class="p">)</span>
    <span class="c1"># ASCII code for &#39;A&#39;</span>
    <span class="n">ascii_A</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="c1"># Calculate row and column</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">well_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="c1"># Convert row to letter (A-P) and adjust col to start from 1</span>
    <span class="n">row_letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">ascii_A</span> <span class="o">+</span> <span class="n">row</span><span class="p">)</span>
    <span class="c1"># Format column as two digits</span>
    <span class="n">well_format</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row_letter</span><span class="si">}{</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span> 
    <span class="k">return</span> <span class="n">well_format</span>

<span class="k">def</span> <span class="nf">_get_cellpose_batch_size</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Check if CUDA is available</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">device_properties</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_device_properties</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vram_gb</span> <span class="o">=</span> <span class="n">device_properties</span><span class="o">.</span><span class="n">total_memory</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Convert bytes to gigabytes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CUDA is not available. Please check your installation and GPU.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">12</span> <span class="ow">and</span> <span class="n">vram_gb</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">48</span>
        <span class="k">elif</span> <span class="n">vram_gb</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">96</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Device </span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">device_properties</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, VRAM: </span><span class="si">{</span><span class="n">vram_gb</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> GB, cellpose batch size: </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">batch_size</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">8</span>

<span class="k">def</span> <span class="nf">_extract_filename_metadata</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">regular_expression</span><span class="p">,</span> <span class="n">metadata_type</span><span class="o">=</span><span class="s1">&#39;cellvoyager&#39;</span><span class="p">,</span> <span class="n">pick_slice</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_mode</span><span class="o">=</span><span class="s1">&#39;01&#39;</span><span class="p">):</span>
    
    <span class="n">images_by_key</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plate</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;plateID&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">plate</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

                <span class="n">well</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wellID&#39;</span><span class="p">)</span>
                <span class="n">field</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;fieldID&#39;</span><span class="p">)</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;chanID&#39;</span><span class="p">)</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">well</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">well</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">field</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">metadata_type</span> <span class="o">==</span><span class="s1">&#39;cq1&#39;</span><span class="p">:</span>
                    <span class="n">orig_wellID</span> <span class="o">=</span> <span class="n">wellID</span>
                    <span class="n">wellID</span> <span class="o">=</span> <span class="n">_convert_cq1_well_id</span><span class="p">(</span><span class="n">wellID</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Converted Well ID: </span><span class="si">{</span><span class="n">orig_wellID</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">wellID</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">pick_slice</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mode</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;AID&#39;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="n">sliceid</span> <span class="o">=</span> <span class="s1">&#39;00&#39;</span>

                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">skip_mode</span><span class="p">:</span>
                        <span class="k">continue</span>
                        
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>  <span class="c1"># Store the full path</span>
                <span class="n">images_by_key</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not extract information from filename </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> using provided regex&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filename </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> did not match provided regex&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
    <span class="k">return</span> <span class="n">images_by_key</span>

<div class="viewcode-block" id="mask_object_count">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.mask_object_count">[docs]</a>
<span class="k">def</span> <span class="nf">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of objects in a given mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - mask: numpy.ndarray. The mask containing object labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - int. The number of objects in the mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">num_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">num_objects</span></div>


<span class="k">def</span> <span class="nf">_update_database_with_merged_info</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges additional columns into the png_list table in the SQLite database and updates it.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The path to the SQLite database file.</span>
<span class="sd">        df (pd.DataFrame): DataFrame containing the additional info to be merged.</span>
<span class="sd">        table (str): Name of the table to update in the database. Defaults to &#39;png_list&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Connect to the SQLite database</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>

    <span class="c1"># Read the existing table into a DataFrame</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">existing_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SELECT * FROM </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to read table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> from database: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span>
    
    <span class="k">if</span> <span class="s1">&#39;prcfo&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;generating prcfo columns&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_o&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging on cell failed, trying with cell_id&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_o&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        
    <span class="c1"># Merge the existing DataFrame with the new info based on the &#39;prcfo&#39; column</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">existing_df</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">],</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    
    <span class="c1"># Drop the existing table and replace it with the updated DataFrame</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DROP TABLE IF EXISTS </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> successfully updated in the database.&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to update table </span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2"> in the database: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_generate_representative_images</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">cells</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;HeLa&#39;</span><span class="p">],</span> <span class="n">cell_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogens</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;rh&#39;</span><span class="p">],</span> <span class="n">pathogen_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatments</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cm&#39;</span><span class="p">],</span> <span class="n">treatment_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">compartments</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span><span class="s1">&#39;cytoplasm&#39;</span><span class="p">],</span> <span class="n">measurement</span> <span class="o">=</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">,</span> <span class="n">nr_imgs</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">channel_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">um_per_pixel</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">show_filename</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_db</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates representative images based on the provided parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_path (str): The path to the SQLite database file.</span>
<span class="sd">        cells (list, optional): The list of host cell types. Defaults to [&#39;HeLa&#39;].</span>
<span class="sd">        cell_loc (list, optional): The list of location identifiers for host cells. Defaults to None.</span>
<span class="sd">        pathogens (list, optional): The list of pathogens. Defaults to [&#39;rh&#39;].</span>
<span class="sd">        pathogen_loc (list, optional): The list of location identifiers for pathogens. Defaults to None.</span>
<span class="sd">        treatments (list, optional): The list of treatments. Defaults to [&#39;cm&#39;].</span>
<span class="sd">        treatment_loc (list, optional): The list of location identifiers for treatments. Defaults to None.</span>
<span class="sd">        channel_of_interest (int, optional): The index of the channel of interest. Defaults to 1.</span>
<span class="sd">        compartments (list or str, optional): The compartments to compare. Defaults to [&#39;pathogen&#39;, &#39;cytoplasm&#39;].</span>
<span class="sd">        measurement (str, optional): The measurement to compare. Defaults to &#39;mean_intensity&#39;.</span>
<span class="sd">        nr_imgs (int, optional): The number of representative images to generate. Defaults to 16.</span>
<span class="sd">        channel_indices (list, optional): The indices of the channels to include in the representative images. Defaults to [0, 1, 2].</span>
<span class="sd">        um_per_pixel (float, optional): The scale factor for converting pixels to micrometers. Defaults to 0.1.</span>
<span class="sd">        scale_bar_length_um (float, optional): The length of the scale bar in micrometers. Defaults to 10.</span>
<span class="sd">        plot (bool, optional): Whether to plot the representative images. Defaults to False.</span>
<span class="sd">        fontsize (int, optional): The font size for the plot. Defaults to 12.</span>
<span class="sd">        show_filename (bool, optional): Whether to show the filename on the plot. Defaults to True.</span>
<span class="sd">        channel_names (list, optional): The names of the channels. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_read_and_join_tables</span><span class="p">,</span> <span class="n">_save_figure</span>
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">_plot_images_on_grid</span>
    
    <span class="n">df</span> <span class="o">=</span> <span class="n">_read_and_join_tables</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">annotate_conditions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_loc</span><span class="p">,</span> <span class="n">pathogens</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="p">,</span> <span class="n">treatments</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">update_db</span><span class="p">:</span>
        <span class="n">_update_database_with_merged_info</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s1">&#39;png_list&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;prcfo&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">compartments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">measurement</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">compartments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">measurement</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">]</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">condition</span><span class="p">:</span> <span class="n">df_group</span> <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">df_group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;condition&#39;</span><span class="p">)}</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_filter_closest_to_stat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;new_measurement&#39;</span><span class="p">,</span> <span class="n">n_rows</span><span class="o">=</span><span class="n">nr_imgs</span><span class="p">,</span> <span class="n">use_median</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">png_paths_by_condition</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">_plot_images_on_grid</span><span class="p">(</span><span class="n">png_paths_by_condition</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">,</span> <span class="n">um_per_pixel</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">show_filename</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_save_figure</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_indices</span><span class="p">:</span>
            <span class="n">channel_indices</span><span class="o">=</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">_plot_images_on_grid</span><span class="p">(</span><span class="n">png_paths_by_condition</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">,</span> <span class="n">um_per_pixel</span><span class="p">,</span> <span class="n">scale_bar_length_um</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">show_filename</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">plot</span><span class="p">)</span>
            <span class="n">_save_figure</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
<span class="c1"># Adjusted mapping function to infer type from location identifiers</span>
<span class="k">def</span> <span class="nf">_map_values</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps values to a specific location in the row or column based on the given locs.</span>

<span class="sd">    Args:</span>
<span class="sd">        row (dict): The row dictionary containing the location identifier.</span>
<span class="sd">        values (list): The list of values to be mapped.</span>
<span class="sd">        locs (list): The list of location identifiers.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The mapped value corresponding to the given row or column location, or None if not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">locs</span><span class="p">:</span>
        <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">loc</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">loc_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">loc_list</span><span class="p">}</span>
        <span class="c1"># Determine if we&#39;re dealing with row or column based on first location identifier</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;row_name&#39;</span> <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span> <span class="k">else</span> <span class="s1">&#39;column_name&#39;</span>
        <span class="k">return</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">type_</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">values</span> <span class="k">else</span> <span class="kc">None</span>

<div class="viewcode-block" id="is_list_of_lists">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.is_list_of_lists">[docs]</a>
<span class="k">def</span> <span class="nf">is_list_of_lists</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="normalize_to_dtype">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.normalize_to_dtype">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_to_dtype</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="mi">98</span><span class="p">,</span> <span class="n">percentile_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize each image in the stack to its own percentiles.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - array: numpy array</span>
<span class="sd">    The input stack to be normalized.</span>
<span class="sd">    - p1: int, optional</span>
<span class="sd">    The lower percentile value for normalization. Default is 2.</span>
<span class="sd">    - p2: int, optional</span>
<span class="sd">    The upper percentile value for normalization. Default is 98.</span>
<span class="sd">    - percentile_list: list, optional</span>
<span class="sd">    A list of pre-calculated percentiles for each image in the stack. Default is None.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - new_stack: numpy array</span>
<span class="sd">    The normalized stack with the same shape as the input stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">new_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">new_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">]:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">new_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">]:</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="k">if</span> <span class="n">new_dtype</span> <span class="o">==</span> <span class="s1">&#39;uint8&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

    <span class="n">nimg</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">new_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">non_zero_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">percentile_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">percentile_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentile_1</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">percentile_2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="k">if</span> <span class="n">percentile_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">non_zero_img</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">percentile_1</span><span class="p">)</span>
                <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">percentile_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">percentile_1</span><span class="p">)</span>
                <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">percentile_2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Normalize to the range (0, 1) for visualization</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">out_range</span><span class="p">)</span>
        <span class="n">new_stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
    <span class="k">return</span> <span class="n">new_stack</span></div>

    
<span class="k">def</span> <span class="nf">_list_endpoint_subdirectories</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of subdirectories within the given base directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        base_dir (str): The base directory to search for subdirectories.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of subdirectories within the base directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">endpoint_subdirectories</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="n">endpoint_subdirectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            
    <span class="n">endpoint_subdirectories</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">endpoint_subdirectories</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;figure&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">endpoint_subdirectories</span>
    
<span class="k">def</span> <span class="nf">_generate_names</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">,</span> <span class="n">cell_nucleus_ids</span><span class="p">,</span> <span class="n">cell_pathogen_ids</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">crop_mode</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate names for the image, folder, and table based on the given parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        cell_id (numpy.ndarray): An array of cell IDs.</span>
<span class="sd">        cell_nucleus_ids (numpy.ndarray): An array of cell nucleus IDs.</span>
<span class="sd">        cell_pathogen_ids (numpy.ndarray): An array of cell pathogen IDs.</span>
<span class="sd">        source_folder (str): The source folder path.</span>
<span class="sd">        crop_mode (str, optional): The crop mode. Defaults to &#39;cell&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the image name, folder path, and table name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_zero_cell_ids</span> <span class="o">=</span> <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">non_zero_cell_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">non_zero_cell_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">non_zero_cell_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">cell_nucleus_ids</span> <span class="o">=</span> <span class="n">cell_nucleus_ids</span><span class="p">[</span><span class="n">cell_nucleus_ids</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_nucleus_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cell_nucleus_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">cell_pathogen_ids</span> <span class="o">=</span> <span class="n">cell_pathogen_ids</span><span class="p">[</span><span class="n">cell_pathogen_ids</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cell_pathogen_id_str</span> <span class="o">=</span> <span class="s2">&quot;multi&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cell_pathogen_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">fldr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s2">/data/&quot;</span>
    <span class="n">img_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_nucleus_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_pathogen/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_pathogens/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="k">elif</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_pathogen_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;infected/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="k">elif</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">or</span> <span class="n">crop_mode</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
        <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_id_str</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_nucleus/&quot;</span> <span class="k">if</span> <span class="n">cell_nucleus_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;no_nucleus/&quot;</span>
        <span class="n">fldr</span> <span class="o">+=</span> <span class="s2">&quot;single_pathogen/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;multiple_pathogens/&quot;</span> <span class="k">if</span> <span class="n">cell_pathogen_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;uninfected/&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">plate</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">metadata</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">plate</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">well</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">fldr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fldr</span><span class="p">,</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="n">fldr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_name</span><span class="p">,</span> <span class="n">fldr</span><span class="p">,</span> <span class="n">table_name</span>

<span class="k">def</span> <span class="nf">_find_bounding_box</span><span class="p">(</span><span class="n">crop_mask</span><span class="p">,</span> <span class="n">_id</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the bounding box coordinates for a given object ID in a crop mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    crop_mask (ndarray): The crop mask containing object IDs.</span>
<span class="sd">    _id (int): The object ID to find the bounding box for.</span>
<span class="sd">    buffer (int, optional): The buffer size to add to the bounding box coordinates. Defaults to 10.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ndarray: A new mask with the same dimensions as crop_mask, where the bounding box area is filled with the object ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">object_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">crop_mask</span> <span class="o">==</span> <span class="n">_id</span><span class="p">)</span>

    <span class="c1"># Determine the bounding box coordinates</span>
    <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">object_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># Add buffer to the bounding box coordinates</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_min</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_max</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_min</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Create a new mask with the same dimensions as crop_mask</span>
    <span class="n">new_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">crop_mask</span><span class="p">)</span>

    <span class="c1"># Fill in the bounding box area with the _id</span>
    <span class="n">new_mask</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_id</span>

    <span class="k">return</span> <span class="n">new_mask</span>
    
<span class="k">def</span> <span class="nf">_merge_and_save_to_database</span><span class="p">(</span><span class="n">morph_df</span><span class="p">,</span> <span class="n">intensity_df</span><span class="p">,</span> <span class="n">table_type</span><span class="p">,</span> <span class="n">source_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges morphology and intensity dataframes, renames columns, adds additional columns, rearranges columns,</span>
<span class="sd">        and saves the merged dataframe to a SQLite database.</span>

<span class="sd">        Args:</span>
<span class="sd">            morph_df (pd.DataFrame): Dataframe containing morphology data.</span>
<span class="sd">            intensity_df (pd.DataFrame): Dataframe containing intensity data.</span>
<span class="sd">            table_type (str): Type of table to save the merged dataframe to.</span>
<span class="sd">            source_folder (str): Path to the source folder.</span>
<span class="sd">            file_name (str): Name of the file.</span>
<span class="sd">            experiment (str): Name of the experiment.</span>
<span class="sd">            timelapse (bool, optional): Indicates if the data is from a timelapse experiment. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If an invalid table_type is provided or if columns are missing in the dataframe.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">morph_df</span> <span class="o">=</span> <span class="n">_check_integrity</span><span class="p">(</span><span class="n">morph_df</span><span class="p">)</span>
        <span class="n">intensity_df</span> <span class="o">=</span> <span class="n">_check_integrity</span><span class="p">(</span><span class="n">intensity_df</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">morph_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensity_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">morph_df</span><span class="p">,</span> <span class="n">intensity_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;label_list_x&quot;</span><span class="p">:</span> <span class="s2">&quot;label_list_morphology&quot;</span><span class="p">,</span> <span class="s2">&quot;label_list_y&quot;</span><span class="p">:</span> <span class="s2">&quot;label_list_intensity&quot;</span><span class="p">})</span>
            <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_name</span>
            <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;path_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source_folder</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
                <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;timeid&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timelapse</span><span class="p">)))</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># get the list of all columns</span>
            <span class="k">if</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">or</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">:</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span> <span class="ow">or</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid table_type: </span><span class="si">{</span><span class="n">table_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Check if all columns in column_list are in cols</span>
            <span class="n">missing_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_list</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">missing_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span>
                <span class="n">missing_columns</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">,</span> <span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;prcf&#39;</span><span class="p">,</span> <span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;path_name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">missing_columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Columns missing in DataFrame: </span><span class="si">{</span><span class="n">missing_columns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_list</span><span class="p">):</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>  <span class="c1"># rearrange the columns</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_folder</span><span class="si">}</span><span class="s1">/measurements/measurements.db&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">merged_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="n">table_type</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SQLite error:&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    
<span class="k">def</span> <span class="nf">_safe_int_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the given value to an integer if possible, otherwise returns the default value.</span>

<span class="sd">    Args:</span>
<span class="sd">        value: The value to be converted to an integer.</span>
<span class="sd">        default: The default value to be returned if the conversion fails. Default is 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The converted integer value if successful, otherwise the default value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not convert </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> to int using </span><span class="si">{</span><span class="n">default</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">default</span>

<span class="k">def</span> <span class="nf">_map_wells</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps the components of a file name to plate, row, column, field, and timeid (if timelapse is True).</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        timelapse (bool, optional): Indicates whether the file is part of a timelapse sequence. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the mapped values for plate, row, column, field, and timeid (if timelapse is True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">timeid</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="n">row</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">well</span><span class="p">,</span> <span class="n">well</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>    
            <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing filename: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcf</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">prcf</span>

<span class="k">def</span> <span class="nf">_map_wells_png</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps the components of a file name to their corresponding values.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name (str): The name of the file.</span>
<span class="sd">        timelapse (bool, optional): Indicates whether the file is part of a timelapse sequence. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the mapped components of the file name.</span>

<span class="sd">    Raises:</span>
<span class="sd">        None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">well</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">timeid</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">object_id</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="n">row</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_safe_int_convert</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">well</span><span class="p">,</span> <span class="n">well</span>
        <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
            <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">object_id</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">object_id</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing filename: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">object_id</span><span class="p">,</span> <span class="n">prcfo</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">timeid</span><span class="p">,</span> <span class="n">prcfo</span><span class="p">,</span> <span class="n">object_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plate</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">prcfo</span><span class="p">,</span> <span class="n">object_id</span>
        
<span class="k">def</span> <span class="nf">_check_integrity</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the integrity of the DataFrame and perform necessary modifications.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The modified DataFrame with integrity checks and modifications applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">col</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
    <span class="n">label_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">label_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">label_cols</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>
    
<span class="k">def</span> <span class="nf">_get_percentiles</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the percentiles of each image in the given array.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - array: numpy.ndarray</span>
<span class="sd">        The input array containing the images.</span>
<span class="sd">    - q1: float, optional</span>
<span class="sd">        The lower percentile value to calculate. Default is 2.</span>
<span class="sd">    - q2: float, optional</span>
<span class="sd">        The upper percentile value to calculate. Default is 98.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - percentiles: list</span>
<span class="sd">        A list of tuples, where each tuple contains the minimum and maximum</span>
<span class="sd">        values of the corresponding image in the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nimg</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">])</span>
        <span class="n">non_zero_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">non_zero_img</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># check if there are non-zero values</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>  <span class="c1"># change percentile from 0.02 to 2</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">non_zero_img</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>  <span class="c1"># change percentile from 0.98 to 98</span>
            <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if there are no non-zero values, just use the image as it is</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>  <span class="c1"># change percentile from 0.02 to 2</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>  <span class="c1"># change percentile from 0.98 to 98</span>
            <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">percentiles</span>

<span class="k">def</span> <span class="nf">_crop_center</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">new_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the image around the center of the cell mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - img: numpy.ndarray</span>
<span class="sd">        The input image.</span>
<span class="sd">    - cell_mask: numpy.ndarray</span>
<span class="sd">        The binary mask of the cell.</span>
<span class="sd">    - new_width: int</span>
<span class="sd">        The desired width of the cropped image.</span>
<span class="sd">    - new_height: int</span>
<span class="sd">        The desired height of the cropped image.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - img: numpy.ndarray</span>
<span class="sd">        The cropped image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert all non-zero values in mask to 1</span>
    <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># Create 3D mask</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask_3d</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># Multiply image with mask to set pixel values outside of the mask to 0</span>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ndi</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># Compute centroid of the mask</span>
    
    <span class="c1"># Pad the image and mask to ensure the crop will not go out of bounds</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    
    <span class="c1"># Update centroid coordinates due to padding</span>
    <span class="n">centroid</span> <span class="o">+=</span> <span class="n">pad_width</span>
    
    <span class="c1"># Compute bounding box</span>
    <span class="n">start_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_height</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">end_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_y</span> <span class="o">+</span> <span class="n">new_height</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">end_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_x</span> <span class="o">+</span> <span class="n">new_width</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Crop to bounding box</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">start_y</span><span class="p">:</span><span class="n">end_y</span><span class="p">,</span> <span class="n">start_x</span><span class="p">:</span><span class="n">end_x</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">img</span>
    
<span class="k">def</span> <span class="nf">_masks_to_masks_stack</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a list of masks into a stack of masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        masks (list): A list of masks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A stack of masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
        <span class="n">mask_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask_stack</span>
    
<span class="k">def</span> <span class="nf">_get_diam</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">mag</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">120</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">60</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid magnification: Use 20, 40 or 60&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mag</span> <span class="o">==</span> <span class="mi">40</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">160</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid magnification: Use 20, 40 or 60&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mag</span> <span class="o">==</span> <span class="mi">60</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
            <span class="n">diamiter</span> <span class="o">=</span> <span class="mi">60</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid magnification: Use 20, 40 or 60&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid magnification: Use 20, 40 or 60&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">diamiter</span>

<span class="k">def</span> <span class="nf">_get_object_settings</span><span class="p">(</span><span class="n">object_type</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
    <span class="n">object_settings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_diam</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">],</span> <span class="n">obj</span><span class="o">=</span><span class="n">object_type</span><span class="p">)</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;minimum_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;maximum_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;resample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;remove_border_objects&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
    
    <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;nucleus_channel&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto2&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nuclei&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nucleus_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;model_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cyto&#39;</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;filter_intensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;resample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;restore_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pathogen_restore_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;merge_pathogens&#39;</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Object type: </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> not supported. Supported object types are : cell, nucleus and pathogen&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">object_settings</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">object_settings</span>
    
<span class="k">def</span> <span class="nf">_pivot_counts_table</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_read_table_to_dataframe</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">table_name</span><span class="o">=</span><span class="s1">&#39;object_counts&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a table from an SQLite database into a pandas DataFrame.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - db_path (str): The path to the SQLite database file.</span>
<span class="sd">        - table_name (str): The name of the table to read. Default is &#39;object_counts&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - df (pandas.DataFrame): The table data as a pandas DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Connect to the SQLite database</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="c1"># Read the entire table into a pandas DataFrame</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SELECT * FROM </span><span class="si">{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="c1"># Close the connection</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">_pivot_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pivot the DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The input DataFrame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: The pivoted DataFrame with filled NaN values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pivot the DataFrame</span>
        <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;count_type&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;object_count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># Because the pivot operation can introduce NaN values for missing data,</span>
        <span class="c1"># you might want to fill those NaNs with a default value, like 0</span>
        <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">pivoted_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pivoted_df</span>

    <span class="c1"># Read the original &#39;object_counts&#39; table</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_read_table_to_dataframe</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="s1">&#39;object_counts&#39;</span><span class="p">)</span>
    <span class="c1"># Pivot the DataFrame to have one row per filename and a column for each object type</span>
    <span class="n">pivoted_df</span> <span class="o">=</span> <span class="n">_pivot_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="c1"># Reconnect to the SQLite database to overwrite the &#39;object_counts&#39; table with the pivoted DataFrame</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
    <span class="c1"># When overwriting, ensure that you drop the existing table or use if_exists=&#39;replace&#39; to overwrite it</span>
    <span class="n">pivoted_df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;pivoted_counts&#39;</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">_get_cellpose_channels</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">nucleus_channel</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">cell_channel</span><span class="p">):</span>

    <span class="n">cell_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;norm_channel_stack&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">nucleus_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;norm_channel_stack&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">pathogen_mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;norm_channel_stack&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen_mask_stack&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_mask_path</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nucleus_mask_path</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathogen_mask_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Cellpose masks already exist. Unexpected behaviour when setting any object dimention to None when the object masks have been created.&#39;</span><span class="p">)</span>
        
    <span class="n">cellpose_channels</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;nucleus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellpose_channels</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cellpose_channels</span>

<div class="viewcode-block" id="annotate_conditions">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.annotate_conditions">[docs]</a>
<span class="k">def</span> <span class="nf">annotate_conditions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotates conditions in a DataFrame based on specified criteria and combines them into a &#39;condition&#39; column.</span>
<span class="sd">    NaN is used for missing values, and they are excluded from the &#39;condition&#39; column.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The DataFrame to annotate.</span>
<span class="sd">        cells (list/str, optional): Host cell types. Defaults to None.</span>
<span class="sd">        cell_loc (list of lists, optional): Values for each host cell type. Defaults to None.</span>
<span class="sd">        pathogens (list/str, optional): Pathogens. Defaults to None.</span>
<span class="sd">        pathogen_loc (list of lists, optional): Values for each pathogen. Defaults to None.</span>
<span class="sd">        treatments (list/str, optional): Treatments. Defaults to None.</span>
<span class="sd">        treatment_loc (list of lists, optional): Values for each treatment. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: Annotated DataFrame with a combined &#39;condition&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if a value maps to &#39;row_name&#39; or &#39;column_name&#39;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;column_name&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;row_name&#39;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_map_or_default</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consolidates the logic for mapping values or assigning defaults when loc is None.</span>

<span class="sd">        Args:</span>
<span class="sd">            column_name (str): The column in the DataFrame to annotate.</span>
<span class="sd">            values (list/str): The list of values or a single string to annotate.</span>
<span class="sd">            loc (list of lists): Location mapping for the values, or None if not used.</span>
<span class="sd">            df (pandas.DataFrame): The DataFrame to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Assign all rows the first value in the list or the single string</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Perform the location-based mapping</span>
            <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">loc_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">loc_list</span><span class="p">}</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">loc_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">loc_type</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">loc_type</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="c1"># Handle cells, pathogens, and treatments using the consolidated logic</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;host_cells&#39;</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;pathogen&#39;</span><span class="p">,</span> <span class="n">pathogens</span><span class="p">,</span> <span class="n">pathogen_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
    <span class="n">_map_or_default</span><span class="p">(</span><span class="s1">&#39;treatment&#39;</span><span class="p">,</span> <span class="n">treatments</span><span class="p">,</span> <span class="n">treatment_loc</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

    <span class="c1"># Conditionally fill NaN for pathogen and treatment columns if applicable</span>
    <span class="k">if</span> <span class="n">pathogens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">treatments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;treatment&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Create the &#39;condition&#39; column by excluding any NaN values, safely checking if &#39;host_cells&#39;, &#39;pathogen&#39;, and &#39;treatment&#39; exist</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;host_cells&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pathogen&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;treatment&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">v</span><span class="p">)]),</span> 
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">NA</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_split_data_v1</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_by</span><span class="p">,</span> <span class="n">object_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input dataframe into numeric and non-numeric parts, groups them by the specified column,</span>
<span class="sd">    and returns the grouped dataframes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The input dataframe.</span>
<span class="sd">    group_by (str): The column name to group the dataframes by.</span>
<span class="sd">    object_type (str): The column name to concatenate with &#39;prcf&#39; to create a new column &#39;prcfo&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    grouped_numeric (pandas.DataFrame): The grouped dataframe containing numeric columns.</span>
<span class="sd">    grouped_non_numeric (pandas.DataFrame): The grouped dataframe containing non-numeric columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="s1">&#39;prcf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>    
    
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">object_type</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">df_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
    <span class="n">df_non_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
    
    <span class="p">[]</span>

    <span class="n">grouped_numeric</span> <span class="o">=</span> <span class="n">df_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">grouped_non_numeric</span> <span class="o">=</span> <span class="n">df_non_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_non_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_numeric</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_non_numeric</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_split_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_by</span><span class="p">,</span> <span class="n">object_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input dataframe into numeric and non-numeric parts, groups them by the specified column,</span>
<span class="sd">    and returns the grouped dataframes with conditional aggregation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The input dataframe.</span>
<span class="sd">    group_by (str): The column name to group the dataframes by.</span>
<span class="sd">    object_type (str): The column name to concatenate with &#39;prcf&#39; to create a new column &#39;prcfo&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    grouped_numeric (pandas.DataFrame): The grouped dataframe containing numeric columns with conditional aggregation.</span>
<span class="sd">    grouped_non_numeric (pandas.DataFrame): The grouped dataframe containing non-numeric columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Ensure &#39;prcf&#39; column exists by concatenating specific columns</span>
    <span class="k">if</span> <span class="s1">&#39;prcf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>    
    
    <span class="c1"># Create the &#39;prcfo&#39; column</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prcf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">object_type</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Split the DataFrame into numeric and non-numeric parts</span>
    <span class="n">df_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
    <span class="n">df_non_numeric</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="c1"># Define keywords for columns to be summed instead of averaged</span>
    <span class="n">sum_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;convex_area&#39;</span><span class="p">,</span> <span class="s1">&#39;bbox_area&#39;</span><span class="p">,</span> <span class="s1">&#39;filled_area&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent_diameter&#39;</span><span class="p">]</span>

    <span class="c1"># Create a dictionary for custom aggregation</span>
    <span class="n">agg_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df_numeric</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">column</span> <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">sum_keywords</span><span class="p">):</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span>

    <span class="c1"># Apply custom aggregation</span>
    <span class="n">grouped_numeric</span> <span class="o">=</span> <span class="n">df_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_dict</span><span class="p">)</span>
    <span class="n">grouped_non_numeric</span> <span class="o">=</span> <span class="n">df_non_numeric</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df_non_numeric</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_numeric</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grouped_non_numeric</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_calculate_recruitment</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate recruitment metrics based on intensity values in different channels.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame containing intensity values in different channels.</span>
<span class="sd">        channel (int): The channel number.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The DataFrame with calculated recruitment metrics.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cell_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_cytoplasm_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_nucleus_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_percentile_75&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cell_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_cytoplasm_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_outside_nucleus_q75_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_outside_75_percentile&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_cell_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cell_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_cytoplasm_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cytoplasm_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pathogen_periphery_nucleus_mean_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pathogen_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_periphery_mean&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;nucleus_channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span>

    <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">object_type</span> <span class="o">=</span> <span class="s1">&#39;pathogen&#39;</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_slope_channel_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">object_type</span> <span class="o">=</span> <span class="s1">&#39;nucleus&#39;</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_slope_channel_</span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">#for chan in channels:</span>
    <span class="c1">#    df[f&#39;nucleus_coordinates_{chan}&#39;] = df[[f&#39;nucleus_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;nucleus_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;pathogen_coordinates_{chan}&#39;] = df[[f&#39;pathogen_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;pathogen_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;cell_coordinates_{chan}&#39;] = df[[f&#39;cell_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;cell_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1">#    df[f&#39;cytoplasm_coordinates_{chan}&#39;] = df[[f&#39;cytoplasm_channel_{chan}_centroid_weighted_local-0&#39;, f&#39;cytoplasm_channel_{chan}_centroid_weighted_local-1&#39;]].values.tolist()</span>
    <span class="c1"># </span>
    <span class="c1">#    df[f&#39;pathogen_cell_distance_channel_{chan}&#39;] = df.apply(lambda row: np.sqrt((row[f&#39;pathogen_coordinates_{chan}&#39;][0] - row[f&#39;cell_coordinates_{chan}&#39;][0])**2 + </span>
    <span class="c1">#                                                  (row[f&#39;pathogen_coordinates_{chan}&#39;][1] - row[f&#39;cell_coordinates_{chan}&#39;][1])**2), axis=1)</span>
    <span class="c1">#    df[f&#39;nucleus_cell_distance_channel_{chan}&#39;] = df.apply(lambda row: np.sqrt((row[f&#39;nucleus_coordinates_{chan}&#39;][0] - row[f&#39;cell_coordinates_{chan}&#39;][0])**2 + </span>
    <span class="c1">#                                                  (row[f&#39;nucleus_coordinates_{chan}&#39;][1] - row[f&#39;cell_coordinates_{chan}&#39;][1])**2), axis=1)</span>
    <span class="k">return</span> <span class="n">df</span>
    
<span class="k">def</span> <span class="nf">_group_by_well</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group the DataFrame by well coordinates (plate, row, col) and apply mean function to numeric columns</span>
<span class="sd">    and select the first value for non-numeric columns.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (DataFrame): The input DataFrame to be grouped.</span>

<span class="sd">    Returns:</span>
<span class="sd">    DataFrame: The grouped DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numeric_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">non_numeric_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>

    <span class="c1"># Apply mean function to numeric columns and first to non-numeric</span>
    <span class="n">df_grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">numeric_cols</span><span class="p">},</span> <span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="s1">&#39;first&#39;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">non_numeric_cols</span><span class="p">}})</span>
    <span class="k">return</span> <span class="n">df_grouped</span>

<span class="c1">###################################################</span>
<span class="c1">#  Classify</span>
<span class="c1">###################################################</span>

<div class="viewcode-block" id="Cache">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.Cache">[docs]</a>
<span class="k">class</span> <span class="nc">Cache</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing a cache with a maximum size.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        max_size (int): The maximum size of the cache.</span>
<span class="sd">        cache (OrderedDict): The cache data structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">max_size</span>

<div class="viewcode-block" id="Cache.get">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.Cache.get">[docs]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cache.put">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.Cache.put">[docs]</a>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>
</div>


<span class="k">class</span> <span class="nc">ScaledDotProductAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scaled Dot-Product Attention module.</span>

<span class="sd">    Args:</span>
<span class="sd">        d_k (int): The dimension of the key and query vectors.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        d_k (int): The dimension of the key and query vectors.</span>

<span class="sd">    Methods:</span>
<span class="sd">        forward(Q, K, V): Performs the forward pass of the attention mechanism.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScaledDotProductAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">d_k</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the forward pass of the attention mechanism.</span>

<span class="sd">        Args:</span>
<span class="sd">            Q (torch.Tensor): The query tensor of shape (batch_size, seq_len_q, d_k).</span>
<span class="sd">            K (torch.Tensor): The key tensor of shape (batch_size, seq_len_k, d_k).</span>
<span class="sd">            V (torch.Tensor): The value tensor of shape (batch_size, seq_len_v, d_k).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor of shape (batch_size, seq_len_q, d_k).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

<span class="k">class</span> <span class="nc">SelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-Attention module that applies scaled dot-product attention mechanism.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">        d_k (int): Dimensionality of the key and query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelfAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">ScaledDotProductAttention</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the SelfAttention module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor of shape (batch_size, d_k).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

<div class="viewcode-block" id="ScaledDotProductAttention">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.ScaledDotProductAttention">[docs]</a>
<span class="k">class</span> <span class="nc">ScaledDotProductAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the ScaledDotProductAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            d_k (int): The dimension of the key and query vectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScaledDotProductAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_k</span> <span class="o">=</span> <span class="n">d_k</span>

<div class="viewcode-block" id="ScaledDotProductAttention.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.ScaledDotProductAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the forward pass of the ScaledDotProductAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            Q (torch.Tensor): The query tensor.</span>
<span class="sd">            K (torch.Tensor): The key tensor.</span>
<span class="sd">            V (torch.Tensor): The value tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="SelfAttention">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SelfAttention">[docs]</a>
<span class="k">class</span> <span class="nc">SelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-Attention module that applies scaled dot-product attention mechanism.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">        d_k (int): Dimensionality of the key and query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SelfAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">d_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">ScaledDotProductAttention</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>
    
<div class="viewcode-block" id="SelfAttention.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SelfAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the SelfAttention module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor after applying self-attention mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>


<span class="c1"># Early Fusion Block</span>
<div class="viewcode-block" id="EarlyFusion">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.EarlyFusion">[docs]</a>
<span class="k">class</span> <span class="nc">EarlyFusion</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Early Fusion module for image classification.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): Number of input channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EarlyFusion</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
<div class="viewcode-block" id="EarlyFusion.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.EarlyFusion.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the Early Fusion module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (batch_size, in_channels, height, width).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor of shape (batch_size, 64, height, width).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>
</div>


<span class="c1"># Spatial Attention Mechanism</span>
<div class="viewcode-block" id="SpatialAttention">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SpatialAttention">[docs]</a>
<span class="k">class</span> <span class="nc">SpatialAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the SpatialAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            kernel_size (int): The size of the convolutional kernel. Default is 7.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SpatialAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">kernel_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>

<div class="viewcode-block" id="SpatialAttention.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SpatialAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs forward pass of the SpatialAttention module.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): The input tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The output tensor after applying spatial attention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">avg_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">max_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">avg_out</span><span class="p">,</span> <span class="n">max_out</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>

    
<span class="c1"># Multi-Scale Block with Attention</span>
<div class="viewcode-block" id="MultiScaleBlockWithAttention">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.MultiScaleBlockWithAttention">[docs]</a>
<span class="k">class</span> <span class="nc">MultiScaleBlockWithAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiScaleBlockWithAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dilated_conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_attention</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
<div class="viewcode-block" id="MultiScaleBlockWithAttention.custom_forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.MultiScaleBlockWithAttention.custom_forward">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dilated_conv1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_attention</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="MultiScaleBlockWithAttention.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.MultiScaleBlockWithAttention.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>


<span class="c1"># Final Classifier</span>
<div class="viewcode-block" id="CustomCellClassifier">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.CustomCellClassifier">[docs]</a>
<span class="k">class</span> <span class="nc">CustomCellClassifier</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">use_attention</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomCellClassifier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">early_fusion</span> <span class="o">=</span> <span class="n">EarlyFusion</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_scale_block_1</span> <span class="o">=</span> <span class="n">MultiScaleBlockWithAttention</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span>
        <span class="c1"># Explicitly require gradients for all parameters</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        
<div class="viewcode-block" id="CustomCellClassifier.custom_forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.CustomCellClassifier.custom_forward">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">early_fusion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_scale_block_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">adaptive_avg_pool2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="CustomCellClassifier.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.CustomCellClassifier.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span> 
            <span class="k">return</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>


<span class="c1">#CNN and Transformer class, pick any Torch model.</span>
<div class="viewcode-block" id="TorchModel">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel">[docs]</a>
<span class="k">class</span> <span class="nc">TorchModel</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="s1">&#39;resnet50&#39;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TorchModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_base_model</span><span class="p">(</span><span class="n">pretrained</span><span class="p">)</span>
        
        <span class="c1"># Retain layers up to and including the (5): Linear layer for model &#39;maxvit_t&#39;</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;maxvit_t&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">children</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">dropout_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_dropout_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ftrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_ftrs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_spacr_classifier</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>

<div class="viewcode-block" id="TorchModel.apply_dropout_rate">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.apply_dropout_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_dropout_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply dropout rate to all dropout layers in the model.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">):</span>
                <span class="n">module</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">dropout_rate</span></div>


<div class="viewcode-block" id="TorchModel.init_base_model">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.init_base_model">[docs]</a>
    <span class="k">def</span> <span class="nf">init_base_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pretrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the base model from torchvision.models.&quot;&quot;&quot;</span>
        <span class="n">model_func</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">model_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="si">}</span><span class="s2"> is not recognized.&quot;</span><span class="p">)</span>
        <span class="n">weight_choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_weight_choice</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">weight_choice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">model_func</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weight_choice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">model_func</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="n">pretrained</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.get_weight_choice">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.get_weight_choice">[docs]</a>
    <span class="k">def</span> <span class="nf">get_weight_choice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get weight choice if it exists for the model.&quot;&quot;&quot;</span>
        <span class="n">weight_enum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="si">}</span><span class="s2">_weights&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">weight_enum</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">weight_enum</span><span class="o">.</span><span class="n">DEFAULT</span> <span class="k">if</span> <span class="n">weight_enum</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="TorchModel.get_num_ftrs">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.get_num_ftrs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_num_ftrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the number of features output by the base model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="s1">&#39;fc&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="s1">&#39;classifier&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">!=</span> <span class="s1">&#39;maxvit_t&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>

        <span class="c1"># Forward a dummy input and check output size</span>
        <span class="n">dummy_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">(</span><span class="n">dummy_input</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.init_spacr_classifier">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.init_spacr_classifier">[docs]</a>
    <span class="k">def</span> <span class="nf">init_spacr_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the SPACR classifier.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span> <span class="o">=</span> <span class="n">dropout_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacr_classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ftrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchModel.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.TorchModel.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the forward pass of the model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacr_classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">logits</span></div>
</div>


<div class="viewcode-block" id="FocalLossWithLogits">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.FocalLossWithLogits">[docs]</a>
<span class="k">class</span> <span class="nc">FocalLossWithLogits</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FocalLossWithLogits</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

<div class="viewcode-block" id="FocalLossWithLogits.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.FocalLossWithLogits.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">BCE_loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">BCE_loss</span><span class="p">)</span>
        <span class="n">focal_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pt</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">BCE_loss</span>
        <span class="k">return</span> <span class="n">focal_loss</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>
</div>

    
<div class="viewcode-block" id="ResNet">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.ResNet">[docs]</a>
<span class="k">class</span> <span class="nc">ResNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnet_type</span><span class="o">=</span><span class="s1">&#39;resnet50&#39;</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="s1">&#39;imagenet&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">resnet_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;resnet18&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet18</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet18_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet34&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet34</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet34_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet50&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet50</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet50_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet101&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet101</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet101_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">},</span>
            <span class="s1">&#39;resnet152&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet152</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">ResNet152_Weights</span><span class="o">.</span><span class="n">IMAGENET1K_V1</span><span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">resnet_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resnet_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid resnet_type. Choose from </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">resnet_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_base</span><span class="p">(</span><span class="n">resnet_map</span><span class="p">[</span><span class="n">resnet_type</span><span class="p">],</span> <span class="n">dropout_rate</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">init_weights</span><span class="p">)</span>

<div class="viewcode-block" id="ResNet.initialize_base">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.ResNet.initialize_base">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_model_dict</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">init_weights</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">init_weights</span> <span class="o">==</span> <span class="s1">&#39;imagenet&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span> <span class="o">=</span> <span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">](</span><span class="n">weights</span><span class="o">=</span><span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">init_weights</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span> <span class="o">=</span> <span class="n">base_model_dict</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">](</span><span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;init_weights should be either &#39;imagenet&#39; or &#39;none&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span> <span class="o">=</span> <span class="n">dropout_rate</span> <span class="o">!=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span> <span class="o">=</span> <span class="n">use_checkpoint</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResNet.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.ResNet.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Ensure that the tensor has requires_grad set to True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_checkpoint</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># Use checkpointing for just the ResNet part</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dropout</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">logits</span></div>
</div>


<div class="viewcode-block" id="split_my_dataset">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.split_my_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">split_my_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">split_ratio</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a dataset into training and validation subsets.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (torch.utils.data.Dataset): The dataset to be split.</span>
<span class="sd">        split_ratio (float, optional): The ratio of validation samples to total samples. Defaults to 0.1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the training dataset and validation dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">))</span>
    <span class="n">split_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">split_ratio</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">train_indices</span><span class="p">,</span> <span class="n">val_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">split_idx</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">split_idx</span><span class="p">:]</span>
    <span class="n">train_dataset</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">train_indices</span><span class="p">)</span>
    <span class="n">val_dataset</span> <span class="o">=</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">val_dataset</span></div>


<div class="viewcode-block" id="classification_metrics">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.classification_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">classification_metrics</span><span class="p">(</span><span class="n">all_labels</span><span class="p">,</span> <span class="n">prediction_pos_probs</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate classification metrics for binary classification.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - all_labels (list): List of true labels.</span>
<span class="sd">    - prediction_pos_probs (list): List of predicted positive probabilities.</span>
<span class="sd">    - loader_name (str): Name of the data loader.</span>
<span class="sd">    - loss (float): Loss value.</span>
<span class="sd">    - epoch (int): Epoch number.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - data_df (DataFrame): DataFrame containing the calculated metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prediction_pos_probs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_labels (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">) and pred_labels (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">prediction_pos_probs</span><span class="p">)</span><span class="si">}</span><span class="s2">) have different lengths&quot;</span><span class="p">)</span>
    
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pr_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">precision_recall_curve</span><span class="p">(</span><span class="n">pr_labels</span><span class="p">,</span> <span class="n">prediction_pos_probs</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pr_auc</span> <span class="o">=</span> <span class="n">auc</span><span class="p">(</span><span class="n">recall</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">f1_scores</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span><span class="p">)</span>
        <span class="n">optimal_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">f1_scores</span><span class="p">)</span>
        <span class="n">optimal_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">optimal_idx</span><span class="p">]</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prediction_pos_probs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">optimal_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">optimal_threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prediction_pos_probs</span><span class="p">]</span>
        <span class="n">pr_auc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">all_labels</span><span class="p">,</span> <span class="s1">&#39;pred&#39;</span><span class="p">:</span> <span class="n">pred_labels</span><span class="p">}</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">pc_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">nc_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
    <span class="n">acc_all</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pc_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">correct_pc</span> <span class="o">=</span> <span class="n">pc_df</span><span class="p">[</span><span class="n">pc_df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pc_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
        <span class="n">acc_pc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct_pc</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pc_df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acc_pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">correct_nc</span> <span class="o">=</span> <span class="n">nc_df</span><span class="p">[</span><span class="n">nc_df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nc_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]]</span>
        <span class="n">acc_nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">correct_nc</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc_df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acc_nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">acc_all</span><span class="p">,</span> <span class="s1">&#39;neg_accuracy&#39;</span><span class="p">:</span> <span class="n">acc_nc</span><span class="p">,</span> <span class="s1">&#39;pos_accuracy&#39;</span><span class="p">:</span> <span class="n">acc_pc</span><span class="p">,</span> <span class="s1">&#39;loss&#39;</span><span class="p">:</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="s1">&#39;prauc&#39;</span><span class="p">:</span><span class="n">pr_auc</span><span class="p">,</span> <span class="s1">&#39;optimal_threshold&#39;</span><span class="p">:</span><span class="n">optimal_threshold</span><span class="p">}</span>
    <span class="n">data_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)])</span> 
    <span class="k">return</span> <span class="n">data_df</span></div>

    
<div class="viewcode-block" id="compute_irm_penalty">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.compute_irm_penalty">[docs]</a>
<span class="k">def</span> <span class="nf">compute_irm_penalty</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Invariant Risk Minimization (IRM) penalty.</span>

<span class="sd">    Args:</span>
<span class="sd">        losses (list): A list of losses.</span>
<span class="sd">        dummy_w (torch.Tensor): A dummy weight tensor.</span>
<span class="sd">        device (torch.device): The device to perform computations on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The computed IRM penalty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weighted_losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">dummy_w</span> <span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">losses</span><span class="p">]</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="p">[</span><span class="n">grad</span><span class="p">(</span><span class="n">w_loss</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w_loss</span> <span class="ow">in</span> <span class="n">weighted_losses</span><span class="p">]</span>
    <span class="n">irm_penalty</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">irm_penalty</span> <span class="o">+=</span> <span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">irm_penalty</span></div>


<span class="c1">#def print_model_summary(base_model, channels, height, width):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Prints the summary of a given base model.</span>
<span class="c1">#</span>
<span class="c1">#    Args:</span>
<span class="c1">#        base_model (torch.nn.Module): The base model to print the summary of.</span>
<span class="c1">#        channels (int): The number of input channels.</span>
<span class="c1">#        height (int): The height of the input.</span>
<span class="c1">#        width (int): The width of the input.</span>
<span class="c1">#</span>
<span class="c1">#    Returns:</span>
<span class="c1">#        None</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span>
<span class="c1">#    base_model.to(device)</span>
<span class="c1">#    summary(base_model, (channels, height, width))</span>
<span class="c1">#    return</span>

<div class="viewcode-block" id="choose_model">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.choose_model">[docs]</a>
<span class="k">def</span> <span class="nf">choose_model</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">init_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">chan_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a model for classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_type (str): The type of model to choose. Can be one of the pre-defined TorchVision models or &#39;custom&#39; for a custom model.</span>
<span class="sd">        device (str): The device to use for model inference.</span>
<span class="sd">        init_weights (bool, optional): Whether to initialize the model with pre-trained weights. Defaults to True.</span>
<span class="sd">        dropout_rate (float, optional): The dropout rate to use in the model. Defaults to 0.</span>
<span class="sd">        use_checkpoint (bool, optional): Whether to use checkpointing during model training. Defaults to False.</span>
<span class="sd">        channels (int, optional): The number of input channels for the model. Defaults to 3.</span>
<span class="sd">        height (int, optional): The height of the input images for the model. Defaults to 224.</span>
<span class="sd">        width (int, optional): The width of the input images for the model. Defaults to 224.</span>
<span class="sd">        chan_dict (dict, optional): A dictionary containing channel information for custom models. Defaults to None.</span>
<span class="sd">        num_classes (int, optional): The number of output classes for the model. Defaults to 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.nn.Module: The chosen model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">torch_model_types</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">list_models</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="p">)</span>
    <span class="n">model_types</span> <span class="o">=</span> <span class="n">torch_model_types</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;custom&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chan_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pathogen_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;pathogen_channel&#39;</span><span class="p">]</span>
        <span class="n">nucleus_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;nucleus_channel&#39;</span><span class="p">]</span>
        <span class="n">protein_channel</span> <span class="o">=</span> <span class="n">chan_dict</span><span class="p">[</span><span class="s1">&#39;protein_channel&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_types</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid model_type: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1">. Compatible model_types: </span><span class="si">{</span><span class="n">model_types</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Model parameters: Architecture: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1"> init_weights: </span><span class="si">{</span><span class="n">init_weights</span><span class="si">}</span><span class="s1"> dropout_rate: </span><span class="si">{</span><span class="n">dropout_rate</span><span class="si">}</span><span class="s1"> use_checkpoint: </span><span class="si">{</span><span class="n">use_checkpoint</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
        
        <span class="n">base_model</span> <span class="o">=</span> <span class="n">CustomCellClassifier</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">pathogen_channel</span><span class="o">=</span><span class="n">pathogen_channel</span><span class="p">,</span> <span class="n">use_attention</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_checkpoint</span><span class="o">=</span><span class="n">use_checkpoint</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="n">dropout_rate</span><span class="p">)</span>
        <span class="c1">#base_model = CustomCellClassifier(num_classes=2, pathogen_channel=pathogen_channel, nucleus_channel=nucleus_channel, protein_channel=protein_channel, dropout_rate=dropout_rate, use_checkpoint=use_checkpoint)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="ow">in</span> <span class="n">torch_model_types</span><span class="p">:</span>
        <span class="n">base_model</span> <span class="o">=</span> <span class="n">TorchModel</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="n">model_type</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="n">init_weights</span><span class="p">,</span> <span class="n">dropout_rate</span><span class="o">=</span><span class="n">dropout_rate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Compatible model_types: </span><span class="si">{</span><span class="n">model_types</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid model_type: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">base_model</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">base_model</span></div>


<div class="viewcode-block" id="calculate_loss">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.calculate_loss">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">loss_type</span><span class="o">=</span><span class="s1">&#39;binary_cross_entropy_with_logits&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loss_type</span> <span class="o">==</span> <span class="s1">&#39;binary_cross_entropy_with_logits&#39;</span><span class="p">:</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">loss_type</span> <span class="o">==</span> <span class="s1">&#39;focal_loss&#39;</span><span class="p">:</span>
        <span class="n">focal_loss_fn</span> <span class="o">=</span> <span class="n">FocalLossWithLogits</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">focal_loss_fn</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span></div>


<div class="viewcode-block" id="pick_best_model">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.pick_best_model">[docs]</a>
<span class="k">def</span> <span class="nf">pick_best_model</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="n">all_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="n">pth_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_files</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pth&#39;</span><span class="p">)]</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_epoch_(\d+)_acc_(\d+(?:\.\d+)?)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make the primary sorting key float for consistency</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">g2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>  <span class="c1"># Primary sort by accuracy (g2) and secondary sort by epoch (g1)</span>
    
    <span class="n">sorted_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pth_files</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">best_model</span> <span class="o">=</span> <span class="n">sorted_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">best_model</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_paths_from_db">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_paths_from_db">[docs]</a>
<span class="k">def</span> <span class="nf">get_paths_from_db</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">png_df</span><span class="p">,</span> <span class="n">image_type</span><span class="o">=</span><span class="s1">&#39;cell_png&#39;</span><span class="p">):</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">png_df</span><span class="p">[</span><span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">image_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">png_df</span><span class="p">[</span><span class="s1">&#39;prcfo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">objects</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">filtered_df</span></div>


<div class="viewcode-block" id="save_file_lists">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.save_file_lists">[docs]</a>
<span class="k">def</span> <span class="nf">save_file_lists</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">data_set</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">data_set</span><span class="p">])</span>  
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dst</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">data_set</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="augment_single_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.augment_single_image">[docs]</a>
<span class="k">def</span> <span class="nf">augment_single_image</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">img_path</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_UNCHANGED</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Original Image</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_original.png&quot;</span><span class="p">),</span> <span class="n">img</span><span class="p">)</span>
    
    <span class="c1"># 90 degree rotation</span>
    <span class="n">img_rot_90</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_CLOCKWISE</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_90.png&quot;</span><span class="p">),</span> <span class="n">img_rot_90</span><span class="p">)</span>
    
    <span class="c1"># 180 degree rotation</span>
    <span class="n">img_rot_180</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_180</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_180.png&quot;</span><span class="p">),</span> <span class="n">img_rot_180</span><span class="p">)</span>

    <span class="c1"># 270 degree rotation</span>
    <span class="n">img_rot_270</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_COUNTERCLOCKWISE</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_rot_270.png&quot;</span><span class="p">),</span> <span class="n">img_rot_270</span><span class="p">)</span>

    <span class="c1"># Horizontal Flip</span>
    <span class="n">img_flip_hor</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_flip_hor.png&quot;</span><span class="p">),</span> <span class="n">img_flip_hor</span><span class="p">)</span>

    <span class="c1"># Vertical Flip</span>
    <span class="n">img_flip_ver</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_flip_ver.png&quot;</span><span class="p">),</span> <span class="n">img_flip_ver</span><span class="p">)</span></div>


<div class="viewcode-block" id="augment_images">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.augment_images">[docs]</a>
<span class="k">def</span> <span class="nf">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="n">args_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">for</span> <span class="n">img_path</span> <span class="ow">in</span> <span class="n">file_paths</span><span class="p">]</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">augment_single_image</span><span class="p">,</span> <span class="n">args_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="augment_classes">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.augment_classes">[docs]</a>
<span class="k">def</span> <span class="nf">augment_classes</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">generate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">move</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">aug_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug_nc&#39;</span><span class="p">)</span>
    <span class="n">aug_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug_pc&#39;</span><span class="p">)</span>
    <span class="n">all_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">generate</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
            <span class="n">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="o">=</span><span class="n">nc</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">aug_nc</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
            <span class="n">augment_images</span><span class="p">(</span><span class="n">file_paths</span><span class="o">=</span><span class="n">pc</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">aug_pc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">move</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="s1">&#39;aug&#39;</span><span class="p">)</span>
        <span class="n">aug_train_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;train/nc&#39;</span><span class="p">)</span>
        <span class="n">aug_train_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;train/pc&#39;</span><span class="p">)</span>
        <span class="n">aug_test_nc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;test/nc&#39;</span><span class="p">)</span>
        <span class="n">aug_test_pc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span><span class="s1">&#39;test/pc&#39;</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">aug_nc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_nc</span><span class="p">)]</span>
        <span class="n">aug_pc_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_pc</span><span class="p">)]</span>

        <span class="n">nc_train_data</span><span class="p">,</span> <span class="n">nc_test_data</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">aug_nc_list</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">pc_train_data</span><span class="p">,</span> <span class="n">pc_test_data</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">aug_pc_list</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">nc_train_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">nc_test_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pc_train_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pc_test_data</span><span class="p">:</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">all_</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Train nc: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_train_nc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Train pc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_test_nc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Test nc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_train_pc</span><span class="p">))</span><span class="si">}</span><span class="s1">, Test pc:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">aug_test_pc</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="annotate_predictions">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.annotate_predictions">[docs]</a>
<span class="k">def</span> <span class="nf">annotate_predictions</span><span class="p">(</span><span class="n">csv_loc</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_loc</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">assign_condition</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">plate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">])</span>
        <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;well&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plate</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;screen&#39;</span>
            <span class="k">elif</span> <span class="n">plate</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;pc&#39;</span>
        <span class="k">elif</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;nc&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cond&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">assign_condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="initiate_counter">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.initiate_counter">[docs]</a>
<span class="k">def</span> <span class="nf">initiate_counter</span><span class="p">(</span><span class="n">counter_</span><span class="p">,</span> <span class="n">lock_</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">counter</span><span class="p">,</span> <span class="n">lock</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">counter_</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">lock_</span></div>


<div class="viewcode-block" id="add_images_to_tar">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.add_images_to_tar">[docs]</a>
<span class="k">def</span> <span class="nf">add_images_to_tar</span><span class="p">(</span><span class="n">paths_chunk</span><span class="p">,</span> <span class="n">tar_path</span><span class="p">,</span> <span class="n">total_images</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">tar_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths_chunk</span><span class="p">):</span>
            <span class="n">arcname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">arcname</span><span class="o">=</span><span class="n">arcname</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                    <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Print every 100 updates</span>
                        <span class="c1">#progress = (counter.value / total_images) * 100</span>
                        <span class="c1">#print(f&quot;Progress: {counter.value}/{total_images} ({progress:.2f}%)&quot;, end=&#39;\r&#39;, file=sys.stdout, flush=True)</span>
                        <span class="n">print_progress</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">total_images</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_ls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_type</span><span class="o">=</span><span class="s2">&quot;generating .tar dataset&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File not found: </span><span class="si">{</span><span class="n">img_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_fraction_map">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.generate_fraction_map">[docs]</a>
<span class="k">def</span> <span class="nf">generate_fraction_map</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">gene_column</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;well_read_sum&#39;</span><span class="p">]</span>
    <span class="n">genes</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">gene_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">wells</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">))</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">genes</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">wells</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">prc</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span>
        <span class="n">gene</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">gene_column</span><span class="p">]</span>
        <span class="n">fraction</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;fraction&#39;</span><span class="p">]</span>
        <span class="n">independent_variables</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">prc</span><span class="p">,</span><span class="n">gene</span><span class="p">]</span><span class="o">=</span><span class="n">fraction</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">independent_variables</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">#sums = independent_variables[&#39;sum&#39;].unique().tolist()</span>
    <span class="c1">#print(sums)</span>
    <span class="c1">#independent_variables = independent_variables[(independent_variables[&#39;sum&#39;] == 0.0) | (independent_variables[&#39;sum&#39;] == 1.0)]</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">independent_variables</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_frequency</span><span class="p">])</span>
    <span class="n">independent_variables</span> <span class="o">=</span> <span class="n">independent_variables</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">independent_variables</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;prc&#39;</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="s1">&#39;/mnt/data/CellVoyager/20x/tsg101/crispr_screen/all/measurements/iv.csv&#39;</span>
    <span class="n">independent_variables</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">independent_variables</span></div>


<div class="viewcode-block" id="fishers_odds">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.fishers_odds">[docs]</a>
<span class="k">def</span> <span class="nf">fishers_odds</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">phenotyp_col</span><span class="o">=</span><span class="s1">&#39;mean_pred&#39;</span><span class="p">):</span>
    <span class="c1"># Binning based on phenotype score (e.g., above 0.8 as high)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;high_phenotype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">phenotyp_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mutants</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mutants</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">mutants</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;count_prc&#39;</span><span class="p">,</span><span class="s1">&#39;mean_pathogen_area&#39;</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fishers df&#39;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="c1"># Perform Fisher&#39;s exact test for each mutant</span>
    <span class="k">for</span> <span class="n">mutant</span> <span class="ow">in</span> <span class="n">mutants</span><span class="p">:</span>
        <span class="n">contingency_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">crosstab</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">mutant</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;high_phenotype&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">contingency_table</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Check for 2x2 shape</span>
            <span class="n">odds_ratio</span><span class="p">,</span> <span class="n">p_value</span> <span class="o">=</span> <span class="n">fisher_exact</span><span class="p">(</span><span class="n">contingency_table</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mutant</span><span class="p">,</span> <span class="n">odds_ratio</span><span class="p">,</span> <span class="n">p_value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Optionally handle non-2x2 tables (e.g., append NaN or other placeholders)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mutant</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)))</span>
    
    <span class="c1"># Convert results to DataFrame for easier handling</span>
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Mutant&#39;</span><span class="p">,</span> <span class="s1">&#39;OddsRatio&#39;</span><span class="p">,</span> <span class="s1">&#39;PValue&#39;</span><span class="p">])</span>
    <span class="c1"># Remove rows with undefined odds ratios or p-values</span>
    <span class="n">filtered_results_df</span> <span class="o">=</span> <span class="n">results_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;OddsRatio&#39;</span><span class="p">,</span> <span class="s1">&#39;PValue&#39;</span><span class="p">])</span>
    
    <span class="n">pvalues</span> <span class="o">=</span> <span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;PValue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Check if pvalues array is empty</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvalues</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Apply Benjamini-Hochberg correction</span>
        <span class="n">adjusted_pvalues</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fdr_bh&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Add adjusted p-values back to the dataframe</span>
        <span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;AdjustedPValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_pvalues</span>
        <span class="c1"># Filter significant results</span>
        <span class="n">significant_mutants</span> <span class="o">=</span> <span class="n">filtered_results_df</span><span class="p">[</span><span class="n">filtered_results_df</span><span class="p">[</span><span class="s1">&#39;AdjustedPValue&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No p-values to adjust. Check your data filtering steps.&quot;</span><span class="p">)</span>
        <span class="n">significant_mutants</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># return empty DataFrame in this case</span>
    
    <span class="k">return</span> <span class="n">filtered_results_df</span></div>


<div class="viewcode-block" id="model_metrics">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.model_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>

    <span class="c1"># Calculate additional metrics</span>
    <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">mse_resid</span><span class="p">)</span>
    <span class="n">mae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">durbin_w_value</span> <span class="o">=</span> <span class="n">durbin_watson</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>

    <span class="c1"># Display the additional metrics</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Additional Metrics:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Root Mean Squared Error (RMSE): </span><span class="si">{</span><span class="n">rmse</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean Absolute Error (MAE): </span><span class="si">{</span><span class="n">mae</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Durbin-Watson: </span><span class="si">{</span><span class="n">durbin_w_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Residual Plots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

    <span class="c1"># Residual vs. Fitted</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">facecolors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Residuals vs Fitted&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Fitted values&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Residuals&#39;</span><span class="p">)</span>

    <span class="c1"># Histogram</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Histogram of Residuals&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Residuals&#39;</span><span class="p">)</span>

    <span class="c1"># QQ Plot</span>
    <span class="n">sm</span><span class="o">.</span><span class="n">qqplot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s1">&#39;45&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;QQ Plot&#39;</span><span class="p">)</span>

    <span class="c1"># Scale-Location</span>
    <span class="n">standardized_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">resid_studentized_internal</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">standardized_resid</span><span class="p">)),</span> <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">facecolors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Scale-Location&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Fitted values&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\sqrt{|Standardized Residuals|}$&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="check_multicollinearity">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.check_multicollinearity">[docs]</a>
<span class="k">def</span> <span class="nf">check_multicollinearity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks multicollinearity of the predictors by computing the VIF.&quot;&quot;&quot;</span>
    <span class="n">vif_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">vif_data</span><span class="p">[</span><span class="s2">&quot;Variable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">vif_data</span><span class="p">[</span><span class="s2">&quot;VIF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">variance_inflation_factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">return</span> <span class="n">vif_data</span></div>


<div class="viewcode-block" id="lasso_reg">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.lasso_reg">[docs]</a>
<span class="k">def</span> <span class="nf">lasso_reg</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">alpha_value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;lasso&#39;</span><span class="p">):</span>
    <span class="c1"># Separate predictors and response</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[[</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;grna&#39;</span><span class="p">,</span> <span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">]]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]</span>

    <span class="c1"># One-hot encode the categorical predictors</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>  <span class="c1"># drop one category to avoid the dummy variable trap</span>
    <span class="n">X_encoded</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">feature_names</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">(</span><span class="n">input_features</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s1">&#39;ridge&#39;</span><span class="p">:</span>
        <span class="c1"># Fit ridge regression</span>
        <span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha_value</span><span class="p">)</span>
        <span class="n">ridge</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_encoded</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">ridge</span><span class="o">.</span><span class="n">coef_</span>
        <span class="n">coeff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">ridge</span><span class="o">.</span><span class="n">coef_</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s1">&#39;lasso&#39;</span><span class="p">:</span>
        <span class="c1"># Fit Lasso regression</span>
        <span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha_value</span><span class="p">)</span>
        <span class="n">lasso</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_encoded</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">lasso</span><span class="o">.</span><span class="n">coef_</span>
        <span class="n">coeff_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">lasso</span><span class="o">.</span><span class="n">coef_</span><span class="p">))</span>
    <span class="n">coeff_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coeff_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;Coefficient&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">coeff_df</span></div>


<div class="viewcode-block" id="MLR">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.MLR">[docs]</a>
<span class="k">def</span> <span class="nf">MLR</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">refine_model</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">_reg_v_plot</span>
    
    <span class="c1">#model = smf.ols(&quot;pred ~ gene + grna + gene:grna + plate + row + column&quot;, merged_df).fit()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="s2">&quot;pred ~ gene:grna + plate + row + column&quot;</span><span class="p">,</span> <span class="n">merged_df</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="c1"># Display model metrics and summary</span>
    <span class="n">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">refine_model</span><span class="p">:</span>
        <span class="c1"># Filter outliers</span>
        <span class="n">std_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">resid_studentized_internal</span>
        <span class="n">outliers_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">std_resid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_influence</span><span class="p">()</span><span class="o">.</span><span class="n">cooks_distance</span>
        <span class="n">outliers_cooks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_df</span><span class="p">)</span><span class="o">-</span><span class="n">merged_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">,</span> <span class="p">(</span><span class="n">outliers_resid</span><span class="p">,</span> <span class="n">outliers_cooks</span><span class="p">))</span>
        <span class="n">merged_df_filtered</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">outliers</span><span class="p">])</span>

        <span class="n">display</span><span class="p">(</span><span class="n">merged_df_filtered</span><span class="p">)</span>

        <span class="c1"># Refit the model with filtered data</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="s2">&quot;pred ~ gene + grna + gene:grna + row + column&quot;</span><span class="p">,</span> <span class="n">merged_df_filtered</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of outliers detected by standardized residuals:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers_resid</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of outliers detected by Cook&#39;s distance:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers_cooks</span><span class="p">))</span>

        <span class="n">model_metrics</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="c1"># Extract interaction coefficients and determine the maximum effect size</span>
    <span class="n">interaction_coeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;gene[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="s2">&quot;:grna[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>
    <span class="n">interaction_pvalues</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">pvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;gene[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="s2">&quot;:grna[T.&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>

    <span class="n">max_effects</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_effects_pvalues</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">interaction_coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gene_name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;gene[T.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gene_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">max_effects</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">max_effects</span><span class="p">[</span><span class="n">gene_name</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">max_effects</span><span class="p">[</span><span class="n">gene_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">max_effects_pvalues</span><span class="p">[</span><span class="n">gene_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_pvalues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">max_effects</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">max_effects</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">, p:</span><span class="si">{</span><span class="n">max_effects_pvalues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">max_effects</span><span class="p">,</span> <span class="n">max_effects_pvalues</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s1">&#39;effect&#39;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="s1">&#39;p&#39;</span><span class="p">})</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;effect&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>

    <span class="n">_reg_v_plot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">max_effects</span><span class="p">,</span> <span class="n">max_effects_pvalues</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_files_from_dir">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_files_from_dir">[docs]</a>
<span class="k">def</span> <span class="nf">get_files_from_dir</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">file_extension</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">file_extension</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="create_circular_mask">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.create_circular_mask">[docs]</a>
<span class="k">def</span> <span class="nf">create_circular_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the middle of the image</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the smallest distance between the center and image walls</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">w</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">h</span><span class="p">,</span> <span class="p">:</span><span class="n">w</span><span class="p">]</span>
    <span class="n">dist_from_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">dist_from_center</span> <span class="o">&lt;=</span> <span class="n">radius</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="apply_mask">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.apply_mask">[docs]</a>
<span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">output_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Assuming image is grayscale or RGB</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">create_circular_mask</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    
    <span class="c1"># If the image has more than one channel, repeat the mask for each channel</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Apply the mask - set pixels outside of the mask to output_value</span>
    <span class="n">masked_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">output_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_image</span></div>

    
<div class="viewcode-block" id="invert_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.invert_image">[docs]</a>
<span class="k">def</span> <span class="nf">invert_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="c1"># The maximum value depends on the image dtype (e.g., 255 for uint8)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="n">inverted_image</span> <span class="o">=</span> <span class="n">max_value</span> <span class="o">-</span> <span class="n">image</span>
    <span class="k">return</span> <span class="n">inverted_image</span>  </div>


<div class="viewcode-block" id="resize_images_and_labels">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.resize_images_and_labels">[docs]</a>
<span class="k">def</span> <span class="nf">resize_images_and_labels</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">show_example</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">plot_resize</span>
    
    <span class="n">resized_images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">resized_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="n">resized_image</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">resized_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">resized_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
            <span class="n">resized_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
        
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="n">resized_image</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">resized_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">resized_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
            <span class="n">resized_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_image</span><span class="p">)</span>
            
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">target_height</span><span class="p">,</span> <span class="n">target_width</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">show_example</span><span class="p">:</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">resized_images</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_resize</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">resized_labels</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">resized_images</span><span class="p">,</span> <span class="n">resized_labels</span></div>


<div class="viewcode-block" id="resize_labels_back">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.resize_labels_back">[docs]</a>
<span class="k">def</span> <span class="nf">resize_labels_back</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">orig_dims</span><span class="p">):</span>
    <span class="n">resized_labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_dims</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of labels and orig_dims must match.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">orig_dims</span><span class="p">):</span>
        <span class="c1"># Ensure dims is a tuple of two integers (width, height)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element in orig_dims must be a tuple of two integers representing the original dimensions (width, height)&quot;</span><span class="p">)</span>

        <span class="n">resized_label</span> <span class="o">=</span> <span class="n">resizescikit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">resized_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resized_label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resized_labels</span></div>


<div class="viewcode-block" id="calculate_iou">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.calculate_iou">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_iou</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
    <span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">pad_to_same_shape</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">union</span> <span class="k">if</span> <span class="n">union</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>

    
<div class="viewcode-block" id="match_masks">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.match_masks">[docs]</a>
<span class="k">def</span> <span class="nf">match_masks</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="p">):</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">matched_true_masks_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Use set to store indices of matched true masks</span>

    <span class="k">for</span> <span class="n">pred_mask</span> <span class="ow">in</span> <span class="n">pred_masks</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">true_mask_index</span><span class="p">,</span> <span class="n">true_mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_masks</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">true_mask_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matched_true_masks_indices</span><span class="p">:</span>
                <span class="n">iou</span> <span class="o">=</span> <span class="n">calculate_iou</span><span class="p">(</span><span class="n">true_mask</span><span class="p">,</span> <span class="n">pred_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iou</span> <span class="o">&gt;=</span> <span class="n">iou_threshold</span><span class="p">:</span>
                    <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">true_mask</span><span class="p">,</span> <span class="n">pred_mask</span><span class="p">))</span>
                    <span class="n">matched_true_masks_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">true_mask_index</span><span class="p">)</span>  <span class="c1"># Store the index of the matched true mask</span>
                    <span class="k">break</span>  <span class="c1"># Move on to the next predicted mask</span>
    <span class="k">return</span> <span class="n">matches</span></div>

    
<div class="viewcode-block" id="compute_average_precision">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.compute_average_precision">[docs]</a>
<span class="k">def</span> <span class="nf">compute_average_precision</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">num_true_masks</span><span class="p">,</span> <span class="n">num_pred_masks</span><span class="p">):</span>
    <span class="n">TP</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
    <span class="n">FP</span> <span class="o">=</span> <span class="n">num_pred_masks</span> <span class="o">-</span> <span class="n">TP</span>
    <span class="n">FN</span> <span class="o">=</span> <span class="n">num_true_masks</span> <span class="o">-</span> <span class="n">TP</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="k">if</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="k">if</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span></div>


<div class="viewcode-block" id="pad_to_same_shape">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.pad_to_same_shape">[docs]</a>
<span class="k">def</span> <span class="nf">pad_to_same_shape</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
    <span class="c1"># Find the shape differences</span>
    <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">pad_mask1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">shape_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="n">mask1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">mask2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">pad_mask2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="n">padded_mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">pad_mask1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">padded_mask2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">pad_mask2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">padded_mask1</span><span class="p">,</span> <span class="n">padded_mask2</span></div>

    
<div class="viewcode-block" id="compute_ap_over_iou_thresholds">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.compute_ap_over_iou_thresholds">[docs]</a>
<span class="k">def</span> <span class="nf">compute_ap_over_iou_thresholds</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="p">):</span>
    <span class="n">precision_recall_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iou_threshold</span> <span class="ow">in</span> <span class="n">iou_thresholds</span><span class="p">:</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">match_masks</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="p">)</span>
        <span class="n">precision</span><span class="p">,</span> <span class="n">recall</span> <span class="o">=</span> <span class="n">compute_average_precision</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_masks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_masks</span><span class="p">))</span>
        <span class="c1"># Check that precision and recall are within the range [0, 1]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">precision</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">recall</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Precision or recall out of bounds. Precision: </span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s1">, Recall: </span><span class="si">{</span><span class="n">recall</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">precision_recall_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">))</span>

    <span class="c1"># Sort by recall values</span>
    <span class="n">precision_recall_pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">precision_recall_pairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sorted_precisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">precision_recall_pairs</span><span class="p">]</span>
    <span class="n">sorted_recalls</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">precision_recall_pairs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">sorted_precisions</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">sorted_recalls</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="compute_segmentation_ap">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.compute_segmentation_ap">[docs]</a>
<span class="k">def</span> <span class="nf">compute_segmentation_ap</span><span class="p">(</span><span class="n">true_masks</span><span class="p">,</span> <span class="n">pred_masks</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
    <span class="n">true_mask_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">true_masks</span><span class="p">)</span>
    <span class="n">pred_mask_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">pred_masks</span><span class="p">)</span>
    <span class="n">true_mask_regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">true_mask_labels</span><span class="p">)]</span>
    <span class="n">pred_mask_regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">pred_mask_labels</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">compute_ap_over_iou_thresholds</span><span class="p">(</span><span class="n">true_mask_regions</span><span class="p">,</span> <span class="n">pred_mask_regions</span><span class="p">,</span> <span class="n">iou_thresholds</span><span class="p">)</span></div>


<div class="viewcode-block" id="jaccard_index">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.jaccard_index">[docs]</a>
<span class="k">def</span> <span class="nf">jaccard_index</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">union</span><span class="p">)</span></div>


<div class="viewcode-block" id="dice_coefficient">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.dice_coefficient">[docs]</a>
<span class="k">def</span> <span class="nf">dice_coefficient</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
    <span class="c1"># Convert to binary masks</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate intersection and total</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask2</span><span class="p">)</span>
    
    <span class="c1"># Handle the case where both masks are empty</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    
    <span class="c1"># Return the Dice coefficient</span>
    <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">intersection</span> <span class="o">/</span> <span class="n">total</span></div>


<div class="viewcode-block" id="extract_boundaries">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.extract_boundaries">[docs]</a>
<span class="k">def</span> <span class="nf">extract_boundaries</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">binary_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">struct_elem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dilation_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">dilated</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">struct_elem</span><span class="p">)</span>
    <span class="n">eroded</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">binary_mask</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">struct_elem</span><span class="p">)</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">dilated</span> <span class="o">^</span> <span class="n">eroded</span>
    <span class="k">return</span> <span class="n">boundary</span></div>


<div class="viewcode-block" id="boundary_f1_score">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.boundary_f1_score">[docs]</a>
<span class="k">def</span> <span class="nf">boundary_f1_score</span><span class="p">(</span><span class="n">mask_true</span><span class="p">,</span> <span class="n">mask_pred</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Assume extract_boundaries is defined to extract object boundaries with given dilation_radius</span>
    <span class="n">boundary_true</span> <span class="o">=</span> <span class="n">extract_boundaries</span><span class="p">(</span><span class="n">mask_true</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="p">)</span>
    <span class="n">boundary_pred</span> <span class="o">=</span> <span class="n">extract_boundaries</span><span class="p">(</span><span class="n">mask_pred</span><span class="p">,</span> <span class="n">dilation_radius</span><span class="p">)</span>
    
    <span class="c1"># Calculate intersection of boundaries</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">boundary_true</span><span class="p">,</span> <span class="n">boundary_pred</span><span class="p">)</span>
    
    <span class="c1"># Calculate precision and recall for boundary detection</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">boundary_pred</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">boundary_true</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="c1"># Calculate F1 score as harmonic mean of precision and recall</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">f1</span></div>




<span class="k">def</span> <span class="nf">_remove_noninfected</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove non-infected cells from the stack based on the provided dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        cell_dim (int or None): The dimension index for the cell mask. If None, a zero-filled mask will be used.</span>
<span class="sd">        nucleus_dim (int or None): The dimension index for the nucleus mask. If None, a zero-filled mask will be used.</span>
<span class="sd">        pathogen_dim (int or None): The dimension index for the pathogen mask. If None, a zero-filled mask will be used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with non-infected cells removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pathogen_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">labels_in_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_in_cell</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nucleus_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="k">return</span> <span class="n">stack</span>

<span class="k">def</span> <span class="nf">_remove_outside_objects</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove outside objects from the stack based on the provided dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        cell_dim (int): The dimension index of the cell mask in the stack.</span>
<span class="sd">        nucleus_dim (int): The dimension index of the nucleus mask in the stack.</span>
<span class="sd">        pathogen_dim (int): The dimension index of the pathogen mask in the stack.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with outside objects removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="n">pathogen_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">pathogen_label</span> <span class="ow">in</span> <span class="n">pathogen_labels</span><span class="p">:</span>
        <span class="n">pathogen_region</span> <span class="o">=</span> <span class="n">pathogen_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span>
        <span class="n">cell_in_pathogen_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">[</span><span class="n">pathogen_region</span><span class="p">])</span>
        <span class="n">cell_in_pathogen_region</span> <span class="o">=</span> <span class="n">cell_in_pathogen_region</span><span class="p">[</span><span class="n">cell_in_pathogen_region</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude background</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_in_pathogen_region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pathogen_mask</span><span class="p">[</span><span class="n">pathogen_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">corresponding_nucleus_region</span> <span class="o">=</span> <span class="n">nucleus_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">corresponding_nucleus_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathogen_mask</span>
    <span class="k">return</span> <span class="n">stack</span>

<span class="k">def</span> <span class="nf">_remove_multiobject_cells</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">mask_dim</span><span class="p">,</span> <span class="n">cell_dim</span><span class="p">,</span> <span class="n">nucleus_dim</span><span class="p">,</span> <span class="n">pathogen_dim</span><span class="p">,</span> <span class="n">object_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove multi-object cells from the stack.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack (ndarray): The stack of images.</span>
<span class="sd">        mask_dim (int): The dimension of the mask in the stack.</span>
<span class="sd">        cell_dim (int): The dimension of the cell in the stack.</span>
<span class="sd">        nucleus_dim (int): The dimension of the nucleus in the stack.</span>
<span class="sd">        pathogen_dim (int): The dimension of the pathogen in the stack.</span>
<span class="sd">        object_dim (int): The dimension of the object in the stack.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated stack with multi-object cells removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">mask_dim</span><span class="p">]</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span>
    <span class="n">object_mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">object_dim</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">labels_in_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">object_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_in_cell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pathogen_label</span> <span class="ow">in</span> <span class="n">labels_in_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Skip the first label (0)</span>
                <span class="n">pathogen_mask</span><span class="p">[</span><span class="n">pathogen_mask</span> <span class="o">==</span> <span class="n">pathogen_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cell_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">nucleus_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nucleus_mask</span>
    <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pathogen_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathogen_mask</span>
    <span class="k">return</span> <span class="n">stack</span>
    
<div class="viewcode-block" id="merge_touching_objects">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.merge_touching_objects">[docs]</a>
<span class="k">def</span> <span class="nf">merge_touching_objects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges touching objects in a binary mask based on the percentage of their shared boundary.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (ndarray): Binary mask representing objects.</span>
<span class="sd">        threshold (float, optional): Threshold value for merging objects. Defaults to 0.25.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Merged mask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perimeters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="c1"># Calculating perimeter of each object</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Ignore background</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">erosion</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="n">perimeters</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="c1"># Detect touching objects and find the shared boundary</span>
    <span class="n">shared_perimeters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dilated</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Ignore background</span>
            <span class="c1"># Find the objects that this object is touching</span>
            <span class="n">dilated_label</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>
            <span class="n">touching_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">dilated</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dilated_label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">touching_label</span> <span class="ow">in</span> <span class="n">touching_labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">touching_label</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>  <span class="c1"># Exclude the object itself</span>
                    <span class="n">shared_boundary</span> <span class="o">=</span> <span class="n">dilated_label</span> <span class="o">&amp;</span> <span class="n">morphology</span><span class="o">.</span><span class="n">dilation</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">touching_label</span><span class="p">)</span>
                    <span class="n">shared_perimeters</span><span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">touching_label</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shared_boundary</span><span class="p">)</span>
    <span class="c1"># Merge objects if more than 25% of their boundary is touching</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">label2</span><span class="p">),</span> <span class="n">shared_perimeter</span> <span class="ow">in</span> <span class="n">shared_perimeters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">shared_perimeter</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">perimeters</span><span class="p">[</span><span class="n">label1</span><span class="p">],</span> <span class="n">perimeters</span><span class="p">[</span><span class="n">label2</span><span class="p">]):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">label2</span><span class="p">]</span> <span class="o">=</span> <span class="n">label1</span>  <span class="c1"># Merge label2 into label1</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="remove_intensity_objects">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.remove_intensity_objects">[docs]</a>
<span class="k">def</span> <span class="nf">remove_intensity_objects</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">intensity_threshold</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes objects from the mask based on their mean intensity in the original image.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (ndarray): The original image.</span>
<span class="sd">        mask (ndarray): The mask containing labeled objects.</span>
<span class="sd">        intensity_threshold (float): The threshold value for mean intensity.</span>
<span class="sd">        mode (str): The mode for intensity comparison. Can be &#39;low&#39; or &#39;high&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The updated mask with objects removed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the mean intensity of each object in the original image</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">))</span>
    <span class="c1"># Find the labels of the objects with mean intensity below the threshold</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span><span class="p">:</span>
        <span class="n">labels_to_remove</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intensity_threshold</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">:</span>
        <span class="n">labels_to_remove</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intensity_threshold</span><span class="p">]</span>
    <span class="c1"># Remove these objects from the mask</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">labels_to_remove</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">mask</span></div>

    
<span class="k">def</span> <span class="nf">_filter_closest_to_stat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">use_median</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the DataFrame to include the closest rows to a statistical measure.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The input DataFrame.</span>
<span class="sd">        column (str): The column name to calculate the statistical measure.</span>
<span class="sd">        n_rows (int): The number of closest rows to include in the result.</span>
<span class="sd">        use_median (bool, optional): Whether to use the median or mean as the statistical measure. </span>
<span class="sd">            Defaults to False (mean).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The filtered DataFrame with the closest rows to the statistical measure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_median</span><span class="p">:</span>
        <span class="n">target_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_value</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;diff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result_df</span>
    
<span class="k">def</span> <span class="nf">_find_similar_sized_images</span><span class="p">(</span><span class="n">file_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the largest group of images with the most similar size and shape.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_list (list): List of file paths to the images.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: List of file paths belonging to the largest group of images with the most similar size and shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Dictionary to hold image sizes and their paths</span>
    <span class="n">size_to_paths</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="c1"># Iterate over image paths to get their dimensions</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_UNCHANGED</span><span class="p">)</span>  <span class="c1"># Read with unchanged color space to support different image types</span>
        <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Find indices where the image is not padded (non-zero)</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Color image</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Grayscale image</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># Find the bounding box of non-zero regions</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip images that are completely padded</span>
                <span class="k">continue</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Add 1 because slice end index is exclusive</span>
            <span class="c1"># Crop the image to remove padding</span>
            <span class="n">cropped_img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span>
            <span class="c1"># Get dimensions of the cropped image</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">cropped_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span>
            <span class="n">size_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Group by width, height, and aspect ratio</span>
            <span class="n">size_to_paths</span><span class="p">[</span><span class="n">size_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="c1"># Find the largest group of images with the most similar size and shape</span>
    <span class="n">largest_group</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">size_to_paths</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">largest_group</span>
    
<span class="k">def</span> <span class="nf">_relabel_parent_with_child_labels</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">,</span> <span class="n">child_mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relabels the parent mask based on overlapping child labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        parent_mask (ndarray): Binary mask representing the parent objects.</span>
<span class="sd">        child_mask (ndarray): Binary mask representing the child objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the relabeled parent mask and the original child mask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Label parent mask to identify unique objects</span>
    <span class="n">parent_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Use the original child mask labels directly, without relabeling</span>
    <span class="n">child_labels</span> <span class="o">=</span> <span class="n">child_mask</span>

    <span class="c1"># Create a new parent mask for updated labels</span>
    <span class="n">parent_mask_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">parent_mask</span><span class="p">)</span>

    <span class="c1"># Directly relabel parent cells based on overlapping child labels</span>
    <span class="n">unique_child_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">child_labels</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Skip background</span>
    <span class="k">for</span> <span class="n">child_label</span> <span class="ow">in</span> <span class="n">unique_child_labels</span><span class="p">:</span>
        <span class="n">child_area_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">child_labels</span> <span class="o">==</span> <span class="n">child_label</span><span class="p">)</span>
        <span class="n">overlapping_parent_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">parent_labels</span><span class="p">[</span><span class="n">child_area_mask</span><span class="p">])</span>

        <span class="c1"># Since each parent is assumed to overlap with exactly one nucleus,</span>
        <span class="c1"># directly set the parent label to the child label where overlap occurs</span>
        <span class="k">for</span> <span class="n">parent_label</span> <span class="ow">in</span> <span class="n">overlapping_parent_label</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent_label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip background</span>
                <span class="n">parent_mask_new</span><span class="p">[</span><span class="n">parent_labels</span> <span class="o">==</span> <span class="n">parent_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_label</span>

    <span class="c1"># For cells containing multiple nucleus, standardize all nucleus to the first label</span>
    <span class="c1"># This will be done only if needed, as per your condition</span>
    <span class="k">for</span> <span class="n">parent_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">parent_mask_new</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Skip background</span>
        <span class="n">parent_area_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent_mask_new</span> <span class="o">==</span> <span class="n">parent_label</span><span class="p">)</span>
        <span class="n">child_labels_in_parent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">child_mask</span><span class="p">[</span><span class="n">parent_area_mask</span><span class="p">])</span>
        <span class="n">child_labels_in_parent</span> <span class="o">=</span> <span class="n">child_labels_in_parent</span><span class="p">[</span><span class="n">child_labels_in_parent</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Exclude background</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_labels_in_parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Standardize to the first child label within this parent</span>
            <span class="n">first_child_label</span> <span class="o">=</span> <span class="n">child_labels_in_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">child_label</span> <span class="ow">in</span> <span class="n">child_labels_in_parent</span><span class="p">:</span>
                <span class="n">child_mask</span><span class="p">[</span><span class="n">child_mask</span> <span class="o">==</span> <span class="n">child_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_child_label</span>

    <span class="k">return</span> <span class="n">parent_mask_new</span><span class="p">,</span> <span class="n">child_mask</span>
    
<span class="k">def</span> <span class="nf">_exclude_objects</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">pathogen_mask</span><span class="p">,</span> <span class="n">cytoplasm_mask</span><span class="p">,</span> <span class="n">uninfected</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exclude objects from the masks based on certain criteria.</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_mask (ndarray): Mask representing cells.</span>
<span class="sd">        nucleus_mask (ndarray): Mask representing nucleus.</span>
<span class="sd">        pathogen_mask (ndarray): Mask representing pathogens.</span>
<span class="sd">        cytoplasm_mask (ndarray): Mask representing cytoplasm.</span>
<span class="sd">        uninfected (bool, optional): Whether to include uninfected cells. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the filtered cell mask, nucleus mask, pathogen mask, and cytoplasm mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove cells with no nucleus or cytoplasm (or pathogen)</span>
    <span class="n">filtered_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span> <span class="c1"># Initialize a new mask to store the filtered cells.</span>
    <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">):</span> <span class="c1"># Iterate over all cell labels in the cell mask.</span>
        <span class="k">if</span> <span class="n">cell_label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Skip background</span>
            <span class="k">continue</span>
        <span class="n">cell_region</span> <span class="o">=</span> <span class="n">cell_mask</span> <span class="o">==</span> <span class="n">cell_label</span> <span class="c1"># Get a mask for the current cell.</span>
        <span class="c1"># Check existence of nucleus, cytoplasm and pathogen in the current cell.</span>
        <span class="n">has_nucleus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="n">has_cytoplasm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cytoplasm_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="n">has_pathogen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pathogen_mask</span><span class="p">[</span><span class="n">cell_region</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">uninfected</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_nucleus</span> <span class="ow">and</span> <span class="n">has_cytoplasm</span><span class="p">:</span>
                <span class="n">filtered_cells</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_nucleus</span> <span class="ow">and</span> <span class="n">has_cytoplasm</span> <span class="ow">and</span> <span class="n">has_pathogen</span><span class="p">:</span>
                <span class="n">filtered_cells</span><span class="p">[</span><span class="n">cell_region</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_label</span>
    <span class="c1"># Remove objects outside of cells</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">nucleus_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pathogen_mask</span> <span class="o">=</span> <span class="n">pathogen_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cytoplasm_mask</span> <span class="o">=</span> <span class="n">cytoplasm_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">filtered_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_cells</span><span class="p">,</span> <span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">pathogen_mask</span><span class="p">,</span> <span class="n">cytoplasm_mask</span>

<span class="k">def</span> <span class="nf">_merge_overlapping_objects</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge overlapping objects in two masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask1 (ndarray): First mask.</span>
<span class="sd">        mask2 (ndarray): Second mask.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the merged masks (mask1, mask2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labeled_1</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span>
    <span class="n">num_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m1_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_1_mask</span> <span class="o">=</span> <span class="n">labeled_1</span> <span class="o">==</span> <span class="n">m1_id</span>
        <span class="n">overlapping_2_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask2</span><span class="p">[</span><span class="n">current_1_mask</span><span class="p">])</span>
        <span class="n">overlapping_2_labels</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="n">overlapping_2_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_2_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_1_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_1_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">]</span>
            <span class="n">max_overlap_label</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">overlap_percentages</span><span class="p">)]</span>
            <span class="n">max_overlap_percentage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">overlap_percentages</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_overlap_percentage</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">m2_label</span> <span class="o">!=</span> <span class="n">max_overlap_label</span><span class="p">:</span>
                        <span class="n">mask1</span><span class="p">[(</span><span class="n">current_1_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m2_label</span> <span class="ow">in</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">mask2</span><span class="p">[</span><span class="n">mask2</span> <span class="o">==</span> <span class="n">m2_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlapping_2_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span>

<span class="k">def</span> <span class="nf">_filter_object</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">min_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter objects in a mask based on their frequency.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (ndarray): The input mask.</span>
<span class="sd">        min_value (int): The minimum frequency threshold.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The filtered mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">mask</span>

<span class="k">def</span> <span class="nf">_filter_cp_masks</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">filter_intensity</span><span class="p">,</span> <span class="n">minimum_size</span><span class="p">,</span> <span class="n">maximum_size</span><span class="p">,</span> <span class="n">remove_border_objects</span><span class="p">,</span> <span class="n">merge</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the masks based on various criteria such as size, border objects, merging, and intensity.</span>

<span class="sd">    Args:</span>
<span class="sd">        masks (list): List of masks.</span>
<span class="sd">        flows (list): List of flows.</span>
<span class="sd">        filter_size (bool): Flag indicating whether to filter based on size.</span>
<span class="sd">        filter_intensity (bool): Flag indicating whether to filter based on intensity.</span>
<span class="sd">        minimum_size (int): Minimum size of objects to keep.</span>
<span class="sd">        maximum_size (int): Maximum size of objects to keep.</span>
<span class="sd">        remove_border_objects (bool): Flag indicating whether to remove border objects.</span>
<span class="sd">        merge (bool): Flag indicating whether to merge adjacent objects.</span>
<span class="sd">        batch (ndarray): Batch of images.</span>
<span class="sd">        plot (bool): Flag indicating whether to plot the masks.</span>
<span class="sd">        figuresize (tuple): Size of the figure.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: List of filtered masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">plot_masks</span>
    
    <span class="n">mask_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch</span><span class="p">)):</span>
        
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects before filtration: </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">merge_touching_objects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.66</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after merging adjacent objects, : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_size</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">])</span>
            <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minimum_size</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maximum_size</span><span class="p">)]</span> 
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after size filtration &gt;</span><span class="si">{</span><span class="n">minimum_size</span><span class="si">}</span><span class="s1"> and &lt;</span><span class="si">{</span><span class="n">maximum_size</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_intensity</span><span class="p">:</span>
            <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>  
            <span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">intensity_image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span>
            <span class="n">mean_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mean_intensities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">mean_intensities</span><span class="p">)</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
            
                <span class="c1"># Calculate the Euclidean distance between the two centroids</span>
                <span class="n">dist_between_centroids</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="c1"># Set a threshold for the minimum distance to consider clusters distinct</span>
                <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mf">0.25</span> 
                
                <span class="k">if</span> <span class="n">dist_between_centroids</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span><span class="p">:</span>
                    <span class="n">high_intensity_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
                    <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">])[</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">high_intensity_cluster</span><span class="p">]</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">props_after</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">intensity_image</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">])</span>
                <span class="n">mean_intensities_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">props_after</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]))</span>
                <span class="n">average_intensity_before</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_intensities</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after potential intensity clustering: </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">. Mean intensity before:</span><span class="si">{</span><span class="n">average_intensity_before</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">. After:</span><span class="si">{</span><span class="n">mean_intensities_after</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">remove_border_objects</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_objects</span> <span class="o">=</span> <span class="n">mask_object_count</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of objects after removing border objects, : </span><span class="si">{</span><span class="n">num_objects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plot_masks</span><span class="p">(</span><span class="n">batch</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">flows</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">nr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">print_object_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">mask_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mask_stack</span>
    
<span class="k">def</span> <span class="nf">_object_filter</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">object_type</span><span class="p">,</span> <span class="n">size_range</span><span class="p">,</span> <span class="n">intensity_range</span><span class="p">,</span> <span class="n">mask_chans</span><span class="p">,</span> <span class="n">mask_chan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the DataFrame based on object type, size range, and intensity range.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pandas.DataFrame): The DataFrame to filter.</span>
<span class="sd">        object_type (str): The type of object to filter.</span>
<span class="sd">        size_range (list or None): The range of object sizes to filter.</span>
<span class="sd">        intensity_range (list or None): The range of object intensities to filter.</span>
<span class="sd">        mask_chans (list): The list of mask channels.</span>
<span class="sd">        mask_chan (int): The index of the mask channel to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: The filtered DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">size_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span> 
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_area&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> minimum area filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_area&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> maximum area filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">intensity_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">mask_chans</span><span class="p">[</span><span class="n">mask_chan</span><span class="p">]</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> minimum mean intensity filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1">_channel_</span><span class="si">{</span><span class="n">mask_chans</span><span class="p">[</span><span class="n">mask_chan</span><span class="p">]</span><span class="si">}</span><span class="s1">_mean_intensity&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intensity_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;After </span><span class="si">{</span><span class="n">object_type</span><span class="si">}</span><span class="s1"> maximum mean intensity filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="k">def</span> <span class="nf">_get_regex</span><span class="p">(</span><span class="n">metadata_type</span><span class="p">,</span> <span class="n">img_format</span><span class="p">,</span> <span class="n">custom_regex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">img_format</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img_format</span> <span class="o">==</span> <span class="s1">&#39;.tif&#39;</span>
    <span class="k">if</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;cellvoyager&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;..)A(?P&lt;AID&gt;..)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;cq1&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;W(?P&lt;wellID&gt;.*)F(?P&lt;fieldID&gt;.*)T(?P&lt;timeID&gt;.*)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;nikon&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;..)A(?P&lt;AID&gt;..)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;zeis&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;..)A(?P&lt;AID&gt;..)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;leica&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(?P&lt;plateID&gt;.*)_(?P&lt;wellID&gt;.*)_T(?P&lt;timeID&gt;.*)F(?P&lt;fieldID&gt;.*)L(?P&lt;laserID&gt;..)A(?P&lt;AID&gt;..)Z(?P&lt;sliceID&gt;.*)C(?P&lt;chanID&gt;.*)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">metadata_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">custom_regex</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;regex mode:</span><span class="si">{</span><span class="n">metadata_type</span><span class="si">}</span><span class="s1"> regex:</span><span class="si">{</span><span class="n">regex</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">regex</span>

<span class="k">def</span> <span class="nf">_run_test_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">timelapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">test_images</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_test</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">timelapse</span><span class="p">:</span>
        <span class="n">test_images</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Use only 1 set for timelapse to ensure full sequence inclusion</span>
    
    <span class="n">test_folder_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">test_folder_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">regular_expression</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;orig&#39;</span><span class="p">)):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;orig&#39;</span><span class="p">)</span>
    
    <span class="n">all_filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="k">if</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_filenames</span><span class="p">)</span><span class="si">}</span><span class="s1"> files&#39;</span><span class="p">)</span>
    <span class="n">images_by_set</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">all_filenames</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">regular_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">plate</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;plateID&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;plateID&#39;</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="n">well</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wellID&#39;</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;fieldID&#39;</span><span class="p">)</span>
            <span class="n">set_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="n">images_by_set</span><span class="p">[</span><span class="n">set_identifier</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    
    <span class="c1"># Prepare for random selection</span>
    <span class="n">set_identifiers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images_by_set</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">random_test</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">set_identifiers</span><span class="p">)</span>  <span class="c1"># Randomize the order</span>
    
    <span class="c1"># Select a subset based on the test_images count</span>
    <span class="n">selected_sets</span> <span class="o">=</span> <span class="n">set_identifiers</span><span class="p">[:</span><span class="n">test_images</span><span class="p">]</span>

    <span class="c1"># Print information about the number of sets used</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_sets</span><span class="p">)</span><span class="si">}</span><span class="s1"> random image set(s) for test model&#39;</span><span class="p">)</span>

    <span class="c1"># Copy files for selected sets to the test folder</span>
    <span class="k">for</span> <span class="n">set_identifier</span> <span class="ow">in</span> <span class="n">selected_sets</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">images_by_set</span><span class="p">[</span><span class="n">set_identifier</span><span class="p">]:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">test_folder_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">test_folder_path</span>

<span class="k">def</span> <span class="nf">_choose_model</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">object_type</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">restore_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">object_settings</span><span class="o">=</span><span class="p">{}):</span>
    
    <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;toxo_pv_lumen&#39;</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">object_settings</span><span class="p">[</span><span class="s1">&#39;diameter&#39;</span><span class="p">]</span>
            <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span> <span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="s1">&#39;toxo_pv_lumen.CP_model&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cp_models</span><span class="o">.</span><span class="n">CellposeModel</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">model_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pretrained_model</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">diam_mean</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="c1">#model = cp_models.Cellpose(gpu=torch.cuda.is_available(), model_type=&#39;cyto&#39;, device=device)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using Toxoplasma PV lumen model to generate pathogen masks&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>
    
    <span class="n">restore_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;denoise&#39;</span><span class="p">,</span> <span class="s1">&#39;deblur&#39;</span><span class="p">,</span> <span class="s1">&#39;upsample&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">restore_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">restore_list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid restore type. Choose from </span><span class="si">{</span><span class="n">restore_list</span><span class="si">}</span><span class="s2"> defaulting to None&quot;</span><span class="p">)</span>
        <span class="n">restore_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">restore_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">,</span> <span class="s1">&#39;cyto2&#39;</span><span class="p">,</span> <span class="s1">&#39;cyto3&#39;</span><span class="p">,</span> <span class="s1">&#39;nuclei&#39;</span><span class="p">]:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cp_models</span><span class="o">.</span><span class="n">Cellpose</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">model_type</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">:</span>
            <span class="n">restore</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s1">_nuclei&#39;</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">denoise</span><span class="o">.</span><span class="n">CellposeDenoiseModel</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">model_type</span><span class="o">=</span><span class="s2">&quot;nuclei&quot;</span><span class="p">,</span><span class="n">restore_type</span><span class="o">=</span><span class="n">restore</span><span class="p">,</span> <span class="n">chan2_restore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">restore</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s1">_cyto3&#39;</span>
            <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span><span class="s1">&#39;cyto2&#39;</span><span class="p">:</span>
                <span class="n">chan2_restore</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span><span class="s1">&#39;cyto&#39;</span><span class="p">:</span>
                <span class="n">chan2_restore</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">denoise</span><span class="o">.</span><span class="n">CellposeDenoiseModel</span><span class="p">(</span><span class="n">gpu</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">(),</span> <span class="n">model_type</span><span class="o">=</span><span class="s2">&quot;cyto3&quot;</span><span class="p">,</span><span class="n">restore_type</span><span class="o">=</span><span class="n">restore</span><span class="p">,</span> <span class="n">chan2_restore</span><span class="o">=</span><span class="n">chan2_restore</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model</span>

<div class="viewcode-block" id="SelectChannels">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SelectChannels">[docs]</a>
<span class="k">class</span> <span class="nc">SelectChannels</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
    
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the red channel</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the green channel</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Zero out the blue channel</span>
        <span class="k">return</span> <span class="n">img</span></div>

    
<span class="k">def</span> <span class="nf">preprocess_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
            <span class="n">SelectChannels</span><span class="p">(</span><span class="n">channels</span><span class="p">),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">std</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
            <span class="n">SelectChannels</span><span class="p">(</span><span class="n">channels</span><span class="p">)])</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">input_tensor</span>

<div class="viewcode-block" id="SaliencyMapGenerator">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SaliencyMapGenerator">[docs]</a>
<span class="k">class</span> <span class="nc">SaliencyMapGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

<div class="viewcode-block" id="SaliencyMapGenerator.compute_saliency_maps">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SaliencyMapGenerator.compute_saliency_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_saliency_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># For binary classification, target scores can be the single output</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="n">saliency</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">saliency</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator.compute_saliency_and_predictions">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SaliencyMapGenerator.compute_saliency_and_predictions">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_saliency_and_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass to get predictions (logits)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Get predicted class (0 or 1 for binary classification)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Compute saliency maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">predictions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="n">saliency</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">saliency</span><span class="p">,</span> <span class="n">predictions</span></div>


<div class="viewcode-block" id="SaliencyMapGenerator.plot_activation_grid">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SaliencyMapGenerator.plot_activation_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_activation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">saliency</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">overlay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> 
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">]</span>
            <span class="n">saliency_map</span> <span class="o">=</span> <span class="n">saliency</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># Move to CPU and convert to numpy</span>

            <span class="k">if</span> <span class="n">saliency_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Channels first, reshape to (H, W, 3)</span>
                <span class="n">saliency_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">saliency_map</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Normalize image channels to 2nd and 98th percentiles</span>
            <span class="k">if</span> <span class="n">overlay</span><span class="p">:</span>
                <span class="n">img_np</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">img_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile_normalize</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">saliency_map</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># Add class label in the top-left corner</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span>
                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round,pad=0.2&#39;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    
<div class="viewcode-block" id="SaliencyMapGenerator.percentile_normalize">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.SaliencyMapGenerator.percentile_normalize">[docs]</a>
    <span class="k">def</span> <span class="nf">percentile_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">lower_percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize each channel of the image to the given percentiles.</span>
<span class="sd">        Args:</span>
<span class="sd">            img: Input image as numpy array with shape (H, W, C)</span>
<span class="sd">            lower_percentile: Lower percentile for normalization (default 2)</span>
<span class="sd">            upper_percentile: Upper percentile for normalization (default 98)</span>
<span class="sd">        Returns:</span>
<span class="sd">            img: Normalized image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>  <span class="c1"># Iterate over each channel</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">lower_percentile</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">upper_percentile</span><span class="p">)</span>
            <span class="n">img_normalized</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_normalized</span></div>
</div>



<div class="viewcode-block" id="GradCAMGenerator">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator">[docs]</a>
<span class="k">class</span> <span class="nc">GradCAMGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">cam_type</span><span class="o">=</span><span class="s1">&#39;gradcam&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer</span> <span class="o">=</span> <span class="n">target_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cam_type</span> <span class="o">=</span> <span class="n">cam_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activations</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Hook the target layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hook_layers</span><span class="p">()</span>

<div class="viewcode-block" id="GradCAMGenerator.hook_layers">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.hook_layers">[docs]</a>
    <span class="k">def</span> <span class="nf">hook_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Forward hook to get activations</span>
        <span class="k">def</span> <span class="nf">forward_hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activations</span> <span class="o">=</span> <span class="n">output</span>

        <span class="c1"># Backward hook to get gradients</span>
        <span class="k">def</span> <span class="nf">backward_hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="n">grad_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">forward_hook</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layer_module</span><span class="o">.</span><span class="n">register_backward_hook</span><span class="p">(</span><span class="n">backward_hook</span><span class="p">)</span></div>


<div class="viewcode-block" id="GradCAMGenerator.get_layer">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.get_layer">[docs]</a>
    <span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">):</span>
        <span class="c1"># Recursively find the layer specified in target_layer</span>
        <span class="n">modules</span> <span class="o">=</span> <span class="n">target_layer</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">layer</span></div>


<div class="viewcode-block" id="GradCAMGenerator.compute_gradcam_maps">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.compute_gradcam_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradcam_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Perform backward pass</span>
        <span class="n">target_scores</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">target_scores</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">target_scores</span><span class="p">))</span>

        <span class="c1"># Compute GradCAM</span>
        <span class="n">pooled_gradients</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradients</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">pooled_gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activations</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">gradcam</span><span class="p">)</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">gradcam</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">gradcam</span> <span class="o">=</span> <span class="p">(</span><span class="n">gradcam</span> <span class="o">-</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">gradcam</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">gradcam</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">gradcam</span></div>


<div class="viewcode-block" id="GradCAMGenerator.compute_gradcam_and_predictions">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.compute_gradcam_and_predictions">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradcam_and_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">X</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

        <span class="c1"># Forward pass to get predictions (logits)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Get predicted class (0 or 1 for binary classification)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Compute gradcam maps</span>
        <span class="n">gradcam_maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">gradcam_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_gradcam_maps</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">gradcam_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gradcam_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">gradcam_maps</span><span class="p">),</span> <span class="n">predictions</span></div>


<div class="viewcode-block" id="GradCAMGenerator.plot_activation_grid">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.plot_activation_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_activation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gradcam</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">overlay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">]</span>
            <span class="n">gradcam_map</span> <span class="o">=</span> <span class="n">gradcam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

            <span class="c1"># Normalize image channels to 2nd and 98th percentiles</span>
            <span class="k">if</span> <span class="n">overlay</span><span class="p">:</span>
                <span class="n">img_np</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">img_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile_normalize</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gradcam_map</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="c1">#ax.imshow(X[i].permute(1, 2, 0).detach().cpu().numpy())  # Original image</span>
            <span class="c1">#ax.imshow(gradcam_map, cmap=&#39;jet&#39;, alpha=0.5)  # Overlay the gradcam map</span>

            <span class="c1"># Add class label in the top-left corner</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span>
                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round,pad=0.2&#39;</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    
<div class="viewcode-block" id="GradCAMGenerator.percentile_normalize">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAMGenerator.percentile_normalize">[docs]</a>
    <span class="k">def</span> <span class="nf">percentile_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">lower_percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">98</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize each channel of the image to the given percentiles.</span>
<span class="sd">        Args:</span>
<span class="sd">            img: Input image as numpy array with shape (H, W, C)</span>
<span class="sd">            lower_percentile: Lower percentile for normalization (default 2)</span>
<span class="sd">            upper_percentile: Upper percentile for normalization (default 98)</span>
<span class="sd">        Returns:</span>
<span class="sd">            img: Normalized image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>  <span class="c1"># Iterate over each channel</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">lower_percentile</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">upper_percentile</span><span class="p">)</span>
            <span class="n">img_normalized</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_normalized</span></div>
</div>


<div class="viewcode-block" id="preprocess_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.preprocess_image">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]):</span>
    <span class="n">preprocess</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
    <span class="p">])</span>
    
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span> <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">])(</span><span class="n">input_tensor</span><span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">input_tensor</span></div>


<div class="viewcode-block" id="class_visualization">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.class_visualization">[docs]</a>
<span class="k">def</span> <span class="nf">class_visualization</span><span class="p">(</span><span class="n">target_y</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">img_size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">l2_reg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blur_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_jitter</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">show_every</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="s1">&#39;pc&#39;</span><span class="p">]):</span>
    
    <span class="k">def</span> <span class="nf">jitter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">):</span>
        <span class="c1"># Randomly jitter the image</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">oy</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blur_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Apply Gaussian blur to the image</span>
        <span class="n">img_np</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">img_np</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">img_np</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">img</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">img_np</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">deprocess</span><span class="p">(</span><span class="n">img_tensor</span><span class="p">):</span>
        <span class="c1"># Convert the tensor image to a numpy array for visualization</span>
        <span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">img_tensor</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">img_tensor</span> <span class="o">=</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img_tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    
    <span class="c1"># Assuming these are defined somewhere in your codebase</span>
    <span class="n">SQUEEZENET_MEAN</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
    <span class="n">SQUEEZENET_STD</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
    
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">FloatTensor</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span>
    <span class="n">len_chans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Randomly initialize the image as a PyTorch Tensor, and make it requires gradient.</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_chans</span><span class="p">,</span> <span class="n">img_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
        <span class="c1"># Randomly jitter the image a bit; this gives slightly nicer results</span>
        <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_jitter</span><span class="p">),</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_jitter</span><span class="p">)</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">jitter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">))</span>

        <span class="c1"># Forward pass</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">target_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">target_score</span> <span class="o">=</span> <span class="o">-</span><span class="n">score</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_score</span> <span class="o">=</span> <span class="n">score</span>

        <span class="c1"># Add regularization</span>
        <span class="n">target_score</span> <span class="o">=</span> <span class="n">target_score</span> <span class="o">-</span> <span class="n">l2_reg</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="c1"># Backward pass</span>
        <span class="n">target_score</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># Gradient ascent step</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">img</span> <span class="o">+=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">grad</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

        <span class="c1"># Undo the random jitter</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">jitter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="n">ox</span><span class="p">,</span> <span class="o">-</span><span class="n">oy</span><span class="p">))</span>

        <span class="c1"># As regularizer, clamp and periodically blur the image</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SQUEEZENET_MEAN</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">/</span> <span class="n">SQUEEZENET_STD</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">lo</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">hi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">%</span> <span class="n">blur_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blur_image</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        
        <span class="c1"># Periodically show the image</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">show_every</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">==</span> <span class="n">num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">deprocess</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()))</span>
            <span class="n">class_name</span> <span class="o">=</span> <span class="n">class_names</span><span class="p">[</span><span class="n">target_y</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">Iteration </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">deprocess</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span></div>


<div class="viewcode-block" id="get_submodules">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_submodules">[docs]</a>
<span class="k">def</span> <span class="nf">get_submodules</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="n">submodules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
        <span class="n">full_name</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">submodules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_name</span><span class="p">)</span>
        <span class="n">submodules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_submodules</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">full_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">submodules</span></div>


<div class="viewcode-block" id="GradCAM">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAM">[docs]</a>
<span class="k">class</span> <span class="nc">GradCAM</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">target_layers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_layers</span> <span class="o">=</span> <span class="n">target_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span> <span class="o">=</span> <span class="n">use_cuda</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<div class="viewcode-block" id="GradCAM.forward">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.GradCAM.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">hook</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_layers</span><span class="p">:</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">hook</span><span class="p">))</span>

        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">one_hot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">one_hot</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="n">one_hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">one_hot</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">one_hot</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">grads_val</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grads_val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">cam</span> <span class="o">+=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
        <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">cam</span></div>


<div class="viewcode-block" id="show_cam_on_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.show_cam_on_image">[docs]</a>
<span class="k">def</span> <span class="nf">show_cam_on_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="n">heatmap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">applyColorMap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">mask</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLORMAP_JET</span><span class="p">)</span>
    <span class="n">heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">cam</span> <span class="o">=</span> <span class="n">heatmap</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">cam</span><span class="p">)</span></div>


<div class="viewcode-block" id="recommend_target_layers">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.recommend_target_layers">[docs]</a>
<span class="k">def</span> <span class="nf">recommend_target_layers</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="n">target_layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
            <span class="n">target_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># Choose the last conv layer as the recommended target layer</span>
    <span class="k">if</span> <span class="n">target_layers</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">target_layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">target_layers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No convolutional layers found in the model.&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="IntegratedGradients">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.IntegratedGradients">[docs]</a>
<span class="k">class</span> <span class="nc">IntegratedGradients</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<div class="viewcode-block" id="IntegratedGradients.generate_integrated_gradients">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.IntegratedGradients.generate_integrated_gradients">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_integrated_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target_label_idx</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">input_tensor</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Scale input and compute gradients</span>
        <span class="n">scaled_inputs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">baseline</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_steps</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_tensor</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">))</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scaled_input</span> <span class="ow">in</span> <span class="n">scaled_inputs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">scaled_input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_label_idx</span><span class="p">]</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">grads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_input</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="n">avg_grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grads</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">integrated_grads</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_tensor</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">baseline</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span> <span class="o">*</span> <span class="n">avg_grads</span>
        <span class="k">return</span> <span class="n">integrated_grads</span></div>
</div>


<div class="viewcode-block" id="get_db_paths">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_db_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_db_paths</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span>
    <span class="n">db_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;measurements/measurements.db&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">db_paths</span></div>


<div class="viewcode-block" id="get_sequencing_paths">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_sequencing_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_sequencing_paths</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span>
    <span class="n">seq_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;sequencing/sequencing_data.csv&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">seq_paths</span></div>


<div class="viewcode-block" id="load_image_paths">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.load_image_paths">[docs]</a>
<span class="k">def</span> <span class="nf">load_image_paths</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">visualize</span><span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SELECT * FROM png_list&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">columns_info</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;PRAGMA table_info(png_list)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_info</span> <span class="ow">in</span> <span class="n">columns_info</span><span class="p">]</span>
    <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
        <span class="n">object_visualize</span> <span class="o">=</span> <span class="n">visualize</span> <span class="o">+</span> <span class="s1">&#39;_png&#39;</span>
        <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="p">[</span><span class="n">image_paths_df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">object_visualize</span><span class="p">)]</span>
    <span class="n">image_paths_df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;prcfo&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image_paths_df</span></div>


<div class="viewcode-block" id="merge_dataframes">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.merge_dataframes">[docs]</a>
<span class="k">def</span> <span class="nf">merge_dataframes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">image_paths_df</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;prcfo&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">image_paths_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    <span class="n">upper_tri</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">upper_tri</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">upper_tri</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="filter_columns">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.filter_columns">[docs]</a>
<span class="k">def</span> <span class="nf">filter_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">filter_by</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">filter_by</span> <span class="o">!=</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
        <span class="n">cols_to_include</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">filter_by</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cols_to_include</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;channel&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cols_to_include</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="reduction_and_clustering">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.reduction_and_clustering">[docs]</a>
<span class="k">def</span> <span class="nf">reduction_and_clustering</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">reduction_method</span><span class="o">=</span><span class="s1">&#39;umap&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform dimensionality reduction and clustering on the given data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    numeric_data (np.ndarray): Numeric data for embedding and clustering.</span>
<span class="sd">    n_neighbors (int or float): Number of neighbors for UMAP or perplexity for t-SNE.</span>
<span class="sd">    min_dist (float): Minimum distance for UMAP.</span>
<span class="sd">    metric (str): Metric for UMAP and DBSCAN.</span>
<span class="sd">    eps (float): Epsilon for DBSCAN.</span>
<span class="sd">    min_samples (int): Minimum samples for DBSCAN or number of clusters for KMeans.</span>
<span class="sd">    clustering (str): Clustering method (&#39;DBSCAN&#39; or &#39;KMeans&#39;).</span>
<span class="sd">    reduction_method (str): Dimensionality reduction method (&#39;UMAP&#39; or &#39;tSNE&#39;).</span>
<span class="sd">    verbose (bool): Whether to print verbose output.</span>
<span class="sd">    embedding (np.ndarray, optional): Precomputed embedding. Default is None.</span>
<span class="sd">    return_model (bool): Whether to return the reducer model. Default is False.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    tuple: embedding, labels (and optionally the reducer model)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fit&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;umap&#39;</span><span class="p">:</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span>
                                <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                <span class="n">n_epochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">init</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">,</span>
                                <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                                <span class="n">spread</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">set_op_mix_ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">local_connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">repulsion_strength</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">negative_sample_rate</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">transform_queue_size</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                                <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                <span class="n">metric_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">angular_rp_forest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">target_n_neighbors</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">target_metric</span><span class="o">=</span><span class="s1">&#39;categorical&#39;</span><span class="p">,</span>
                                <span class="n">target_metric_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">target_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                <span class="n">transform_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;tsne&#39;</span><span class="p">:</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">perplexity</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span>
                        <span class="n">early_exaggeration</span><span class="o">=</span><span class="mf">12.0</span><span class="p">,</span>
                        <span class="n">learning_rate</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
                        <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">n_iter_without_progress</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                        <span class="n">min_grad_norm</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
                        <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                        <span class="n">init</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;barnes_hut&#39;</span><span class="p">,</span>
                        <span class="n">angle</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported reduction method: </span><span class="si">{</span><span class="n">reduction_method</span><span class="si">}</span><span class="s2">. Supported methods are &#39;umap&#39; and &#39;tsne&#39;&quot;</span><span class="p">)</span>
        
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Trained and fit reducer&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">embedding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="n">model</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Fit data to reducer&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model is None. Please provide a model for transform.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="n">clustering_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">labels_</span> <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span> <span class="k">else</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Embedding shape: </span><span class="si">{</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">reducer</span></div>


<div class="viewcode-block" id="remove_noise">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.remove_noise">[docs]</a>
<span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">non_noise_indices</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">non_noise_indices</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">non_noise_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="plot_embedding">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_embedding">[docs]</a>
<span class="k">def</span> <span class="nf">plot_embedding</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">plot_images</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">dot_size</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="c1">#num_clusters = len(unique_labels[unique_labels != 0])</span>
    <span class="n">colors</span><span class="p">,</span> <span class="n">label_to_color_index</span> <span class="o">=</span> <span class="n">assign_colors</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
    <span class="n">cluster_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_plot</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">)</span>
    <span class="n">plot_clusters</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">dot_size</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">image_paths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_images</span><span class="p">:</span>
        <span class="n">plot_umap_images</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="generate_colors">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.generate_colors">[docs]</a>
<span class="k">def</span> <span class="nf">generate_colors</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">,</span> <span class="n">black_background</span><span class="p">):</span>
    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">random_colors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">specific_colors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">255</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">55</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">155</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">specific_colors</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">specific_colors</span><span class="p">):]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">black_background</span><span class="p">:</span>
        <span class="n">random_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">random_colors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">random_colors</span></div>


<div class="viewcode-block" id="assign_colors">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.assign_colors">[docs]</a>
<span class="k">def</span> <span class="nf">assign_colors</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">random_colors</span><span class="p">):</span>
    <span class="n">normalized_colors</span> <span class="o">=</span> <span class="n">random_colors</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">colors_img</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">normalized_colors</span><span class="p">]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">random_colors</span><span class="p">]</span>
    <span class="n">label_to_color_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">colors</span><span class="p">,</span> <span class="n">label_to_color_index</span></div>


<div class="viewcode-block" id="setup_plot">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.setup_plot">[docs]</a>
<span class="k">def</span> <span class="nf">setup_plot</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">black_background</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;figure.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;text.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;xtick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;ytick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.labelcolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;figure.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;text.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;xtick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;ytick.color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;axes.labelcolor&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">})</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="plot_clusters">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_clusters">[docs]</a>
<span class="k">def</span> <span class="nf">plot_clusters</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">,</span> <span class="n">plot_outlines</span><span class="p">,</span> <span class="n">plot_points</span><span class="p">,</span> <span class="n">smooth_lines</span><span class="p">,</span> <span class="n">figuresize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dot_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_centers</span><span class="p">):</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">smooth_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">x_smooth</span><span class="p">,</span> <span class="n">y_smooth</span> <span class="o">=</span> <span class="n">smooth_hull_lines</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plot_outlines</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_smooth</span><span class="p">,</span> <span class="n">y_smooth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">plot_outlines</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_points</span><span class="p">:</span>
            <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">dot_size</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cluster_label</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;Noise&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cluster_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">dot_size</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cluster_label</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;Noise&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;UMAP Dimension 1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;UMAP Dimension 2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">))</span></div>


<div class="viewcode-block" id="plot_umap_images">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_umap_images">[docs]</a>
<span class="k">def</span> <span class="nf">plot_umap_images</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">plot_by_cluster</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">plot_by_cluster</span><span class="p">:</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">plot_images_by_cluster</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_indices</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">embedding</span><span class="p">)),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_images_by_cluster">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_images_by_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">plot_images_by_cluster</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cluster_indices</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">colors</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">image_nr</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_image">[docs]</a>
<span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_zoom</span><span class="p">,</span> <span class="n">remove_image_canvas</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">remove_image_canvas</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">remove_canvas</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">imagebox</span> <span class="o">=</span> <span class="n">OffsetImage</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">img_zoom</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">AnnotationBbox</span><span class="p">(</span><span class="n">imagebox</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_canvas">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.remove_canvas">[docs]</a>
<span class="k">def</span> <span class="nf">remove_canvas</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">]:</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">img_data</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img_data</span><span class="p">)</span>
        <span class="n">alpha_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">img_data_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">img_data</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">img_data_with_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_data_rgb</span><span class="p">,</span> <span class="n">alpha_channel</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RGB&#39;</span><span class="p">:</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">img_data</span> <span class="o">=</span> <span class="n">img_data</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="n">alpha_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">img_data_with_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_data</span><span class="p">,</span> <span class="n">alpha_channel</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported image mode: </span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_data_with_alpha</span></div>


<div class="viewcode-block" id="plot_clusters_grid">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_clusters_grid">[docs]</a>
<span class="k">def</span> <span class="nf">plot_clusters_grid</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">image_nr</span><span class="p">,</span> <span class="n">image_paths</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">num_clusters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No clusters found.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">cluster_images</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">cluster_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">image_nr</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">image_nr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">img_path</span> <span class="o">=</span> <span class="n">image_paths</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">img_array</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
            <span class="n">cluster_images</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_grid</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="plot_grid">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.plot_grid">[docs]</a>
<span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">,</span> <span class="n">black_background</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_images</span><span class="p">)</span>
    <span class="n">max_figsize</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># Set a maximum figure size</span>
    <span class="k">if</span> <span class="n">figuresize</span> <span class="o">*</span> <span class="n">num_clusters</span> <span class="o">&gt;</span> <span class="n">max_figsize</span><span class="p">:</span>
        <span class="n">figuresize</span> <span class="o">=</span> <span class="n">max_figsize</span> <span class="o">/</span> <span class="n">num_clusters</span>

    <span class="n">grid_fig</span><span class="p">,</span> <span class="n">grid_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figuresize</span> <span class="o">*</span> <span class="n">num_clusters</span><span class="p">,</span> <span class="n">figuresize</span><span class="p">),</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;wspace&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;hspace&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">num_clusters</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">grid_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_axes</span><span class="p">]</span>  <span class="c1"># Ensure grid_axes is always iterable</span>
    <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">axes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">grid_axes</span><span class="p">):</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">cluster_images</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span>
        <span class="n">num_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">grid_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_images</span><span class="p">)))</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">/</span> <span class="n">grid_size</span>
        <span class="n">whitespace</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">grid_size</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lable: </span><span class="si">{</span><span class="n">cluster_label</span><span class="si">}</span><span class="s1"> index: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span>

        <span class="n">axes</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="n">grid_size</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">grid_size</span>
            <span class="n">x_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="n">col</span> <span class="o">*</span> <span class="n">image_size</span>
            <span class="n">y_pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">whitespace</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">)</span>
            <span class="n">ax_img</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">inset_axes</span><span class="p">([</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">image_size</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax_img</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    
    <span class="c1"># Add cluster labels beside the UMAP plot</span>
    <span class="n">spacing_factor</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Adjust this value to control the spacing between labels</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cluster_label</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cluster_images</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">colors</span><span class="p">)):</span>
        <span class="n">label_y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spacing_factor</span> <span class="o">/</span> <span class="n">num_clusters</span><span class="p">)</span>  <span class="c1"># Adjust y position for each label</span>
        <span class="n">grid_fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">cluster_label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">figuresize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">black_background</span> <span class="k">else</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">grid_fig</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_y</span> <span class="o">-</span> <span class="mf">0.02</span><span class="p">),</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">grid_fig</span><span class="o">.</span><span class="n">transFigure</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">grid_fig</span></div>


<div class="viewcode-block" id="generate_path_list_from_db">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.generate_path_list_from_db">[docs]</a>
<span class="k">def</span> <span class="nf">generate_path_list_from_db</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">file_metadata</span><span class="p">):</span>
    <span class="n">all_paths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Connect to the database and retrieve the image paths</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading DataBase: </span><span class="si">{</span><span class="n">db_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">file_metadata</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_metadata</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="c1"># If file_metadata is a single string</span>
                    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT png_path FROM png_list WHERE png_path LIKE ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">file_metadata</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_metadata</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># If file_metadata is a list of strings</span>
                    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;SELECT png_path FROM png_list WHERE &quot;</span> <span class="o">+</span> <span class="s2">&quot; OR &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="s2">&quot;png_path LIKE ?&quot;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">file_metadata</span><span class="p">])</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">meta</span><span class="si">}</span><span class="s2">%&quot;</span> <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">file_metadata</span><span class="p">]</span>
                    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If file_metadata is None or empty</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT png_path FROM png_list&quot;</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchmany</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">all_paths</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">])</span>

    <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Database error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">return</span> <span class="n">all_paths</span></div>


<div class="viewcode-block" id="correct_paths">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.correct_paths">[docs]</a>
<span class="k">def</span> <span class="nf">correct_paths</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">base_path</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>

        <span class="k">if</span> <span class="s1">&#39;png_path&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No &#39;png_path&#39; column found in the dataframe.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_paths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">image_paths</span> <span class="o">=</span> <span class="n">df</span>
    
    <span class="n">adjusted_image_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">base_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;/</span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s1">/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjusted_image_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;png_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_image_paths</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">adjusted_image_paths</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adjusted_image_paths</span></div>


<div class="viewcode-block" id="delete_folder">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.delete_folder">[docs]</a>
<span class="k">def</span> <span class="nf">delete_folder</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39; has been deleted.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39; does not exist or is not a directory.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="measure_test_mode">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.measure_test_mode">[docs]</a>
<span class="k">def</span> <span class="nf">measure_test_mode</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>    

    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;test_mode&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;test&#39;</span><span class="p">:</span>
            <span class="n">all_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">])</span>
            <span class="n">random_files</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_files</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;test_nr&#39;</span><span class="p">])</span>

            <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]),</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;merged&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                <span class="n">delete_folder</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">random_files</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">],</span> <span class="n">file</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">file</span><span class="p">))</span>

            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Changed source folder to </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s1"> for test mode&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Test mode enabled, using source folder </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;src&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">settings</span></div>


<div class="viewcode-block" id="preprocess_data">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.preprocess_data">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">filter_by</span><span class="p">,</span> <span class="n">remove_highly_correlated</span><span class="p">,</span> <span class="n">log_data</span><span class="p">,</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">column_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses the given dataframe by applying filtering, removing highly correlated columns,</span>
<span class="sd">    applying log transformation, filling NaN values, and scaling the numeric data.</span>

<span class="sd">    Args:</span>
<span class="sd">    df (pandas.DataFrame): The input dataframe.</span>
<span class="sd">    filter_by (str or None): The channel of interest to filter the dataframe by.</span>
<span class="sd">    remove_highly_correlated (bool or float): Whether to remove highly correlated columns.</span>
<span class="sd">    If a float is provided, it represents the correlation threshold.</span>
<span class="sd">    log_data (bool): Whether to apply log transformation to the numeric data.</span>
<span class="sd">    exclude (list or None): List of features to exclude from the filtering process.</span>
<span class="sd">    verbose (bool): Whether to print verbose output during preprocessing.</span>

<span class="sd">    Returns:</span>
<span class="sd">    numpy.ndarray: The preprocessed numeric data.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If no numeric columns are available after filtering.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Apply filtering based on the `filter_by` parameter</span>
    <span class="k">if</span> <span class="n">filter_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">filter_dataframe_features</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">column_list</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_list</span><span class="p">]</span>
    
    <span class="c1"># Select numerical features</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">])</span>
    
    <span class="c1"># Check if numeric_data is empty</span>
    <span class="k">if</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No numeric columns available after filtering. Please check the filter_by and exclude parameters.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Remove highly correlated columns</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_highly_correlated</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remove_highly_correlated</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">remove_highly_correlated</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
    
    <span class="c1"># Apply log transformation</span>
    <span class="k">if</span> <span class="n">log_data</span><span class="p">:</span>
        <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numeric_data</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="c1"># Fill NaN values with the column mean</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">numeric_data</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    
    <span class="c1"># Scale the numeric data</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">numeric_data</span></div>


<div class="viewcode-block" id="remove_low_variance_columns">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.remove_low_variance_columns">[docs]</a>
<span class="k">def</span> <span class="nf">remove_low_variance_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes columns from the dataframe that have low variance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The DataFrame containing the data.</span>
<span class="sd">    threshold (float): The variance threshold below which columns will be removed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame: The DataFrame with low variance columns removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">numerical_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">low_variance_cols</span> <span class="o">=</span> <span class="n">numerical_cols</span><span class="o">.</span><span class="n">var</span><span class="p">()[</span><span class="n">numerical_cols</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns due to low variance: </span><span class="si">{</span><span class="n">low_variance_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">low_variance_cols</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="remove_highly_correlated_columns">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.remove_highly_correlated_columns">[docs]</a>
<span class="k">def</span> <span class="nf">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes columns from the dataframe that are highly correlated with one another.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    df (pandas.DataFrame): The DataFrame containing the data.</span>
<span class="sd">    threshold (float): The correlation threshold above which columns will be removed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame: The DataFrame with highly correlated columns removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numerical_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">numerical_cols</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
    
    <span class="c1"># Upper triangle of the correlation matrix</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    
    <span class="c1"># Find columns with correlation greater than the threshold</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">upper</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns due to high correlation: </span><span class="si">{</span><span class="n">to_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">to_drop</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="filter_dataframe_features">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.filter_dataframe_features">[docs]</a>
<span class="k">def</span> <span class="nf">filter_dataframe_features</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_low_variance_features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_highly_correlated_features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the dataframe `df` based on the specified `channel_of_interest` and `exclude` parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - df (pandas.DataFrame): The input dataframe to be filtered.</span>
<span class="sd">    - channel_of_interest (str, int, list, None): The channel(s) of interest to filter the dataframe. If None, no filtering is applied. If &#39;morphology&#39;, only morphology features are included.If an integer, only the specified channel is included. If a list, only the specified channels are included.If a string, only the specified channel is included.</span>
<span class="sd">    - exclude (str, list, None): The feature(s) to exclude from the filtered dataframe. If None, no features are excluded. If a string, the specified feature is excluded.If a list, the specified features are excluded.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - filtered_df (pandas.DataFrame): The filtered dataframe based on the specified parameters.</span>
<span class="sd">    - features (list): The list of selected features after filtering.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">count_and_id_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;_id&#39;</span> <span class="ow">in</span> <span class="n">col</span> <span class="ow">or</span> <span class="s1">&#39;count&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;pathogen_pathogen&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pathogen_pathogen&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cell_cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cell_cell&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;nucleus_nucleus&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;nucleus_nucleus&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cytoplasm_cytoplasm&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">count_and_id_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cytoplasm_cytoplasm&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Columns to remove:&quot;</span><span class="p">,</span> <span class="n">count_and_id_columns</span><span class="p">)</span>
        
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">count_and_id_columns</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_of_interest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">drop_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;channel_1&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_2&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_3&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_4&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_of_interest</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_of_interest</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">feature_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">feature_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature_string</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="o">==</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
            <span class="n">morphological_features</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;area_bbox&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;eccentricity&#39;</span><span class="p">,</span> <span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;euler_number&#39;</span><span class="p">,</span> <span class="s1">&#39;solidity&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_0&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_1&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_2&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_3&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_4&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_5&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_6&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_7&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_8&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_9&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_10&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_11&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_12&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_13&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_14&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_15&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_16&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_17&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_18&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_19&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_20&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_21&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_22&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_23&#39;</span><span class="p">,</span> <span class="s1">&#39;zernike_24&#39;</span><span class="p">,</span> <span class="s1">&#39;area_filled&#39;</span><span class="p">,</span> <span class="s1">&#39;convex_area&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent_diameter_area&#39;</span><span class="p">,</span> <span class="s1">&#39;feret_diameter_max&#39;</span><span class="p">]</span>
            <span class="n">morphological_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">base</span> <span class="ow">in</span> <span class="n">item</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">morphological_features</span><span class="p">)]</span>
            <span class="n">columns_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">morphological_columns</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">channel_of_interest</span> <span class="o">!=</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
            <span class="c1"># Remove entries from drop_columns that are also in feature_strings</span>
            <span class="n">drop_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">drop_columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_strings</span><span class="p">]</span>

            <span class="c1"># Remove columns from the DataFrame that contain any entry from drop_columns in the column name</span>
            <span class="n">columns_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">drop_col</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">for</span> <span class="n">drop_col</span> <span class="ow">in</span> <span class="n">drop_columns</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">fs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">feature_strings</span><span class="p">)]</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_to_drop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed columns: </span><span class="si">{</span><span class="n">columns_to_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  
    <span class="k">if</span> <span class="n">remove_low_variance_features</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">remove_low_variance_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">remove_highly_correlated_features</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">remove_highly_correlated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        
    <span class="c1"># Remove columns with NaN values</span>
    <span class="n">before_drop_NaN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">after_drop_NaN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dropped </span><span class="si">{</span><span class="n">before_drop_NaN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">after_drop_NaN</span><span class="si">}</span><span class="s2"> columns with NaN values&quot;</span><span class="p">)</span>

    <span class="c1"># Select numerical features</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">features</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">filtered_df</span><span class="p">,</span> <span class="n">features</span></div>


<span class="c1"># Create a function to check if images overlap</span>
<div class="viewcode-block" id="check_overlap">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.check_overlap">[docs]</a>
<span class="k">def</span> <span class="nf">check_overlap</span><span class="p">(</span><span class="n">current_position</span><span class="p">,</span> <span class="n">other_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">other_position</span> <span class="ow">in</span> <span class="n">other_positions</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">current_position</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other_position</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># Define a function to try random positions around a given point</span>
<div class="viewcode-block" id="find_non_overlapping_position">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.find_non_overlapping_position">[docs]</a>
<span class="k">def</span> <span class="nf">find_non_overlapping_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">offset_range</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Adjust the range for random offsets</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">attempts</span> <span class="o">&lt;</span> <span class="n">max_attempts</span><span class="p">:</span>
        <span class="n">random_offset_x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">)</span>
        <span class="n">random_offset_y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">offset_range</span><span class="p">,</span> <span class="n">offset_range</span><span class="p">)</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">random_offset_x</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">random_offset_y</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check_overlap</span><span class="p">((</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">),</span> <span class="n">image_positions</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span>
        <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>  <span class="c1"># Return the original position if no suitable position found</span></div>


<div class="viewcode-block" id="search_reduction_and_clustering">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.search_reduction_and_clustering">[docs]</a>
<span class="k">def</span> <span class="nf">search_reduction_and_clustering</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">reduction_method</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">reduction_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform dimensionality reduction and clustering on the given data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    numeric_data (np.array): Numeric data to process.</span>
<span class="sd">    n_neighbors (int): Number of neighbors for UMAP or perplexity for tSNE.</span>
<span class="sd">    min_dist (float): Minimum distance for UMAP.</span>
<span class="sd">    metric (str): Metric for UMAP, tSNE, and DBSCAN.</span>
<span class="sd">    eps (float): Epsilon for DBSCAN clustering.</span>
<span class="sd">    min_samples (int): Minimum samples for DBSCAN or number of clusters for KMeans.</span>
<span class="sd">    clustering (str): Clustering method (&#39;DBSCAN&#39; or &#39;KMeans&#39;).</span>
<span class="sd">    reduction_method (str): Dimensionality reduction method (&#39;UMAP&#39; or &#39;tSNE&#39;).</span>
<span class="sd">    verbose (bool): Whether to print verbose output.</span>
<span class="sd">    reduction_param (dict): Additional parameters for the reduction method.</span>
<span class="sd">    embedding (np.array): Precomputed embedding (optional).</span>
<span class="sd">    n_jobs (int): Number of parallel jobs to run.</span>

<span class="sd">    Returns:</span>
<span class="sd">    embedding (np.array): Embedding of the data.</span>
<span class="sd">    labels (np.array): Cluster labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;n_neighbors cannota be less than 2. Setting n_neighbors to </span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">reduction_param</span> <span class="o">=</span> <span class="n">reduction_param</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">reduction_param</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">reduction_param</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;perplexity&#39;</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="s1">&#39;min_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;metric&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">]}</span>
    
    <span class="k">if</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;umap&#39;</span><span class="p">:</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">reduction_param</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s1">&#39;tsne&#39;</span><span class="p">:</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">reduction_param</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported reduction method: </span><span class="si">{</span><span class="n">reduction_method</span><span class="si">}</span><span class="s2">. Supported methods are &#39;umap&#39; and &#39;tsne&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span><span class="p">:</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
        <span class="n">clustering_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported clustering method: </span><span class="si">{</span><span class="n">clustering</span><span class="si">}</span><span class="s2">. Supported methods are &#39;dbscan&#39; and &#39;kmeans&#39;&quot;</span><span class="p">)</span>
    <span class="n">clustering_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">labels_</span> <span class="k">if</span> <span class="n">clustering</span> <span class="o">==</span> <span class="s1">&#39;dbscan&#39;</span> <span class="k">else</span> <span class="n">clustering_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Embedding shape: </span><span class="si">{</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">embedding</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="load_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.load_image">[docs]</a>
<span class="k">def</span> <span class="nf">load_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load and preprocess an image.&quot;&quot;&quot;</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span> <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]),</span>
    <span class="p">])</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="extract_features">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.extract_features">[docs]</a>
<span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="n">image_paths</span><span class="p">,</span> <span class="n">resnet</span><span class="o">=</span><span class="n">resnet50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract features from images using a pre-trained ResNet model.&quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">resnet</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">children</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove the last classification layer</span>

    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">image_paths</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">features</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_normality">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.check_normality">[docs]</a>
<span class="k">def</span> <span class="nf">check_normality</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to check if a feature is normally distributed.&quot;&quot;&quot;</span>
    <span class="n">k2</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">normaltest</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>  <span class="c1"># null hypothesis: x comes from a normal distribution</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="random_forest_feature_importance">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.random_forest_feature_importance">[docs]</a>
<span class="k">def</span> <span class="nf">random_forest_feature_importance</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Random Forest feature importance.&quot;&quot;&quot;</span>
    <span class="n">numeric_features</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cluster_col</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">numeric_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">all_df</span><span class="p">[</span><span class="n">numeric_features</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span>

    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">feature_importances</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">feature_importances_</span>

    <span class="n">importance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;Feature&#39;</span><span class="p">:</span> <span class="n">numeric_features</span><span class="p">,</span>
        <span class="s1">&#39;Importance&#39;</span><span class="p">:</span> <span class="n">feature_importances</span>
    <span class="p">})</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;Importance&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">importance_df</span></div>


<div class="viewcode-block" id="perform_statistical_tests">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.perform_statistical_tests">[docs]</a>
<span class="k">def</span> <span class="nf">perform_statistical_tests</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform ANOVA or Kruskal-Wallis tests depending on normality of features.&quot;&quot;&quot;</span>
    <span class="n">numeric_features</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cluster_col</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">numeric_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cluster_col</span><span class="p">)</span>
    
    <span class="n">anova_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kruskal_results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">numeric_features</span><span class="p">:</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_df</span><span class="p">[</span><span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">][</span><span class="n">feature</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">])]</span>
        
        <span class="k">if</span> <span class="n">check_normality</span><span class="p">(</span><span class="n">all_df</span><span class="p">[</span><span class="n">feature</span><span class="p">]):</span>
            <span class="n">stat</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f_oneway</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">)</span>
            <span class="n">anova_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">feature</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">)</span>
            <span class="n">kruskal_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">feature</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    
    <span class="n">anova_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">anova_results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;ANOVA_Statistic&#39;</span><span class="p">,</span> <span class="s1">&#39;ANOVA_pValue&#39;</span><span class="p">])</span>
    <span class="n">kruskal_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kruskal_results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="s1">&#39;Kruskal_Statistic&#39;</span><span class="p">,</span> <span class="s1">&#39;Kruskal_pValue&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span></div>


<div class="viewcode-block" id="combine_results">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.combine_results">[docs]</a>
<span class="k">def</span> <span class="nf">combine_results</span><span class="p">(</span><span class="n">rf_df</span><span class="p">,</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine the results into a single DataFrame.&quot;&quot;&quot;</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">rf_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">anova_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">kruskal_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Feature&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combined_df</span></div>


<div class="viewcode-block" id="cluster_feature_analysis">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.cluster_feature_analysis">[docs]</a>
<span class="k">def</span> <span class="nf">cluster_feature_analysis</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Random Forest feature importance, ANOVA for normally distributed features,</span>
<span class="sd">    and Kruskal-Wallis for non-normally distributed features. Combine results into a single DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rf_df</span> <span class="o">=</span> <span class="n">random_forest_feature_importance</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">)</span>
    <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span> <span class="o">=</span> <span class="n">perform_statistical_tests</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cluster_col</span><span class="p">)</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">combine_results</span><span class="p">(</span><span class="n">rf_df</span><span class="p">,</span> <span class="n">anova_df</span><span class="p">,</span> <span class="n">kruskal_df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combined_df</span></div>


<span class="k">def</span> <span class="nf">_merge_cells_based_on_parasite_overlap</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge cells in cell_mask if a parasite in parasite_mask overlaps with more than one cell,</span>
<span class="sd">    and if cells share more than a specified perimeter percentage.</span>

<span class="sd">    Args:</span>
<span class="sd">        parasite_mask (ndarray): Mask of parasites.</span>
<span class="sd">        cell_mask (ndarray): Mask of cells.</span>
<span class="sd">        nuclei_mask (ndarray): Mask of nuclei.</span>
<span class="sd">        overlap_threshold (float): The percentage threshold for merging cells based on parasite overlap.</span>
<span class="sd">        perimeter_threshold (float): The percentage threshold for merging cells based on shared perimeter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: The modified cell mask (cell_mask) with unique labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labeled_cells</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>
    <span class="n">labeled_parasites</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">)</span>
    <span class="n">labeled_nuclei</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">nuclei_mask</span><span class="p">)</span>
    <span class="n">num_parasites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_parasites</span><span class="p">)</span>
    <span class="n">num_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">)</span>
    <span class="n">num_nuclei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labeled_nuclei</span><span class="p">)</span>

    <span class="c1"># Merge cells based on parasite overlap</span>
    <span class="k">for</span> <span class="n">parasite_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_parasites</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_parasite_mask</span> <span class="o">=</span> <span class="n">labeled_parasites</span> <span class="o">==</span> <span class="n">parasite_id</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">current_parasite_mask</span><span class="p">])</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="n">overlapping_cell_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Calculate the overlap percentages</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_parasite_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_parasite_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span>
            <span class="p">]</span>
            <span class="c1"># Merge cells if overlap percentage is above the threshold</span>
            <span class="k">for</span> <span class="n">cell_label</span><span class="p">,</span> <span class="n">overlap_percentage</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">,</span> <span class="n">overlap_percentages</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">overlap_percentage</span> <span class="o">&gt;</span> <span class="n">overlap_threshold</span><span class="p">:</span>
                    <span class="n">first_label</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="n">other_label</span> <span class="o">!=</span> <span class="n">first_label</span><span class="p">:</span>
                            <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">==</span> <span class="n">other_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_label</span>

    <span class="c1"># Merge cells based on nucleus overlap</span>
    <span class="k">for</span> <span class="n">nucleus_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nuclei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current_nucleus_mask</span> <span class="o">=</span> <span class="n">labeled_nuclei</span> <span class="o">==</span> <span class="n">nucleus_id</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">current_nucleus_mask</span><span class="p">])</span>
        <span class="n">overlapping_cell_labels</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="n">overlapping_cell_labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_cell_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Calculate the overlap percentages</span>
            <span class="n">overlap_percentages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_nucleus_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_nucleus_mask</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span>
            <span class="p">]</span>
            <span class="c1"># Merge cells if overlap percentage is above the threshold for each cell</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">overlap_percentage</span> <span class="o">&gt;</span> <span class="n">overlap_threshold</span> <span class="k">for</span> <span class="n">overlap_percentage</span> <span class="ow">in</span> <span class="n">overlap_percentages</span><span class="p">):</span>
                <span class="n">first_label</span> <span class="o">=</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">overlapping_cell_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">other_label</span> <span class="o">!=</span> <span class="n">first_label</span><span class="p">:</span>
                        <span class="n">cell_mask</span><span class="p">[</span><span class="n">cell_mask</span> <span class="o">==</span> <span class="n">other_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_label</span>

    <span class="c1"># Check for cells without nuclei and merge based on shared perimeter</span>
    <span class="n">labeled_cells</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>  <span class="c1"># Re-label after merging based on overlap</span>
    <span class="n">cell_regions</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">cell_regions</span><span class="p">:</span>
        <span class="n">cell_label</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span>
        <span class="n">cell_mask_binary</span> <span class="o">=</span> <span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span>
        <span class="n">overlapping_nuclei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nuclei_mask</span><span class="p">[</span><span class="n">cell_mask_binary</span><span class="p">])</span>
        <span class="n">overlapping_nuclei</span> <span class="o">=</span> <span class="n">overlapping_nuclei</span><span class="p">[</span><span class="n">overlapping_nuclei</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_nuclei</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># Cell does not overlap with any nucleus</span>
            <span class="n">perimeter</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">perimeter</span>
            
            <span class="c1"># Dilate the cell to find neighbors</span>
            <span class="n">dilated_cell</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">cell_mask_binary</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">neighbor_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_cells</span><span class="p">[</span><span class="n">dilated_cell</span><span class="p">])</span>
            <span class="n">neighbor_cells</span> <span class="o">=</span> <span class="n">neighbor_cells</span><span class="p">[(</span><span class="n">neighbor_cells</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">neighbor_cells</span> <span class="o">!=</span> <span class="n">cell_label</span><span class="p">)]</span>
            
            <span class="c1"># Calculate shared border length with neighboring cells</span>
            <span class="n">shared_borders</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">neighbor_label</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dilated_cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbor_label</span> <span class="ow">in</span> <span class="n">neighbor_cells</span>
            <span class="p">]</span>
            <span class="n">shared_border_percentages</span> <span class="o">=</span> <span class="p">[</span><span class="n">shared_border</span> <span class="o">/</span> <span class="n">perimeter</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">shared_border</span> <span class="ow">in</span> <span class="n">shared_borders</span><span class="p">]</span>
            
            <span class="c1"># Merge with the neighbor cell with the largest shared border percentage above the threshold</span>
            <span class="k">if</span> <span class="n">shared_borders</span><span class="p">:</span>
                <span class="n">max_shared_border_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">shared_border_percentages</span><span class="p">)</span>
                <span class="n">max_shared_border_percentage</span> <span class="o">=</span> <span class="n">shared_border_percentages</span><span class="p">[</span><span class="n">max_shared_border_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">max_shared_border_percentage</span> <span class="o">&gt;</span> <span class="n">perimeter_threshold</span><span class="p">:</span>
                    <span class="n">cell_mask</span><span class="p">[</span><span class="n">labeled_cells</span> <span class="o">==</span> <span class="n">cell_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor_cells</span><span class="p">[</span><span class="n">max_shared_border_index</span><span class="p">]</span>
    
    <span class="c1"># Relabel the merged cell mask</span>
    <span class="n">relabeled_cell_mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">return_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">relabeled_cell_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

<div class="viewcode-block" id="adjust_cell_masks">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.adjust_cell_masks">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_cell_masks</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">cell_folder</span><span class="p">,</span> <span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process all npy files in the given folders. Merge and relabel cells in cell masks</span>
<span class="sd">    based on parasite overlap and cell perimeter sharing conditions.</span>

<span class="sd">    Args:</span>
<span class="sd">        parasite_folder (str): Path to the folder containing parasite masks.</span>
<span class="sd">        cell_folder (str): Path to the folder containing cell masks.</span>
<span class="sd">        nuclei_folder (str): Path to the folder containing nuclei masks.</span>
<span class="sd">        overlap_threshold (float): The percentage threshold for merging cells based on parasite overlap.</span>
<span class="sd">        perimeter_threshold (float): The percentage threshold for merging cells based on shared perimeter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parasite_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">cell_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    <span class="n">nuclei_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)])</span>
    
    <span class="c1"># Ensure there are matching files in all folders</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parasite_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_files</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of files in the folders do not match.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Match files by name</span>
    <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">parasite_files</span><span class="p">:</span>
        <span class="n">parasite_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parasite_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="n">cell_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cell_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="n">nuclei_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nuclei_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="c1"># Check if the corresponding cell and nuclei mask files exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corresponding cell or nuclei mask file for </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>
        <span class="c1"># Load the masks</span>
        <span class="n">parasite_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">parasite_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nuclei_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">nuclei_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Merge and relabel cells</span>
        <span class="n">merged_cell_mask</span> <span class="o">=</span> <span class="n">_merge_cells_based_on_parasite_overlap</span><span class="p">(</span><span class="n">parasite_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">,</span> <span class="n">nuclei_mask</span><span class="p">,</span> <span class="n">overlap_threshold</span><span class="p">,</span> <span class="n">perimeter_threshold</span><span class="p">)</span>
        
        <span class="c1"># Force 16 bit</span>
        <span class="c1">#merged_cell_mask = merged_cell_mask.astype(np.uint16)</span>
        
        <span class="c1"># Overwrite the original cell mask file with the merged result</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cell_path</span><span class="p">,</span> <span class="n">merged_cell_mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_masks">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.process_masks">[docs]</a>
<span class="k">def</span> <span class="nf">process_masks</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">image_folder</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">read_files_in_batches</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)]</span>
        <span class="n">files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># Sort to ensure matching order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
        <span class="n">properties_list</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;mean_intensity&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">mean_intensity</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">perimeter</span><span class="p">,</span> <span class="s1">&#39;eccentricity&#39;</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">properties_list</span>

    <span class="k">def</span> <span class="nf">cluster_objects</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;perimeter&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;eccentricity&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">])</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kmeans</span>

    <span class="k">def</span> <span class="nf">remove_objects_not_in_largest_cluster</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">largest_cluster_label</span><span class="p">):</span>
        <span class="n">cleaned_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">region</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">largest_cluster_label</span><span class="p">:</span>
                <span class="n">cleaned_mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">label</span>
        <span class="k">return</span> <span class="n">cleaned_mask</span>

    <span class="k">def</span> <span class="nf">plot_clusters</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;perimeter&#39;</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;eccentricity&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">])</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">data_2d</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">data_2d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data_2d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;PCA Component 1&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;PCA Component 2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Object Clustering&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">all_properties</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Step 1: Accumulate properties over all files</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">read_files_in_batches</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">]</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">]</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Measure morphology and intensity</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
            <span class="n">all_properties</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>

    <span class="c1"># Step 2: Perform clustering on accumulated properties</span>
    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">cluster_objects</span><span class="p">(</span><span class="n">all_properties</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="c1"># Step 3: Plot clusters using PCA</span>
        <span class="n">plot_clusters</span><span class="p">(</span><span class="n">all_properties</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Step 4: Remove objects not in the largest cluster and overwrite files in batches</span>
    <span class="n">label_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">read_files_in_batches</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">]</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
            <span class="n">batch_properties</span> <span class="o">=</span> <span class="n">measure_morphology_and_intensity</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">batch_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">label_index</span><span class="p">:</span><span class="n">label_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_properties</span><span class="p">)]</span>
            <span class="n">largest_cluster_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">batch_labels</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">cleaned_mask</span> <span class="o">=</span> <span class="n">remove_objects_not_in_largest_cluster</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">batch_labels</span><span class="p">,</span> <span class="n">largest_cluster_label</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cleaned_mask</span><span class="p">)</span>
            <span class="n">label_index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_properties</span><span class="p">)</span></div>


<div class="viewcode-block" id="merge_regression_res_with_metadata">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.merge_regression_res_with_metadata">[docs]</a>
<span class="k">def</span> <span class="nf">merge_regression_res_with_metadata</span><span class="p">(</span><span class="n">results_file</span><span class="p">,</span> <span class="n">metadata_file</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_metadata&#39;</span><span class="p">):</span>
    <span class="c1"># Read the CSV files into dataframes</span>
    <span class="n">df_results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">results_file</span><span class="p">)</span>
    <span class="n">df_metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">extract_and_clean_gene</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
        <span class="c1"># Extract the part between &#39;[&#39; and &#39;]&#39;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[(.*?)\]&#39;</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Remove &#39;T.&#39; if present</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^T\.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gene</span><span class="p">)</span>
            <span class="c1"># Remove everything after and including &#39;_&#39;</span>
            <span class="n">gene</span> <span class="o">=</span> <span class="n">gene</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gene</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Apply the function to the feature column</span>
    <span class="n">df_results</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_results</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">extract_and_clean_gene</span><span class="p">)</span>
    
    <span class="n">df_metadata</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_metadata</span><span class="p">[</span><span class="s1">&#39;Gene ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># Drop rows where gene extraction failed</span>
    <span class="c1">#df_results = df_results.dropna(subset=[&#39;gene&#39;])</span>
    
    <span class="c1"># Merge the two dataframes on the gene column</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_results</span><span class="p">,</span> <span class="n">df_metadata</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    
    <span class="c1"># Generate the new file name</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">results_file</span><span class="p">)</span>
    <span class="n">new_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base</span><span class="si">}{</span><span class="n">name</span><span class="si">}{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="c1"># Save the merged dataframe to the new file</span>
    <span class="n">merged_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">new_file</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">merged_df</span></div>


<div class="viewcode-block" id="process_vision_results">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.process_vision_results">[docs]</a>
<span class="k">def</span> <span class="nf">process_vision_results</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

    <span class="c1"># Split the &#39;path&#39; column using _map_wells function</span>
    <span class="n">mapped_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_map_wells</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;prc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;row_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cv_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pred&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_ml_results_paths">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_ml_results_paths">[docs]</a>
<span class="k">def</span> <span class="nf">get_ml_results_paths</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;xgboost&#39;</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s2">&quot;channels_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">channel_of_interest</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_of_interest</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;channel_</span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="ow">is</span> <span class="s1">&#39;morphology&#39;</span><span class="p">:</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s1">&#39;morphology&#39;</span>

    <span class="k">elif</span> <span class="n">channel_of_interest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">feature_string</span> <span class="o">=</span> <span class="s1">&#39;all_features&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported channel_of_interest: </span><span class="si">{</span><span class="n">channel_of_interest</span><span class="si">}</span><span class="s2">. Supported values are &#39;int&#39;, &#39;list&#39;, &#39;None&#39;, or &#39;morphology&#39;.&quot;</span><span class="p">)</span>

    <span class="n">res_fldr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">feature_string</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saving results to </span><span class="si">{</span><span class="n">res_fldr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;results.csv&#39;</span><span class="p">)</span>
    <span class="n">permutation_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;permutation.csv&#39;</span><span class="p">)</span>
    <span class="n">feature_importance_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;feature_importance.csv&#39;</span><span class="p">)</span>
    <span class="n">model_metricks_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1">_model.csv&#39;</span><span class="p">)</span>
    <span class="n">permutation_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;permutation.pdf&#39;</span><span class="p">)</span>
    <span class="n">feature_importance_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;feature_importance.pdf&#39;</span><span class="p">)</span>
    <span class="n">shap_fig_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;shap.pdf&#39;</span><span class="p">)</span>
    <span class="n">plate_heatmap_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;plate_heatmap.pdf&#39;</span><span class="p">)</span>
    <span class="n">settings_csv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;ml_settings.csv&#39;</span><span class="p">)</span>
    <span class="n">ml_features</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res_fldr</span><span class="p">,</span> <span class="s1">&#39;ml_features.csv&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_path</span><span class="p">,</span> <span class="n">permutation_path</span><span class="p">,</span> <span class="n">feature_importance_path</span><span class="p">,</span> <span class="n">model_metricks_path</span><span class="p">,</span> <span class="n">permutation_fig_path</span><span class="p">,</span> <span class="n">feature_importance_fig_path</span><span class="p">,</span> <span class="n">shap_fig_path</span><span class="p">,</span> <span class="n">plate_heatmap_path</span><span class="p">,</span> <span class="n">settings_csv</span><span class="p">,</span> <span class="n">ml_features</span></div>


<div class="viewcode-block" id="augment_image">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.augment_image">[docs]</a>
<span class="k">def</span> <span class="nf">augment_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform data augmentation by rotating and reflecting the image.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - image (PIL Image or numpy array): The input image.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - augmented_images (list): A list of augmented images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Convert PIL image to numpy array if necessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    
    <span class="c1"># Handle grayscale images</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_GRAY2BGR</span><span class="p">)</span>

    <span class="c1"># Rotations and reflections</span>
    <span class="n">transformations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Original</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_CLOCKWISE</span><span class="p">,</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_180</span><span class="p">,</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">ROTATE_90_COUNTERCLOCKWISE</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">transformations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>

        <span class="c1"># Reflections</span>
        <span class="n">flipped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">rotated</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flipped</span><span class="p">)</span>

    <span class="c1"># Convert numpy arrays back to PIL images</span>
    <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">augmented_images</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">augmented_images</span></div>


<div class="viewcode-block" id="augment_dataset">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.augment_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">augment_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">is_grayscale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform data augmentation on the entire dataset by rotating and reflecting the images.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - dataset (list of tuples): The input dataset, each entry is a tuple (image, label, filename).</span>
<span class="sd">    - is_grayscale (bool): Flag indicating if the images are grayscale.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - augmented_dataset (list of tuples): A dataset with augmented (image, label, filename) tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">augmented_dataset</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">img</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="n">augmented_images</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Ensure the image is a tensor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected torch.Tensor, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Rotations and reflections</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
            <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>

            <span class="c1"># Reflections</span>
            <span class="n">flipped</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">hflip</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>
            <span class="n">augmented_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flipped</span><span class="p">)</span>

        <span class="c1"># Add augmented images to the dataset</span>
        <span class="k">for</span> <span class="n">aug_img</span> <span class="ow">in</span> <span class="n">augmented_images</span><span class="p">:</span>
            <span class="n">augmented_dataset</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aug_img</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">augmented_dataset</span></div>



<div class="viewcode-block" id="convert_and_relabel_masks">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.convert_and_relabel_masks">[docs]</a>
<span class="k">def</span> <span class="nf">convert_and_relabel_masks</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts all int64 npy masks in a folder to uint16 with relabeling to ensure all labels are retained.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - folder_path (str): The path to the folder containing int64 npy mask files.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="c1"># Load the mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="c1">#print(mask.shape)</span>
        <span class="c1">#print(mask.dtype)</span>
        <span class="c1"># Check the current dtype</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> as it is not int64.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="c1"># Relabel the mask to ensure unique labels within uint16 range</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: The mask in </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> contains values that exceed the uint16 range and will be relabeled.&quot;</span><span class="p">)</span>

        <span class="n">relabeled_mask</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Check that relabeling worked correctly</span>
        <span class="n">unique_relabeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">relabeled_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique_relabeled</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Relabeling failed for </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> as it still contains values that exceed the uint16 range.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="c1"># Convert to uint16</span>
        <span class="n">relabeled_mask</span> <span class="o">=</span> <span class="n">relabeled_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        
        <span class="c1"># Save the converted mask</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">relabeled_mask</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> and saved as uint16_</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="correct_masks">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.correct_masks">[docs]</a>
<span class="k">def</span> <span class="nf">correct_masks</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_load_and_concatenate_arrays</span>

    <span class="n">cell_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="s1">&#39;norm_channel_stack&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_mask_stack&#39;</span><span class="p">)</span>
    <span class="n">convert_and_relabel_masks</span><span class="p">(</span><span class="n">cell_path</span><span class="p">)</span>
    <span class="n">_load_and_concatenate_arrays</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_reads_in_fastq">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.count_reads_in_fastq">[docs]</a>
<span class="k">def</span> <span class="nf">count_reads_in_fastq</span><span class="p">(</span><span class="n">fastq_file</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fastq_file</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">//</span> <span class="mi">4</span></div>



<span class="c1"># Function to determine the CUDA version</span>
<div class="viewcode-block" id="get_cuda_version">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.get_cuda_version">[docs]</a>
<span class="k">def</span> <span class="nf">get_cuda_version</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;nvcc&#39;</span><span class="p">,</span> <span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;release&#39;</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;release &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="all_elements_match">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.all_elements_match">[docs]</a>
<span class="k">def</span> <span class="nf">all_elements_match</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="c1"># Check if all elements in list1 are in list2</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="n">list2</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">)</span></div>


<div class="viewcode-block" id="prepare_batch_for_segmentation">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.prepare_batch_for_segmentation">[docs]</a>
<span class="k">def</span> <span class="nf">prepare_batch_for_segmentation</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
    <span class="c1"># Ensure the batch is of dtype float32</span>
    <span class="k">if</span> <span class="n">batch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># Normalize each image in the batch</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">batch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">batch</span></div>


<div class="viewcode-block" id="check_index">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.check_index">[docs]</a>
<span class="k">def</span> <span class="nf">check_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">split_char</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
    <span class="n">problematic_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_char</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">!=</span> <span class="n">elements</span><span class="p">:</span>
            <span class="n">problematic_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">problematic_indices</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Indices that cannot be separated into 5 parts:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">problematic_indices</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">problematic_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> problematic indices that do not split into </span><span class="si">{</span><span class="n">elements</span><span class="si">}</span><span class="s2"> parts.&quot;</span><span class="p">)</span></div>

    
<span class="c1"># Define the mapping function</span>
<div class="viewcode-block" id="map_condition">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.map_condition">[docs]</a>
<span class="k">def</span> <span class="nf">map_condition</span><span class="p">(</span><span class="n">col_value</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;c1&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;c2&#39;</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="s1">&#39;c3&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">neg</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;neg&#39;</span>
    <span class="k">elif</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;pos&#39;</span>
    <span class="k">elif</span> <span class="n">col_value</span> <span class="o">==</span> <span class="n">mix</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;mix&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;screen&#39;</span></div>

    
<div class="viewcode-block" id="download_models">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.download_models">[docs]</a>
<span class="k">def</span> <span class="nf">download_models</span><span class="p">(</span><span class="n">repo_id</span><span class="o">=</span><span class="s2">&quot;einarolafsson/models&quot;</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downloads all model files from Hugging Face and stores them in the `resources/models` directory </span>
<span class="sd">    within the installed `spacr` package.</span>

<span class="sd">    Args:</span>
<span class="sd">        repo_id (str): The repository ID on Hugging Face (default is &#39;einarolafsson/models&#39;).</span>
<span class="sd">        retries (int): Number of retry attempts in case of failure.</span>
<span class="sd">        delay (int): Delay in seconds between retries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The local path to the downloaded models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Construct the path to the `resources/models` directory in the installed `spacr` package</span>
    <span class="n">package_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">spacr_path</span><span class="p">)</span>
    <span class="n">local_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_dir</span><span class="p">,</span> <span class="s1">&#39;resources&#39;</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">)</span>

    <span class="c1"># Create the local directory if it doesn&#39;t exist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">local_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">local_dir</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">local_dir</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Models already downloaded to: </span><span class="si">{</span><span class="n">local_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">local_dir</span>

    <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">attempt</span> <span class="o">&lt;</span> <span class="n">retries</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># List all files in the repo</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">list_repo_files</span><span class="p">(</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">repo_type</span><span class="o">=</span><span class="s2">&quot;dataset&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Files in repository: </span><span class="si">{</span><span class="n">files</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging print to check file list</span>

            <span class="c1"># Download each file</span>
            <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">download_attempt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retries</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;https://huggingface.co/datasets/</span><span class="si">{</span><span class="n">repo_id</span><span class="si">}</span><span class="s2">/resolve/main/</span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">?download=true&quot;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downloading file from: </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging</span>

                        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HTTP response status: </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Debugging</span>
                        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>

                        <span class="c1"># Save the file locally</span>
                        <span class="n">local_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">local_dir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">iter_content</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">8192</span><span class="p">):</span>
                                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downloaded model file: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">local_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">break</span>  <span class="c1"># Exit the retry loop if successful</span>
                    <span class="k">except</span> <span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">HTTPError</span><span class="p">,</span> <span class="n">requests</span><span class="o">.</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Retrying in </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s2"> seconds...&quot;</span><span class="p">)</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to download </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> after multiple attempts.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">local_dir</span>  <span class="c1"># Return the directory where models are saved</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">HTTPError</span><span class="p">,</span> <span class="n">requests</span><span class="o">.</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error downloading files: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Retrying in </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s2"> seconds...&quot;</span><span class="p">)</span>
            <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Failed to download model files after multiple attempts.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_cytoplasm_mask">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.generate_cytoplasm_mask">[docs]</a>
<span class="k">def</span> <span class="nf">generate_cytoplasm_mask</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a cytoplasm mask from nucleus and cell masks.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - nucleus_mask (np.array): Binary or segmented mask of the nucleus (non-zero values represent nucleus).</span>
<span class="sd">    - cell_mask (np.array): Binary or segmented mask of the whole cell (non-zero values represent cell).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - cytoplasm_mask (np.array): Mask for the cytoplasm (1 for cytoplasm, 0 for nucleus and pathogens).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Make sure the nucleus and cell masks are numpy arrays</span>
    <span class="n">nucleus_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nucleus_mask</span><span class="p">)</span>
    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_mask</span><span class="p">)</span>
    
    <span class="c1"># Generate cytoplasm mask</span>
    <span class="n">cytoplasm_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">nucleus_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cytoplasm_mask</span></div>


<div class="viewcode-block" id="add_column_to_database">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.add_column_to_database">[docs]</a>
<span class="k">def</span> <span class="nf">add_column_to_database</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#Adds a new column to the database table by matching on a common column from the DataFrame.</span>
    <span class="c1">#If the column already exists in the database, it adds the column with a suffix.</span>
    <span class="c1">#NaN values will remain as NULL in the database.</span>

    <span class="c1">#Parameters:</span>
    <span class="c1">#    settings (dict): A dictionary containing the following keys:</span>
    <span class="c1">#    csv_path (str): Path to the CSV file with the data to be added.</span>
    <span class="c1">#    db_path (str): Path to the SQLite database (or connection string for other databases).</span>
    <span class="c1">#    table_name (str): The name of the table in the database.</span>
    <span class="c1">#    update_column (str): The name of the new column in the DataFrame to add to the database.</span>
    <span class="c1">#    match_column (str): The common column used to match rows.</span>

    <span class="c1">#Returns:</span>
    <span class="c1">#    None</span>
    <span class="c1">#&quot;&quot;&quot;</span>

    <span class="c1"># Read the DataFrame from the provided CSV path</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;csv_path&#39;</span><span class="p">])</span>

    <span class="c1"># Replace 0 values with 2 in the update column</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Replacing all 0 values with 2 in the update column.&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Connect to the SQLite database</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;db_path&#39;</span><span class="p">])</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="c1"># Get the existing columns in the database table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PRAGMA table_info(</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">columns_in_db</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>

    <span class="c1"># Add a suffix if the update column already exists in the database</span>
    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">columns_in_db</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">while</span> <span class="n">new_column_name</span> <span class="ow">in</span> <span class="n">columns_in_db</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; already exists. Using new column name: &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_column_name</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]</span>

    <span class="c1"># Add the new column with INTEGER type to the database table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALTER TABLE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> ADD COLUMN </span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2"> INTEGER&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added new column &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; to the table &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Iterate over the DataFrame and update the new column in the database</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">value_to_update</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;update_column&#39;</span><span class="p">]]</span>
        <span class="n">match_value</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]]</span>

        <span class="c1"># Handle NaN values by converting them to None (SQLite equivalent of NULL)</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">value_to_update</span><span class="p">):</span>
            <span class="n">value_to_update</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Prepare and execute the SQL update query</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            UPDATE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span>
<span class="s2">            SET </span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2"> = ?</span>
<span class="s2">            WHERE </span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> = ?</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="p">(</span><span class="n">value_to_update</span><span class="p">,</span> <span class="n">match_value</span><span class="p">))</span>

    <span class="c1"># Commit the transaction and close the connection</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updated &#39;</span><span class="si">{</span><span class="n">new_column_name</span><span class="si">}</span><span class="s2">&#39; in &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;table_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; using &#39;</span><span class="si">{</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;match_column&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fill_holes_in_mask">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.fill_holes_in_mask">[docs]</a>
<span class="k">def</span> <span class="nf">fill_holes_in_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill holes in each object in the mask while keeping objects separated.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        mask (np.ndarray): A labeled mask where each object has a unique integer value.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A mask with holes filled and original labels preserved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the mask is integer-labeled</span>
    <span class="n">labeled_mask</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Create an empty mask to store the result</span>
    <span class="n">filled_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labeled_mask</span><span class="p">)</span>

    <span class="c1"># Fill holes for each labeled object independently</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Create a binary mask for the current object</span>
        <span class="n">object_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labeled_mask</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Fill holes within this object</span>
        <span class="n">filled_object</span> <span class="o">=</span> <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">object_mask</span><span class="p">)</span>

        <span class="c1"># Assign the original label back to the filled object</span>
        <span class="n">filled_mask</span><span class="p">[</span><span class="n">filled_object</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">filled_mask</span></div>


<div class="viewcode-block" id="correct_metadata_column_names">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.correct_metadata_column_names">[docs]</a>
<span class="k">def</span> <span class="nf">correct_metadata_column_names</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;plate_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;plate_name&#39;</span><span class="p">:</span> <span class="s1">&#39;plate&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;column_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="s1">&#39;column&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;column_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="s1">&#39;column&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;row_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;row_name&#39;</span><span class="p">:</span> <span class="s1">&#39;row_name&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;grna_name&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;grna_name&#39;</span><span class="p">:</span> <span class="s1">&#39;grna&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;plate_row&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;plate&#39;</span><span class="p">,</span> <span class="s1">&#39;row_name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;plate_row&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="control_filelist">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.control_filelist">[docs]</a>
<span class="k">def</span> <span class="nf">control_filelist</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;02&#39;</span><span class="p">]):</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="s1">&#39;column&#39;</span><span class="p">:</span>
        <span class="n">filtered_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="s1">&#39;row_name&#39;</span><span class="p">:</span>
        <span class="n">filtered_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">filtered_files</span></div>

    
<div class="viewcode-block" id="rename_columns_in_db">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.rename_columns_in_db">[docs]</a>
<span class="k">def</span> <span class="nf">rename_columns_in_db</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        
        <span class="c1"># Retrieve all table names in the database</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;</span><span class="p">)</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()]</span>

        <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">:</span>
            <span class="c1"># Retrieve column names for each table</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PRAGMA table_info(</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">);&quot;</span><span class="p">)</span>
            <span class="n">columns_info</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns_info</span><span class="p">]</span>

            <span class="c1"># Check if columns &#39;row&#39; or &#39;col&#39; exist</span>
            <span class="n">columns_to_rename</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">&#39;row&#39;</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
                <span class="n">columns_to_rename</span><span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;row_name&#39;</span>
            <span class="k">if</span> <span class="s1">&#39;col&#39;</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
                <span class="n">columns_to_rename</span><span class="p">[</span><span class="s1">&#39;col&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;column_name&#39;</span>
            
            <span class="c1"># Rename columns if necessary</span>
            <span class="k">if</span> <span class="n">columns_to_rename</span><span class="p">:</span>
                <span class="c1"># Rename existing table to a temporary name</span>
                <span class="n">temp_table</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">_old&quot;</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALTER TABLE `</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">` RENAME TO `</span><span class="si">{</span><span class="n">temp_table</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>

                <span class="c1"># Define new columns with updated names</span>
                <span class="n">column_definitions</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">columns_to_rename</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">` </span><span class="si">{</span><span class="n">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns_info</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CREATE TABLE `</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">` (</span><span class="si">{</span><span class="n">column_definitions</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                
                <span class="c1"># Copy data to the new table</span>
                <span class="n">old_columns</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">`&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">])</span>
                <span class="n">new_columns</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">columns_to_rename</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INSERT INTO `</span><span class="si">{</span><span class="n">table</span><span class="si">}</span><span class="s2">` (</span><span class="si">{</span><span class="n">new_columns</span><span class="si">}</span><span class="s2">) SELECT </span><span class="si">{</span><span class="n">old_columns</span><span class="si">}</span><span class="s2"> FROM `</span><span class="si">{</span><span class="n">temp_table</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DROP TABLE `</span><span class="si">{</span><span class="n">temp_table</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error while dropping temporary table &#39;</span><span class="si">{</span><span class="n">temp_table</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># After closing the &#39;with&#39; block, run VACUUM outside of any transaction</span>
    <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;VACUUM;&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="group_feature_class">
<a class="viewcode-back" href="../../spacr.html#spacr.utils.group_feature_class">[docs]</a>
<span class="k">def</span> <span class="nf">group_feature_class</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">feature_groups</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;cytoplasm&#39;</span><span class="p">,</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">,</span> <span class="s1">&#39;pathogen&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;compartment&#39;</span><span class="p">):</span>

    <span class="c1"># Function to determine compartment based on multiple matches</span>
    <span class="k">def</span> <span class="nf">find_feature_class</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">compartments</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartment</span> <span class="k">for</span> <span class="n">compartment</span> <span class="ow">in</span> <span class="n">compartments</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">compartment</span><span class="p">,</span> <span class="n">feature</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
    <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">spacrGraph</span>

    <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">find_feature_class</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">feature_groups</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;channel&#39;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;morphology&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Create new DataFrame with summed importance for each compartment and channel</span>
    <span class="n">importance_sum</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="s1">&#39;importance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_importance_sum&#39;</span><span class="p">)</span>
    <span class="n">total_compartment_importance</span> <span class="o">=</span> <span class="n">importance_sum</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_importance_sum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">importance_sum</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">importance_sum</span><span class="p">,</span>
         <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
             <span class="p">[{</span><span class="n">name</span><span class="p">:</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_importance_sum&#39;</span><span class="p">:</span> <span class="n">total_compartment_importance</span><span class="p">}])]</span>
        <span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Your Name.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>