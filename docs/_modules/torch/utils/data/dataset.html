<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>torch.utils.data.dataset &mdash; spacr 0.0.70 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/documentation_options.js?v=29ed05f3"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            spacr
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">spacr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">torch.utils.data.dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for torch.utils.data.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Dict</span>
<span class="p">)</span>

<span class="c1"># No &#39;default_generator&#39; in torch/__init__.pyi</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">default_generator</span><span class="p">,</span> <span class="n">randperm</span>
<span class="kn">from</span> <span class="nn">torch._utils</span> <span class="kn">import</span> <span class="n">_accumulate</span>

<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Tensor</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Dataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;IterableDataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TensorDataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StackDataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ConcatDataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ChainDataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Subset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;random_split&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">T_dict</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T_co</span><span class="p">]</span>
<span class="n">T_tuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">T_co</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">T_stack</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_stack&#39;</span><span class="p">,</span> <span class="n">T_tuple</span><span class="p">,</span> <span class="n">T_dict</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An abstract class representing a :class:`Dataset`.</span>

<span class="sd">    All datasets that represent a map from keys to data samples should subclass</span>
<span class="sd">    it. All subclasses should overwrite :meth:`__getitem__`, supporting fetching a</span>
<span class="sd">    data sample for a given key. Subclasses could also optionally overwrite</span>
<span class="sd">    :meth:`__len__`, which is expected to return the size of the dataset by many</span>
<span class="sd">    :class:`~torch.utils.data.Sampler` implementations and the default options</span>
<span class="sd">    of :class:`~torch.utils.data.DataLoader`. Subclasses could also</span>
<span class="sd">    optionally implement :meth:`__getitems__`, for speedup batched samples</span>
<span class="sd">    loading. This method accepts list of indices of samples of batch and returns</span>
<span class="sd">    list of samples.</span>

<span class="sd">    .. note::</span>
<span class="sd">      :class:`~torch.utils.data.DataLoader` by default constructs an index</span>
<span class="sd">      sampler that yields integral indices.  To make it work with a map-style</span>
<span class="sd">      dataset with non-integral indices/keys, a custom sampler must be provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses of Dataset should implement __getitem__.&quot;</span><span class="p">)</span>

    <span class="c1"># def __getitems__(self, indices: List) -&gt; List[T_co]:</span>
    <span class="c1"># Not implemented to prevent false-positives in fetcher check in</span>
    <span class="c1"># torch.utils.data._utils.fetch._MapDatasetFetcher</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Dataset[T_co]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConcatDataset[T_co]&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ConcatDataset</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="c1"># No `def __len__(self)` default?</span>
    <span class="c1"># See NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]</span>
    <span class="c1"># in pytorch/torch/utils/data/sampler.py</span>


<span class="k">class</span> <span class="nc">IterableDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An iterable Dataset.</span>

<span class="sd">    All datasets that represent an iterable of data samples should subclass it.</span>
<span class="sd">    Such form of datasets is particularly useful when data come from a stream.</span>

<span class="sd">    All subclasses should overwrite :meth:`__iter__`, which would return an</span>
<span class="sd">    iterator of samples in this dataset.</span>

<span class="sd">    When a subclass is used with :class:`~torch.utils.data.DataLoader`, each</span>
<span class="sd">    item in the dataset will be yielded from the :class:`~torch.utils.data.DataLoader`</span>
<span class="sd">    iterator. When :attr:`num_workers &gt; 0`, each worker process will have a</span>
<span class="sd">    different copy of the dataset object, so it is often desired to configure</span>
<span class="sd">    each copy independently to avoid having duplicate data returned from the</span>
<span class="sd">    workers. :func:`~torch.utils.data.get_worker_info`, when called in a worker</span>
<span class="sd">    process, returns information about the worker. It can be used in either the</span>
<span class="sd">    dataset&#39;s :meth:`__iter__` method or the :class:`~torch.utils.data.DataLoader` &#39;s</span>
<span class="sd">    :attr:`worker_init_fn` option to modify each copy&#39;s behavior.</span>

<span class="sd">    Example 1: splitting workload across all workers in :meth:`__iter__`::</span>

<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(env:TORCH_DOCTEST_DATALOADER)</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +SKIP(&quot;Fails on MacOS12&quot;)</span>
<span class="sd">        &gt;&gt;&gt; class MyIterableDataset(torch.utils.data.IterableDataset):</span>
<span class="sd">        ...     def __init__(self, start, end):</span>
<span class="sd">        ...         super(MyIterableDataset).__init__()</span>
<span class="sd">        ...         assert end &gt; start, &quot;this example code only works with end &gt;= start&quot;</span>
<span class="sd">        ...         self.start = start</span>
<span class="sd">        ...         self.end = end</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __iter__(self):</span>
<span class="sd">        ...         worker_info = torch.utils.data.get_worker_info()</span>
<span class="sd">        ...         if worker_info is None:  # single-process data loading, return the full iterator</span>
<span class="sd">        ...             iter_start = self.start</span>
<span class="sd">        ...             iter_end = self.end</span>
<span class="sd">        ...         else:  # in a worker process</span>
<span class="sd">        ...             # split workload</span>
<span class="sd">        ...             per_worker = int(math.ceil((self.end - self.start) / float(worker_info.num_workers)))</span>
<span class="sd">        ...             worker_id = worker_info.id</span>
<span class="sd">        ...             iter_start = self.start + worker_id * per_worker</span>
<span class="sd">        ...             iter_end = min(iter_start + per_worker, self.end)</span>
<span class="sd">        ...         return iter(range(iter_start, iter_end))</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; # should give same set of data as range(3, 7), i.e., [3, 4, 5, 6].</span>
<span class="sd">        &gt;&gt;&gt; ds = MyIterableDataset(start=3, end=7)</span>

<span class="sd">        &gt;&gt;&gt; # Single-process loading</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=0)))</span>
<span class="sd">        [tensor([3]), tensor([4]), tensor([5]), tensor([6])]</span>

<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(POSIX)</span>
<span class="sd">        &gt;&gt;&gt; # Mult-process loading with two worker processes</span>
<span class="sd">        &gt;&gt;&gt; # Worker 0 fetched [3, 4].  Worker 1 fetched [5, 6].</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non deterministic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=2)))</span>
<span class="sd">        [tensor([3]), tensor([5]), tensor([4]), tensor([6])]</span>

<span class="sd">        &gt;&gt;&gt; # With even more workers</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non deterministic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=12)))</span>
<span class="sd">        [tensor([3]), tensor([5]), tensor([4]), tensor([6])]</span>

<span class="sd">    Example 2: splitting workload across all workers using :attr:`worker_init_fn`::</span>

<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(env:TORCH_DOCTEST_DATALOADER)</span>
<span class="sd">        &gt;&gt;&gt; class MyIterableDataset(torch.utils.data.IterableDataset):</span>
<span class="sd">        ...     def __init__(self, start, end):</span>
<span class="sd">        ...         super(MyIterableDataset).__init__()</span>
<span class="sd">        ...         assert end &gt; start, &quot;this example code only works with end &gt;= start&quot;</span>
<span class="sd">        ...         self.start = start</span>
<span class="sd">        ...         self.end = end</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __iter__(self):</span>
<span class="sd">        ...         return iter(range(self.start, self.end))</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; # should give same set of data as range(3, 7), i.e., [3, 4, 5, 6].</span>
<span class="sd">        &gt;&gt;&gt; ds = MyIterableDataset(start=3, end=7)</span>

<span class="sd">        &gt;&gt;&gt; # Single-process loading</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=0)))</span>
<span class="sd">        [3, 4, 5, 6]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Directly doing multi-process loading yields duplicate data</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=2)))</span>
<span class="sd">        [3, 3, 4, 4, 5, 5, 6, 6]</span>

<span class="sd">        &gt;&gt;&gt; # Define a `worker_init_fn` that configures each dataset copy differently</span>
<span class="sd">        &gt;&gt;&gt; def worker_init_fn(worker_id):</span>
<span class="sd">        ...     worker_info = torch.utils.data.get_worker_info()</span>
<span class="sd">        ...     dataset = worker_info.dataset  # the dataset copy in this worker process</span>
<span class="sd">        ...     overall_start = dataset.start</span>
<span class="sd">        ...     overall_end = dataset.end</span>
<span class="sd">        ...     # configure the dataset to only process the split workload</span>
<span class="sd">        ...     per_worker = int(math.ceil((overall_end - overall_start) / float(worker_info.num_workers)))</span>
<span class="sd">        ...     worker_id = worker_info.id</span>
<span class="sd">        ...     dataset.start = overall_start + worker_id * per_worker</span>
<span class="sd">        ...     dataset.end = min(dataset.start + per_worker, overall_end)</span>
<span class="sd">        ...</span>

<span class="sd">        &gt;&gt;&gt; # Mult-process loading with the custom `worker_init_fn`</span>
<span class="sd">        &gt;&gt;&gt; # Worker 0 fetched [3, 4].  Worker 1 fetched [5, 6].</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=2, worker_init_fn=worker_init_fn)))</span>
<span class="sd">        [3, 5, 4, 6]</span>

<span class="sd">        &gt;&gt;&gt; # With even more workers</span>
<span class="sd">        &gt;&gt;&gt; print(list(torch.utils.data.DataLoader(ds, num_workers=12, worker_init_fn=worker_init_fn)))</span>
<span class="sd">        [3, 4, 5, 6]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">ChainDataset</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="c1"># No `def __len__(self)` default? Subclasses raise `TypeError` when needed.</span>
    <span class="c1"># See NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]</span>


<span class="k">class</span> <span class="nc">TensorDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">]]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dataset wrapping tensors.</span>

<span class="sd">    Each sample will be retrieved by indexing tensors along the first dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        *tensors (Tensor): tensors that have the same size of the first dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tensors</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tensors</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">tensor</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">),</span> <span class="s2">&quot;Size mismatch between tensors&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensors</span> <span class="o">=</span> <span class="n">tensors</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tensor</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensors</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">StackDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">[</span><span class="n">T_stack</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dataset as a stacking of multiple datasets.</span>

<span class="sd">    This class is useful to assemble different parts of complex input data, given as datasets.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; images = ImageDataset()</span>
<span class="sd">        &gt;&gt;&gt; texts = TextDataset()</span>
<span class="sd">        &gt;&gt;&gt; tuple_stack = StackDataset(images, texts)</span>
<span class="sd">        &gt;&gt;&gt; tuple_stack[0] == (images[0], texts[0])</span>
<span class="sd">        &gt;&gt;&gt; dict_stack = StackDataset(image=images, text=texts)</span>
<span class="sd">        &gt;&gt;&gt; dict_stack[0] == {&#39;image&#39;: images[0], &#39;text&#39;: texts[0]}</span>

<span class="sd">    Args:</span>
<span class="sd">        *args (Dataset): Datasets for stacking returned as tuple.</span>
<span class="sd">        **kwargs (Dataset): Datasets for stacking returned as dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">datasets</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supported either ``tuple``- (via ``args``) or&quot;</span>
                                 <span class="s2">&quot;``dict``- (via ``kwargs``) like input/output, but both types are given.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size mismatch between datasets&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">):</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size mismatch between datasets&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one dataset should be passed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitems__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># add batched sampling support when parent datasets supports it.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">dict_batch</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T_dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;__getitems__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">__getitems__</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nested dataset&#39;s output size mismatch.&quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot; Expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">d_sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">dict_batch</span><span class="p">):</span>
                        <span class="n">d_sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">d_sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dict_batch</span><span class="p">):</span>
                        <span class="n">d_sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">dict_batch</span>

        <span class="c1"># tuple data</span>
        <span class="n">list_batch</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;__getitems__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">items</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">__getitems__</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nested dataset&#39;s output size mismatch.&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot; Expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">t_sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">list_batch</span><span class="p">):</span>
                    <span class="n">t_sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">t_sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">list_batch</span><span class="p">):</span>
                    <span class="n">t_sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">tuple_batch</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T_tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">list_batch</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tuple_batch</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span>


<span class="k">class</span> <span class="nc">ConcatDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dataset as a concatenation of multiple datasets.</span>

<span class="sd">    This class is useful to assemble different existing datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (sequence): List of datasets to be concatenated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">datasets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">]]</span>
    <span class="n">cumulative_sizes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">l</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dataset</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;datasets should not be an empty iterable&#39;</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">IterableDataset</span><span class="p">),</span> <span class="s2">&quot;ConcatDataset does not support IterableDataset&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;absolute value of index should not exceed dataset length&quot;</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">idx</span>
        <span class="n">dataset_idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumulative_sizes</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dataset_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_sizes</span><span class="p">[</span><span class="n">dataset_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dataset_idx</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cummulative_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;cummulative_sizes attribute is renamed to &quot;</span>
                      <span class="s2">&quot;cumulative_sizes&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_sizes</span>


<span class="k">class</span> <span class="nc">ChainDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dataset for chaining multiple :class:`IterableDataset` s.</span>

<span class="sd">    This class is useful to assemble different existing dataset streams. The</span>
<span class="sd">    chaining operation is done on-the-fly, so concatenating large-scale</span>
<span class="sd">    datasets with this class will be efficient.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (iterable of IterableDataset): datasets to be chained together</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dataset</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">datasets</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">IterableDataset</span><span class="p">),</span> <span class="s2">&quot;ChainDataset only supports IterableDataset&quot;</span>
            <span class="k">yield from</span> <span class="n">d</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">IterableDataset</span><span class="p">),</span> <span class="s2">&quot;ChainDataset only supports IterableDataset&quot;</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">return</span> <span class="n">total</span>


<span class="k">class</span> <span class="nc">Subset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subset of a dataset at specified indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (Dataset): The whole Dataset</span>
<span class="sd">        indices (sequence): Indices in the whole set selected for subset</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">]</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T_co</span><span class="p">],</span> <span class="n">indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__getitems__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T_co</span><span class="p">]:</span>
        <span class="c1"># add batched sampling support when parent dataset supports it.</span>
        <span class="c1"># see torch.utils.data._utils.fetch._MapDatasetFetcher</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;__getitems__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">__getitems__</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">random_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">lengths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                 <span class="n">generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Generator</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_generator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Subset</span><span class="p">[</span><span class="n">T</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly split a dataset into non-overlapping new datasets of given lengths.</span>

<span class="sd">    If a list of fractions that sum up to 1 is given,</span>
<span class="sd">    the lengths will be computed automatically as</span>
<span class="sd">    floor(frac * len(dataset)) for each fraction provided.</span>

<span class="sd">    After computing the lengths, if there are any remainders, 1 count will be</span>
<span class="sd">    distributed in round-robin fashion to the lengths</span>
<span class="sd">    until there are no remainders left.</span>

<span class="sd">    Optionally fix the generator for reproducible results, e.g.:</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; generator1 = torch.Generator().manual_seed(42)</span>
<span class="sd">        &gt;&gt;&gt; generator2 = torch.Generator().manual_seed(42)</span>
<span class="sd">        &gt;&gt;&gt; random_split(range(10), [3, 7], generator=generator1)</span>
<span class="sd">        &gt;&gt;&gt; random_split(range(30), [0.3, 0.3, 0.4], generator=generator2)</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (Dataset): Dataset to be split</span>
<span class="sd">        lengths (sequence): lengths or fractions of splits to be produced</span>
<span class="sd">        generator (Generator): Generator used for the random permutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">subset_lengths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fraction at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is not between 0 and 1&quot;</span><span class="p">)</span>
            <span class="n">n_items_in_split</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="p">)</span>
            <span class="n">subset_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_items_in_split</span><span class="p">)</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">subset_lengths</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="c1"># add 1 to all the lengths in round-robin fashion until the remainder is 0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remainder</span><span class="p">):</span>
            <span class="n">idx_to_add_at</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset_lengths</span><span class="p">)</span>
            <span class="n">subset_lengths</span><span class="p">[</span><span class="n">idx_to_add_at</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">subset_lengths</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of split at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is 0. &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;This might result in an empty dataset.&quot;</span><span class="p">)</span>

    <span class="c1"># Cannot verify that dataset is Sized</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>    <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sum of input lengths does not equal the length of the input dataset!&quot;</span><span class="p">)</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">randperm</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">),</span> <span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># type: ignore[arg-type, call-overload]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">offset</span> <span class="o">-</span> <span class="n">length</span> <span class="p">:</span> <span class="n">offset</span><span class="p">])</span> <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_accumulate</span><span class="p">(</span><span class="n">lengths</span><span class="p">),</span> <span class="n">lengths</span><span class="p">)]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>